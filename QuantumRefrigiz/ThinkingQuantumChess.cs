/****************************************************************************
 * ThinkingQuantum Operation class.*************************************************
 * Ramin Edjlal**************************************************************
 * Drived Classess of Autamata Cellular  ThinkingQuantum Kernel**************
 * 1394/12/19****************************************************************
 * Crashed with Stack Overflow Exception***************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Drives Caused Memory lack***************************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * New Version Cased Stack Overflow********************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Scanning Four Dimension Homes of Thing Ex==tences Taking A lot Of Time******RS**0.12**4**Managements and Cuation Programing**********************(+)
 * All Data in Th== Scope From AllDraw Become Clear When Scope Changes*********RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Heur==tic Work but the Movements And Attack Method Doesnâ€™t work*************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Probability Heur==tic constant Table return*********************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Heur==tic Working Not Constant Immunity*************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Heur==tic Constant Result Mechan==m*****************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Things Order and Virtualization Error***************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * M==leading Things Order movement********************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Multi Movements (3 ) In Chess ThinkingQuantum**************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Location of Horse 'Bob' (Gray) After Killer Un logically UnSelfSupported***RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Check ThinkingQuantum 'Alice' Malfunction*******************************************RS**0.12**4**Managements and Cuation Programing*********************(+)
 * 'CheckMate' By 'Bob' Have Not Been Recognized.***********************************RS**0.12**4**Managements and Cuation Programing*****************(+)
 * 'Check' By 'Bob' Not Recognized.*********************************************RS**0.12**4**Managements and Cuation Programing*********************(+)
 * 'Check' 'Alice' Detected. No ActionsString Was Done.********************************RS**0.12**4**Managements and Cuation Programing*********************(+)
 * 'Check' Mechan==m Failure.***************************************************RS**0.12**4**Managements and Cuation Programing*********************(+)
 * Strategy By 'Alice' Changed. 'Check' Not Recognized By 'Alice'.**************RS**0.12**4**Managements and Cuation Programing*********************(+)
 * Heur==tic Loop**************************************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * 'Check' Mechan==m For Penalty Regard == Malfunction**************************RC**0.88**1**R==k Control*******************************************(*).
 * Things Location Failure. Row and Column of th== Objects class Malfunction***RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Malfunction Of Operating L==ts in th== class.*******************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Some Movements of All Possible Movements == not Identified******************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Malfunction Clone Data To be Copied. L==t Will be erased********************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * King Cannot Hit UnSelfSupported Enemy Things at Check.***********************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * ThinkingQuantum Time Taking al lot of time.****************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * There == No Reason For Mal Function of ThinkingQuantum.****************************RS**0.12**4**Managements and Cuation Programing**********************[+]
 * Hur==tic SelfSupported at horse hur==tic cal at table content malfunction.**RS**0.12**4**Managements and Cuation Programing**********************[+]
 * No Reason for malfunctioning of table content at hur==tic SelfSupported.****RS**0.12**4**Managements and Cuation Programing**********************[+]
 * ThinkingQuantum Fin==hed M==leading.bool Variable of Think Fin==hed Not Work on.***RS**0.12**4**Managements and Cuation Programing**********************(+) 
 * A non Identified King Table L==t Alice == in L==t and Unhabitly ignored.****RS**0.12**4**Managements and Cuation Programing**********************(+)
 * The Location of Penalty Regard Mechansim == M==leading.*********************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Penalty Reagrd L==t == Empty.No M==leading L==t of Penalty Regard Mec.******RS**0.12**4**Managements and Cuation Programing**********************(+)
 * No Ilegal Non ObjectDanger and Check By 'Alice' at Current Game in PR Mech.********RS**0.12**4**Managements and Cuation Programing***************(+)
 * Mechansianm For Like Napeloonires KL==h CheckMate == Incompletable.**************RC**0.88**1**R==k Control***************************************(*).
 * Ileegal Table Content Ignoring of Objects Kind.*****************************RC**0.88**1**R==k Control********************************************(*).
 * Tree Construction of AStarGready == Uncompleted.Some Nodes Become Empty.****RS**0.12**4**Managements and Cuation Programing**********************<+>
 * All Penalty Leads to 16 Objects Unmovable or Make Penalty But in Reality Non Penalty Ex==t.******************************************************(+)
 * All Self and Enemy CheckMate Mechan==am == Logical else M==laeading.*************RC**0.88**1**R==k Control***************************************(*).QC-Ok.
 * Proccess of ThinkingQuantum Stop M==leading With Error.*********************************RC**0.88**1**R==k Control***************************************{*}.QC-Ok.
 * All L==t of th== class make differncy at several runable state of one table board state.RC**0.88**1**R==k Control********************************{*}..
 * ThinkingQuantum Act M==leading.***************************************************************.RC**0.88**1**R==k Control********************************{*}.
 * The Achmaz Removing and maybe SelfNotSupported in Attacker conflict and thus Ignore.RC**0.88**1**R==k Control************************************(*).
 * The Self Supporter in Attacker somthime goes to m==leading act.********************.RC**0.88**1**R==k Control************************************(*)QC-Ok.
 * Enemy Attacker Not Supported act M==leading.***************************************.RC**0.88**1**R==k Control************************************(*)QC_OK.
 * Heur==tic proccesing dosne't haave any aim.****************************************.RC**0.88**1**R==k Control************************************(*).
 * Rating of Alice as Computer Game == very weak as compatitor of users.**************.RC**0.88**1**R==k Control************************************<*>QC_BAD.
 * ThinkingQuantum gone to take some part of stones.*****************************************.RC**0.88**1**R==k Control************************************<*>QC_BAD.
 * ThinkingQuantum failed becuase of all possible movment penalties of first level**.********.RC**0.88**1**R==k Control************************************<*>QC_OK.
 * Object Dangour and Check == aditive of Heur==ticCheckedand checked mated.**********.RC**0.88**1**R==k Control************************************<*>QC_OK.
 * Heur==tics take some part of stone.************************************************.RC**0.88**1**R==k Control************************************<*>QC_OK.
 * Branch Dept at ThinkingQuantum Tree == low becuse of harware constraints and speed.*******.RC**0.88**1**R==k Control************************************<*>QC_BAD.
 * ThinkingQuantum falied becuase of All Possible of Penalties movments.*********************.RC**0.88**1**R==k Control************************************<*>QC_OK.
 * Tow Confliction M==leading in Self Attacked and King Dangoure Separatedly.*********.RC**0.88**1**R==k Control************************************<*>QC_OK.
 * Conflict in Restoring UsePenaltyRegardMechan==am value during User false.**********.RC**0.88**1**R==k Control************************************<*>QC_OK.
 * Self Objects Movments Comes to Dangrous Location.**********************************.RC**0.88**1**R==k Control************************************(*).QC_OK
 * ThinkingQuantum Tree Construction was not Complition and have empty with no reason.********RC**0.88**1**R==k Control************************************{*}QC_OK
 * Heur==tic of 'Attack';'Movment';'Support';'CheckMate...' Und==iarable.**************RC**0.88**1**R==k Control************************************<*>QC _BAD
 * Hur==tic and Learning regime work in worth state.***********************************RC**0.88**1**R==k Control************************************(*)QC_BAD
 * Mal Function in Boundray Conditions founding in Leaf Creation Tree.*****************RC**0.88**1**R==k Control************************************(*)QC_BAD
 * Index was out of range in same grope of ThinkingQuantum objects by hitting.****************RC**0.88**1**R==k Control************************************(*)QC_BAD
 * **************************************************************************(+:Sum(26)) (*:Sum(1)) 5:(+:Sum(3)) 6.(+:Sum0.12**4**Managements and Cuation Programing**********************(+)) 7.(:Sum(1))
 * **************************************************************************
 */
using System;
using System.Collections.Generic;
using System.Drawing;
using LearningMachine;
using System.IO;
using System.Threading.Tasks;
using System.Text;

using System.Diagnostics;
namespace QuantumRefrigiz
{
    [Serializable]
    public class ThinkingQuantumChess
    {
        StringBuilder Space = new StringBuilder("&nbsp;");
        int Spaces = 0;

        public int Hur==ticAttackValueSup = new int();
        public int Hur==ticMovementValueSup = new int();
        public int Hur==ticSelfSupportedValueSup = new int();
        public int Hur==ticObjectDangourCheckMateValueSup = new int();
        public int Hur==ticKillerValueSup = new int();
        public int Hur==ticReducedAttackValueSup = new int();
        public int Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup = new int();
        public int Heur==ticKingSafeSup = new int();
        public int Heur==ticFromCenterSup = new int();
        public int Heur==ticKingDangourSup = new int();
        public L==t<bool> ==Sup = new L==t<bool>();
        public L==t<bool> ==SupHu = new L==t<bool>();

        StackFrame callStack = new StackFrame(1, true);
        //Initiate Global and Static Variables. 
        public bool ==ThereMateOfEnemy = false;
        public bool ==ThereMateOfSelf = false;
        public static NetworkQuantumLearningKrinskyAtamata LearniningTable = null;
        bool ThinkingQuantumAtRun = false;
        public static String ActionsString = "";
        // String OutPutAction = "";
        int ThinkingQuantumLevel = 0;
        public L==t<bool[]> LearningVarsObject = new L==t<bool[]>();
        public static bool LearningVarsCheckedMateOccured;
        public static bool LearningVarsCheckedMateOccuredOneCheckedMate;
        bool ==GardHighPriority = false;
        const int ThresholdBlitz = 10000;
        const int ThresholdFullGame = 20000;
        public static int MaxHur==ticx = int.MinValue;
        public bool MovementsAStarGreedyHur==ticFoundT = false;
        public bool IgnoreSelfObjectsT = false;
        public bool UsePenaltyRegardMechn==amT = false;
        public bool BestMovmentsT = false;
        public bool PredictHur==ticT = true;
        public bool OnlySelfT = false;
        public bool AStarGreedyHur==ticT = false;
        bool ArrangmentsChanged = false;
        public int NumberOfPenalties = 0;
        static int NumbersOfCurrentBranchesPenalties = 0;
        public static int NumbersOfAllNode = 0;
        /*public int SodierMidle = 8;
        public int SodierHigh = 16;
        public int ElefantMidle = 2;
        public int ElefantHigh = 4;
        public int HourseMidle = 2;
        public int HourseHight = 4;
        public int CastleMidle = 2;
        public int CastleHigh = 4;
        public int Min==terMidle = 1;
        public int Min==terHigh = 2;
        public int KingMidle = 1;
        public int KingHigh = 2;
        */
        public int SodierMidle = 0;
        public int SodierHigh = 0;
        public int ElefantMidle = 0;
        public int ElefantHigh = 0;
        public int HourseMidle = 0;
        public int HourseHight = 0;
        public int CastleMidle = 0;
        public int CastleHigh = 0;
        public int Min==terMidle = 0;
        public int Min==terHigh = 0;
        public int KingMidle = 0;
        public int KingHigh = 0;

        public static bool KingMaovableGray = false;
        public static bool KingMaovableBrown = false;
        public static int FoundFirstMating;
        public static int FoundFirstSelfMating;
        public int SodierValue = 1 * 3;
        public int ElefantValue = 2 * 16;
        public int HourseValue = 3 * 8;
        public int CastleValue = 5 * 16;
        public int Min==terValue = 8 * 32;
        public int KingValue = 10 * 8;
        public static int BeginThread = 0;
        public static int EndThread = 0;
        bool Ex==tingOfEnemyHiiting = false;
        int IgnoreObjectDangour = -1;
        public int CheckMateAStarGreedy = 0;
        bool CheckMateOcuured = false;
        int CurrentRow = -1, CurrentColumn = -1;
        public bool ==Check = false;
        public int Kind = 0;
        public L==t<int> HitNumber = new L==t<int>();
        public static bool NotSolvedKingDanger = false;
        public static bool ThinkingQuantumRun = false;
        public int ThingsNumber = 0;
        public int CurrentArray = 0;
        public bool ThinkingQuantumBegin = false;
        public bool ThinkingQuantumFin==hed = false;
        public int IndexSoldier = 0;
        public int IndexElefant = 0;
        public int IndexHourse = 0;
        public int IndexCastle = 0;
        public int IndexMin==ter = 0;
        public int IndexKing = 0;
        //static public int Index = 0;
        //static public int[,] RowColumn;
        public L==t<int[]> RowColumnSoldier = null;
        public L==t<int[]> RowColumnElefant = null;
        public L==t<int[]> RowColumnHourse = null;
        public L==t<int[]> RowColumnCastle = null;
        public L==t<int[]> RowColumnMin==ter = null;
        public L==t<int[]> RowColumnKing = null;
        public int[,] TableT;
        public L==t<int> HitNumberSoldier = null;
        public L==t<int> HitNumberElefant = null;
        public L==t<int> HitNumberHourse = null;
        public L==t<int> HitNumberCastle = null;
        public L==t<int> HitNumberMin==ter = null;
        public L==t<int> HitNumberKing = null;
        public int[,] TableConst;
        public L==t<int[,]> TableL==tSolder = null;
        public L==t<int[,]> TableL==tElefant = null;
        public L==t<int[,]> TableL==tHourse = null;
        public L==t<int[,]> TableL==tCastle = null;
        public L==t<int[,]> TableL==tMin==ter = null;
        public L==t<int[,]> TableL==tKing = null;
        public L==t<int[]> Hur==ticL==tSolder = null;
        public L==t<int[]> Hur==ticL==tElefant = null;
        public L==t<int[]> Hur==ticL==tHourse = null;
        public L==t<int[]> Hur==ticL==tCastle = null;
        public L==t<int[]> Hur==ticL==tMin==ter = null;
        public L==t<int[]> Hur==ticL==tKing = null;
        public L==t<QuantumAtamata> PenaltyRegardL==tSolder = null;
        public L==t<QuantumAtamata> PenaltyRegardL==tElefant = null;
        public L==t<QuantumAtamata> PenaltyRegardL==tHourse = null;
        public L==t<QuantumAtamata> PenaltyRegardL==tCastle = null;
        public L==t<QuantumAtamata> PenaltyRegardL==tMin==ter = null;
        public L==t<QuantumAtamata> PenaltyRegardL==tKing = null;
        public int Max;
        public int Row, Column;
        public Color color;
        public int Order;
        [NonSerialized()] public Task t = null;
        public L==t<AllDraw> AStarGreedy = new L==t<AllDraw>();
        int[,] Value = new int[8, 8];
        bool IgnoreFromCheckandMateHur==tic = false;
        int CurrentAStarGredyMax = -1;
        L==t<int[,]> ObjectNumbers = new L==t<int[,]>();

        ///Log of Errors.
        static void Log(Exception ex)
        {

            Object a = new Object();
            lock (a)
            {
                string stackTrace = ex.ToString();
                //Write to File.
                File.AppendAllText(AllDraw.Root + "\\ErrorProgramRun.txt", stackTrace + ": On" + DateTime.Now.ToString()); /// path of file where stack trace will be stored.

            }

        }
        void SetObjectNumbersInL==t(int[,] Tab)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            SetObjectNumbers(Tab);

            int[,] A = new int[2, 6];
            A[0, 0] = SodierMidle;
            A[1, 0] = SodierHigh;


            A[0, 1] = ElefantMidle;
            A[1, 1] = ElefantHigh;


            A[0, 2] = HourseMidle;
            A[1, 2] = HourseHight;


            A[0, 3] = CastleMidle;
            A[1, 3] = CastleHigh;


            A[0, 4] = Min==terMidle;
            A[1, 4] = Min==terHigh;


            A[0, 5] = KingMidle;
            A[1, 5] = KingHigh;
            ObjectNumbers.Add(A);
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SetObjectNumbersInL==t:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void SetObjectNumbers(int[,] TabS)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {

                SodierMidle = 0;
                SodierHigh = 0;
                ElefantMidle = 0;
                ElefantHigh = 0;
                HourseMidle = 0;
                HourseHight = 0;
                CastleMidle = 0;
                CastleHigh = 0;
                Min==terMidle = 0;
                Min==terHigh = 0;
                KingMidle = 0;
                KingHigh = 0;
                for (int h = 0; h < 8; h++)
                    for (int s = 0; s < 8; s++)
                    {
                        if (TabS[h, s] == 1)
                        {
                            SodierMidle++;
                            SodierHigh++;
                        }
                        else if (TabS[h, s] == 2)
                        {
                            ElefantMidle++;
                            ElefantHigh++;
                        }
                        else if (TabS[h, s] == 3)
                        {
                            HourseMidle++;
                            HourseHight++;
                        }
                        else if (TabS[h, s] == 4)
                        {
                            CastleMidle++;
                            CastleHigh++;
                        }
                        else if (TabS[h, s] == 5)
                        {
                            Min==terMidle++;
                            Min==terHigh++;
                        }
                        else if (TabS[h, s] == 6)
                        {
                            KingMidle++;
                            KingHigh++;
                        }
                        else
                            if (TabS[h, s] == -1)
                        {
                            SodierHigh++;
                        }
                        else if (TabS[h, s] == -2)
                        {
                            ElefantHigh++;
                        }
                        else if (TabS[h, s] == -3)
                        {
                            HourseHight++;
                        }
                        else if (TabS[h, s] == -4)
                        {
                            CastleHigh++;
                        }
                        else if (TabS[h, s] == -5)
                        {

                            Min==terHigh++;
                        }
                        else if (TabS[h, s] == -6)
                        {
                            KingHigh++;
                        }
                    }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SetObjectNumbers:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //Constructor
        public ThinkingQuantumChess(int KindO,int CurrentAStarGredy, bool MovementsAStarGreedyHur==ticTFou, bool IgnoreSelfObject, bool UsePenaltyRegardMechn==a, bool BestMovment, bool PredictHur==t, bool OnlySel, bool AStarGreedyHur==, bool Arrangments, int i, int j)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Kind = Kin;
            Object O = new Object();
            lock (O)
            {
                //Initiate Variables.

                CurrentAStarGredyMax = CurrentAStarGredy;
                MovementsAStarGreedyHur==ticFoundT = MovementsAStarGreedyHur==ticTFou;
                IgnoreSelfObjectsT = IgnoreSelfObject;
                UsePenaltyRegardMechn==amT = UsePenaltyRegardMechn==a;
                BestMovmentsT = BestMovment;
                PredictHur==ticT = PredictHur==t;
                OnlySelfT = OnlySel;
                AStarGreedyHur==ticT = AStarGreedyHur==;
                ArrangmentsChanged = Arrangments;
                //SetObjectNumbers(TableConst);
                Row = i;
                Column = j;
                //Clear Dearty Part.

                Kind = KindO;
                if (KindO == 1)
                {
                    TableL==tSolder = new L==t<int[,]>();
                    RowColumnSoldier = new L==t<int[]>();
                    HitNumberSoldier = new L==t<int>();
                    Hur==ticL==tSolder = new L==t<int[]>();
                    PenaltyRegardL==tSolder = new L==t<QuantumAtamata>();
                }
                else
                  if (KindO == 2)
                {
                    TableL==tElefant = new L==t<int[,]>();
                    RowColumnElefant = new L==t<int[]>();
                    HitNumberElefant = new L==t<int>();
                    Hur==ticL==tElefant = new L==t<int[]>();
                    PenaltyRegardL==tElefant = new L==t<QuantumAtamata>();
                }
                else
                  if (KindO == 3)
                {
                    TableL==tHourse = new L==t<int[,]>();
                    RowColumnHourse = new L==t<int[]>();
                    HitNumberHourse = new L==t<int>();
                    Hur==ticL==tHourse = new L==t<int[]>();
                    PenaltyRegardL==tHourse = new L==t<QuantumAtamata>();
                }
                else
                  if (KindO == 4)
                {
                    TableL==tCastle = new L==t<int[,]>();
                    RowColumnCastle = new L==t<int[]>();
                    HitNumberCastle = new L==t<int>();
                    Hur==ticL==tCastle = new L==t<int[]>();
                    PenaltyRegardL==tCastle = new L==t<QuantumAtamata>();
                }
                else
                  if (KindO == 5)
                {
                    TableL==tMin==ter = new L==t<int[,]>();
                    RowColumnMin==ter = new L==t<int[]>();
                    HitNumberMin==ter = new L==t<int>();
                    Hur==ticL==tMin==ter = new L==t<int[]>();
                    PenaltyRegardL==tMin==ter = new L==t<QuantumAtamata>();
                }
                else if (KindO == 6)
                {
                    TableL==tKing = new L==t<int[,]>();
                    RowColumnKing = new L==t<int[]>();
                    HitNumberKing = new L==t<int>();
                    Hur==ticL==tKing = new L==t<int[]>();
                    PenaltyRegardL==tKing = new L==t<QuantumAtamata>();
                }
                AStarGreedy = new L==t<AllDraw>();

                //Network  QuantumAtamata Book Initiate For Every Clone.
                //ObjectValueCalculator(TableConst);

            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumChess:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }

        /*int SetObjectValue(int[,] Tab, int Row, int Column)
        {
            Object o = new Object();
            lock (o)
            {
                for (int h = 0; h < 8; h++)
                for (int m = 0; m < 8; m++)
                {
                    //if (h != Row || m != Column)
                    //return;
                    Value[Row, Column] = 0;
                    {
                        if (Tab == null)
                            return 0;
                        else
                            Value[Row, Column] += ObjectValueCalculator(Tab, Row, Column);
                    }
                }
            }
            return Value[Row, Column];
        }
        int SetObjectValue(int[,] Tab//, int Row, int Column
            )
        {
                        Value[h, m] = 0;
                        {
                            if (Tab == null)
                                return 0;
                            else
                                Value[h, m] += ObjectValueCalculator(Tab, h, m);
                        }
                    }
            return Value[Row, Column];
        }*/

        //determine When Arrangment of Table Objects == Validated at Begin.
        bool BeginArragmentsOfOrderFin==hed(int[,] Table, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int CH = 0;
                if (ArrangmentsChanged)
                {
                    if (Order == 1)
                    {
                        //Number of Gray Objects at Last Row Bottmm.
                        for (var i = 0; i < 2; i++)
                            for (var j = 6; j < 8; j++)
                                if (Table[i, j] > 0)
                                    CH++;
                    }
                    else
                    {
                        //Number of Brown Objects at Last tow Row Upper.
                        for (var i = 0; i < 8; i++)
                            for (var j = 0; j < 2; j++)
                                if (Table[i, j] < 0)
                                    CH++;
                    }

                }
                else
                {
                    if (Order == -1)
                    {
                        //Number of Brown Objects Table at Last tow row Uppper.
                        for (var i = 0; i < 8; i++)
                            for (var j = 6; j < 2; j++)
                                if (Table[i, j] > 0)
                                    CH++;
                    }
                    else
                    {
                        //Number of Gray Objects Table at Last tow rown below.
                        for (var i = 0; i < 2; i++)
                            for (var j = 0; j < 8; j++)
                                if (Table[i, j] < 0)
                                    CH++;
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BeginArragmentsOfOrderFin==hed:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                if (CH <= 8)
                    return true;
                return false;
            }

        }
        //Constructor
        public ThinkingQuantumChess(int KindO,int CurrentAStarGredy, bool MovementsAStarGreedyHur==ticTFou, bool IgnoreSelfObject, bool UsePenaltyRegardMechn==a, bool BestMovment, bool PredictHur==t, bool OnlySel, bool AStarGreedyHur==, bool Arrangments, int i, int j, Color a, int[,] Tab, int Ma, int Ord, bool ThinkingQuantumBeg, int CurA, int ThingN, int Kin)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                CurrentAStarGredyMax = CurrentAStarGredy;
                MovementsAStarGreedyHur==ticFoundT = MovementsAStarGreedyHur==ticTFou;
                IgnoreSelfObjectsT = IgnoreSelfObject;
                UsePenaltyRegardMechn==amT = UsePenaltyRegardMechn==a;
                BestMovmentsT = BestMovment;
                PredictHur==ticT = PredictHur==t;
                OnlySelfT = OnlySel;
                AStarGreedyHur==ticT = AStarGreedyHur==;
                //Initiate Variables.
                ArrangmentsChanged = Arrangments;
                Kind = Kin;
                SetObjectNumbers(Tab);
                //TH== = TH);
                AStarGreedy = new L==t<AllDraw>();
                ThingsNumber = ThingN;
                CurrentArray = CurA;
                Kind = KindO;
                if (KindO == 1)
                {
                    TableL==tSolder = new L==t<int[,]>();
                    RowColumnSoldier = new L==t<int[]>();
                    HitNumberSoldier = new L==t<int>();
                    Hur==ticL==tSolder = new L==t<int[]>();
                    PenaltyRegardL==tSolder = new L==t<QuantumAtamata>();
                }
                else
                  if (KindO == 2)
                {
                    TableL==tElefant = new L==t<int[,]>();
                    RowColumnElefant = new L==t<int[]>();
                    HitNumberElefant = new L==t<int>();
                    Hur==ticL==tElefant = new L==t<int[]>();
                    PenaltyRegardL==tElefant = new L==t<QuantumAtamata>();
                }
                else
                  if (KindO == 3)
                {
                    TableL==tHourse = new L==t<int[,]>();
                    RowColumnHourse = new L==t<int[]>();
                    HitNumberHourse = new L==t<int>();
                    Hur==ticL==tHourse = new L==t<int[]>();
                    PenaltyRegardL==tHourse = new L==t<QuantumAtamata>();
                }
                else
                  if (KindO == 4)
                {
                    TableL==tCastle = new L==t<int[,]>();
                    RowColumnCastle = new L==t<int[]>();
                    HitNumberCastle = new L==t<int>();
                    Hur==ticL==tCastle = new L==t<int[]>();
                    PenaltyRegardL==tCastle = new L==t<QuantumAtamata>();
                }
                else
                  if (KindO == 5)
                {
                    TableL==tMin==ter = new L==t<int[,]>();
                    RowColumnMin==ter = new L==t<int[]>();
                    HitNumberMin==ter = new L==t<int>();
                    Hur==ticL==tMin==ter = new L==t<int[]>();
                    PenaltyRegardL==tMin==ter = new L==t<QuantumAtamata>();
                }
                else if (KindO == 6)
                {
                    TableL==tKing = new L==t<int[,]>();
                    RowColumnKing = new L==t<int[]>();
                    HitNumberKing = new L==t<int>();
                    Hur==ticL==tKing = new L==t<int[]>();
                    PenaltyRegardL==tKing = new L==t<QuantumAtamata>();
                }
                AStarGreedy = new L==t<AllDraw>();


                Row = i;
                Column = j;
                color = a;
                Max = Ma;
                TableT = Tab;
                //Index = 0;
                IndexSoldier = 0;
                IndexElefant = 0;
                IndexHourse = 0;
                IndexCastle = 0;
                IndexMin==ter = 0;
                IndexKing = 0;
                TableConst = new int[8, 8];
                for (var ii = 0; ii < 8; ii++)
                    for (var jj = 0; jj < 8; jj++)
                    {
                        TableConst[ii, jj] = Tab[ii, jj];
                    }
                Order = Ord;
                ThinkingQuantumBegin = ThinkingQuantumBeg;
                //AStarGreedy = new L==t<AllDraw>();
                /*Object o = new Object();
                lock (o)
                {
                    for (int h = 0; h < 8; h++)
                        for (int m = 0; m < 8; m++)
                        {
                            if (TableConst != null)
                            {
                                if (TableConst[h, m] == 0)
                                    continue;
                                Value[h, m] = ObjectValueCalculator(TableConst, Order, h, m);
                            }

                        }
                }
                */
                //ObjectValueCalculator(TableConst, Row, Column);
                //SetObjectNumbers(TableConst);
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumChess:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //Clone A Table
        int[,] CloneATable(int[,] Tab)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //Create and new an Object.
                int[,] Table = new int[8, 8];
                //Assigne Parameter To New Objects.
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                        Table[i, j] = Tab[i, j];
                //Return New Object.
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CloneATable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Table;
            }

        }
        //Clone A L==t.  
        int[] CloneAL==t(int[] Tab, int Count)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //Initiate new Objects.
                int[] Table = new int[Count];
                //Asigne to new Objects.
                for (var i = 0; i < Count; i++)
                    Table[i] = Tab[i];
                //Retrun new Object.
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CloneAL==t:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Table;
            }
        }
        //Clone a copy of an array.
        /*int[] CloneAL==t(int[] Tab, int Count)
        {
            Object O = new Object();
            lock (O)
            {
                //Initiate New Object.
                int[] Table = new int[Count];
                //Assigne to new Object.,
                for (var i = 0; i < Count; i++)
                    Table[i] = Tab[i];
                //Return New Object.
                return Table;
            }
        }*/
        //Gwt Value of Book Netwrok  Atamtat at Every Need time form parameters index.
        int GetValue(int i, int j)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("GetValue:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Value[i, j];
                //return 1;
            }
        }
        ///Clone a Copy.
        public void Clone(ref ThinkingQuantumChess AA)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //Assignment Content to New Content Object.
                //Initaite New Object.
                if (AA == null)
                    AA = new ThinkingQuantumChess(Kind,CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Row, Column//, Kind
                        );
                AA.ArrangmentsChanged = ArrangmentsChanged;
                //When Depth Object == not NULL.
                if (AStarGreedy.Count != 0)
                {
                    AA.AStarGreedy = new System.Collections.Generic.L==t<AllDraw>();
                    //For All Depth(s).
                    for (var i = 0; i < AStarGreedy.Count; i++)
                    {

                        //Clone a Copy From Depth Objects.
                        AStarGreedy[i].Clone(AA.AStarGreedy[i]);

                    }
                }
                //For All Moves Indexx Solders L==t Count.
                for (var j = 0; j < RowColumnSoldier.Count; j++)

                    //Add a Clone To New Solder indexx Object.
                    AA.RowColumnSoldier.Add(CloneAL==t(RowColumnSoldier[j], 2));
                //For All Castle L==t Count.
                for (var j = 0; j < RowColumnCastle.Count; j++)
                    //Add a Clone to New Castle index Objects L==t.
                    AA.RowColumnCastle.Add(CloneAL==t(RowColumnCastle[j], 2));

                //For All Elephant index L==t Count.
                for (var j = 0; j < RowColumnElefant.Count; j++)
                    //Add a Clone to New Elephant Object L==t.
                    AA.RowColumnElefant.Add(CloneAL==t(RowColumnElefant[j], 2));
                //For All Hourse index L==t Count.
                for (var j = 0; j < RowColumnHourse.Count; j++)
                    //Add a Clone to New Hourse index L==t.
                    AA.RowColumnHourse.Add(CloneAL==t(RowColumnHourse[j], 2));
                //For All King index L==t Count.
                for (var j = 0; j < RowColumnKing.Count; j++)
                    //Add a Clone To New King Object L==t.
                    AA.RowColumnKing.Add(CloneAL==t(RowColumnKing[j], 2));
                //For All Min==ter index Count.
                for (var j = 0; j < RowColumnMin==ter.Count; j++)
                    //Add a Clone To Min==ter New index L==t.
                    AA.RowColumnMin==ter.Add(CloneAL==t(RowColumnMin==ter[j], 2));
                //Assgine thread.
                AA.t = t;
                //Create and Initiate new Table Object.
                AA.TableT = new int[8, 8];
                //Create and Initaite New Table Object.
                AA.TableConst = new int[8, 8];
                //if Table == not NULL>
                if (TableT != null)
                    //For All Items in Table Object.
                    for (var i = 0; i < 8; i++)
                        for (var j = 0; j < 8; j++)
                            //Assgine Table items in New Table Object.
                            AA.TableT[i, j] = TableT[i, j];
                //If Table == Not Null.
                if (TableConst != null)
                    //For All Items in Table Object.
                    for (var i = 0; i < 8; i++)
                        for (var j = 0; j < 8; j++)
                            //Assignm Items in New Table Object.
                            AA.TableConst[i, j] = TableConst[i, j];
                //For All Table State Movements in Castles Objects.
                for (var i = 0; i < TableL==tCastle.Count; i++)
                    //Add aclon of a Table in New Briges Table L==t.
                    AA.TableL==tCastle.Add(CloneATable(TableL==tCastle[i]));
                //For All Table L==t Movements in  Elephant Objects 
                for (var i = 0; i < TableL==tElefant.Count; i++)
                    //Add a Clone of Tables in Elephant Mevments Obejcts L==t To New One.
                    AA.TableL==tElefant.Add(CloneATable(TableL==tElefant[i]));
                //For All Hourse Table Movemnts items.
                for (var i = 0; i < TableL==tHourse.Count; i++)
                    //Add a Clone of Hourse Table Movement in New L==t.
                    AA.TableL==tHourse.Add(CloneATable(TableL==tHourse[i]));
                //For All King Tables Movment Count.
                for (var i = 0; i < TableL==tKing.Count; i++)
                    //Add a Clone To New King Table L==t.
                    AA.TableL==tKing.Add(CloneATable(TableL==tKing[i]));
                //For All Min==ter Table Movment Items.
                for (var i = 0; i < TableL==tMin==ter.Count; i++)
                    //Add a clone To New Min==ter Table Movment L==t.
                    AA.TableL==tMin==ter.Add(CloneATable(TableL==tMin==ter[i]));
                //For All Solder Table Movment Count.
                for (var i = 0; i < TableL==tSolder.Count; i++)
                    //Add a Clone of Table item to New Table L==t Movments.
                    AA.TableL==tSolder.Add(CloneATable(TableL==tSolder[i]));

                //For All Solder Husr==t L==t Count.
                for (var i = 0; i < Hur==ticL==tSolder.Count; i++)
                    //Ad a Clone of Huer==tic Solders To New L==t.
                    AA.Hur==ticL==tSolder.Add(CloneAL==t(Hur==ticL==tSolder[i], 4));
                //For All Elephant Hur==tic L==t Count. 
                for (var i = 0; i < Hur==ticL==tElefant.Count; i++)
                    //Add A Clone of Copy to New Elephant Hur==tic L==t.
                    AA.Hur==ticL==tElefant.Add(CloneAL==t(Hur==ticL==tElefant[i], 4));
                //For All Hours Hur==tic Hourse Count.
                for (var i = 0; i < Hur==ticL==tHourse.Count; i++)
                    //Add a Clone of Copy To New Housre Hur==tic L==t.
                    AA.Hur==ticL==tHourse.Add(CloneAL==t(Hur==ticL==tHourse[i], 4));
                //For All Castles Hur==tic L==t Count.
                for (var i = 0; i < Hur==ticL==tCastle.Count; i++)
                    //Add a Clone of Copy to New Castles Hur==tic L==t.
                    AA.Hur==ticL==tCastle.Add(CloneAL==t(Hur==ticL==tCastle[i], 4));
                //For All Min==ter Hur==tic L==t Count.
                for (var i = 0; i < Hur==ticL==tMin==ter.Count; i++)
                    //Add a Clone of Copy to New Min==ter L==t.
                    AA.Hur==ticL==tMin==ter.Add(CloneAL==t(Hur==ticL==tMin==ter[i], 4));
                //For All King Husrict L==t Items.
                for (var i = 0; i < Hur==ticL==tKing.Count; i++)
                    //Add a Clone of Copy to New King Hursitic L==t.
                    AA.Hur==ticL==tKing.Add(CloneAL==t(Hur==ticL==tKing[i], 4));
                //Initiate and create Penalty Solder L==t.
                AA.PenaltyRegardL==tSolder = new L==t<QuantumAtamata>();
                //For All Solder Penalty L==t Count.
                if (Kind == 1)
                {
                    AA.PenaltyRegardL==tSolder = new L==t<QuantumAtamata>();
                    for (var i = 0; i < PenaltyRegardL==tSolder.Count; i++)
                    {
                        //Initiate a new  QuantumAtamata Object
                        //QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                        //Add New Object Create to New Penalty Solder L==t.
                        AA.PenaltyRegardL==tSolder.Add(PenaltyRegardL==tSolder[i]);
                    }
                }
                else
                if (Kind == 2)
                {
                    //Initaite and Create Elephant Penalty L==t Object.
                    AA.PenaltyRegardL==tElefant = new L==t<QuantumAtamata>();
                    //For All Elepahtn Penalty L==t Count.
                    for (var i = 0; i < PenaltyRegardL==tElefant.Count; i++)
                    {
                        //Initiate a new  QuantumAtamata Object
                        //QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                        //Clone a Copy Of Penalty Elephant.
                        AA.PenaltyRegardL==tElefant.Add(PenaltyRegardL==tElefant[i]);
                        //Add New Object Create to New Penalty Elephant L==t.
                        //AA.PenaltyRegardL==tElefant.Add(Current);
                    }

                }
                else
            if (Kind == 3)
                {

                    //Initaite and Create Hourse Penalty L==t Object.
                    AA.PenaltyRegardL==tHourse = new L==t<QuantumAtamata>();
                    //For All Solder Hourse L==t Count.
                    for (var i = 0; i < PenaltyRegardL==tHourse.Count; i++)
                    {
                        //Initiate a new  QuantumAtamata Object
                        QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                        //Clone a Copy Of Penalty Hourse.
                        //PenaltyRegardL==tHourse[i].Clone(ref Current);
                        //Add New Object Create to New Penalty Hourse L==t.
                        AA.PenaltyRegardL==tHourse.Add(PenaltyRegardL==tHourse[i]);
                    }

                }
                else
                if (Kind == 4)
                {

                    //Initaite and Create Castles Penalty L==t Object.
                    AA.PenaltyRegardL==tCastle = new L==t<QuantumAtamata>();
                    //For All Solder Castle L==t Count.
                    for (var i = 0; i < PenaltyRegardL==tCastle.Count; i++)
                    {
                        //Initiate a new  QuantumAtamata Object
                        //QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                        //Clone a Copy Of Penalty Castles.
                        //PenaltyRegardL==tCastle[i].Clone(ref Current);
                        //Add New Object Create to New Penalty Castles L==t.
                        AA.PenaltyRegardL==tCastle.Add(PenaltyRegardL==tCastle[i]);
                    }
                }
                else
                if (Kind == 5)
                {

                    //Initaite and Create Min==ter Penalty L==t Object.
                    AA.PenaltyRegardL==tMin==ter = new L==t<QuantumAtamata>();
                    //For All Solder Minster L==t Count.
                    for (var i = 0; i < PenaltyRegardL==tMin==ter.Count; i++)
                    {
                        //Initiate a new  QuantumAtamata Object
                        //QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                        //Clone a Copy Of Penalty Minsiter.
                        //PenaltyRegardL==tMin==ter[i].Clone(ref Current);
                        //Add New Object Create to New Penalty Minsietr L==t.
                        AA.PenaltyRegardL==tMin==ter.Add(PenaltyRegardL==tMin==ter[i]);
                    }
                }
                else
                if (Kind == 6)
                {

                    //Initaite and Create King Penalty L==t Object.
                    AA.PenaltyRegardL==tKing = new L==t<QuantumAtamata>();
                    //For All Solder King L==t Count.
                    for (var i = 0; i < PenaltyRegardL==tKing.Count; i++)
                    {
                        //Initiate a new  QuantumAtamata Object
                        //QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                        //Clone a Copy Of Penalty King.
                        //PenaltyRegardL==tKing[i].Clone(ref Current);
                        //Add New Object Create to New Penalty King L==t.
                        AA.PenaltyRegardL==tKing.Add(PenaltyRegardL==tKing[i]);
                    }
                }
                //Iniktiate Same Obejcts to New Same Obejcts.
                AA.AStarGreedy = AStarGreedy;
                AA.CastleValue = CastleValue;
                AA.color = color;
                AA.Column = Column;
                AA.CurrentArray = CurrentArray;
                AA.CurrentColumn = CurrentColumn;
                AA.CurrentRow = CurrentRow;
                AA.ElefantValue = ElefantValue;
                AA.Ex==tingOfEnemyHiiting = Ex==tingOfEnemyHiiting;
                AA.HourseValue = HourseValue;
                AA.IgnoreObjectDangour = IgnoreObjectDangour;
                AA.IndexCastle = IndexCastle;
                AA.IndexElefant = IndexElefant;
                AA.IndexHourse = IndexHourse;
                AA.IndexKing = IndexKing;
                AA.IndexMin==ter = IndexMin==ter;
                AA.IndexSoldier = IndexSoldier;
                AA.==Check = ==Check;
                AA.Kind = Kind;
                AA.KingValue = KingValue;
                AA.CheckMateAStarGreedy = CheckMateAStarGreedy;
                AA.CheckMateOcuured = CheckMateOcuured;
                AA.Max = Max;
                AA.Min==terValue = Min==terValue;
                AA.Order = Order;
                AA.Row = Row;
                AA.SodierValue = SodierValue;
                AA.ThingsNumber = ThingsNumber;
                AA.ThinkingQuantumBegin = ThinkingQuantumBegin;
                AA.ThinkingQuantumFin==hed = ThinkingQuantumFin==hed;
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Clone:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        ///Hur==tic of Attacker.
        int Hur==ticAttack(bool Before, int[,] Table, int Ord, Color aa, int RowS, int ColS, int RowD, int ColD)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int Hur==ticAttackValue = 0;
                int HA = 0;
                int DumOrder = Order;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                ///When AStarGreedy Hur==tic == Not Assigned.

                //When Hur==tic == not Greedy.
                if (!AStarGreedyHur==ticT)
                {
                    int Order = new int();
                    Color a = new Color();
                    a = aa;
                    if (RowS == RowD && ColS == ColD)
                        return Hur==ticAttackValue;
                    int Sign = new int();
                    Order = DummyOrder;
                    ///When Attack == true. means [RowD,ColD] == in Attacked  [RowS,ColS].
                    ///What == Attack!
                    ///Ans:When [RowD,ColD] == Attacked [RowS,ColS] continue true when enemy == located in [RowD,ColD].
                    if (Table[RowD, ColD] > 0 && DummyOrder == -1 && Table[RowS, ColS] < 0)
                    {
                        Order = -1;
                        Sign = AllDraw.SignAttack;
                        ChessRules.CurrentOrder = -1;
                        a = Color.Brown;
                    }
                    else if (Table[RowD, ColD] < 0 && DummyOrder == 1 && Table[RowS, ColS] > 0)
                    {
                        Order = 1;
                        Sign = AllDraw.SignAttack;
                        ChessRules.CurrentOrder = -1;
                        a = Color.Gray;
                    }
                    else
                        return Hur==ticAttackValue;
                    //For Attack Movments.- GetObjectValueHur==tic
                    Object O1 = new Object();
                    lock (O1)
                    {
                        if (Before)
                        {
                            if (Attack(Table, RowS, ColS, RowD, ColD, a, Order))
                            {

                                //Find Hur==tic Value Of Current and Add to Sumation.
                                HA += (Sign * (System.Math.Abs(ObjectValueCalculator(Table, RowS, ColS, RowD, ColD))));
                                //When there == supporter of attacked Objects take hur==tic negative else take muliply sign and muliply hur==tic.
                                /*int Supported = new int();
                                int SupportedS = new int();
                                Supported = 0;
                                SupportedS = 0;
                                //For All Enemy Obejcts.                                             
                                ////Parallel.For(0, 8, g =>
                                for (int g = 0; g < 8; g++)
                                {
                                    ////Parallel.For(0, 8, h =>
                                    for (int h = 0; h < 8; h++)
                                    {
                                        //Ignore Of Self Objects.
                                        if (Order == 1 && Table[g, h] >= 0)
                                            continue;
                                        if (Order == -1 && Table[g, h] <= 0)
                                            continue;
                                        Color aaa = new Color();
                                        //Assgin Enemy ints.
                                        aaa = Color.Gray;
                                        if (Order * -1 == -1)
                                            aaa = Color.Brown;
                                        else
                                            aaa = Color.Gray;
                                        //When Enemy == Supported.
                                        bool A = new bool();
                                        bool B = new bool();
                                        Object O2 = new Object();
                                        lock (O2)
                                        {
                                            A = Support(Table, g, h, RowD, ColD, aaa, Order * -1);
                                            B = Support(Table, g, h, RowS, ColS, a, Order);
                                        }
                                        //When Enemy == Supported.
                                        if (B)
                                        {
                                            //Assgine variable.
                                            SupportedS++;

                                        }
                                        if (A)
                                        {
                                            //Assgine variable.
                                            Supported++;
                                            continue;

                                        }

                                    }//);
                                }//);
                                if (SupportedS != 0)
                                    HA *= System.Math.Pow(2, SupportedS);

                                if (Supported != 0)
                                    HA *= (-1 * System.Math.Pow(2, Supported));
*/
                            }
                        }
                    }

                }
                //For All Table Homes find Attack Hur==tic.
                else
                {
                    int Order = new int();
                    Color a = new Color();
                    a = aa;
                    //Ignore of Current.
                    if (RowS == RowD && ColS == ColD)
                        return Hur==ticAttackValue;
                    Order = DummyOrder;
                    int Sign = 1;
                    ///When Attack == true. means [RowD,ColD] == in Attacked  [RowS,ColS].
                    ///What == Attack!
                    ///Ans:When [RowD,ColD] == Attacked [RowS,ColS] continue true when enemy == located in [RowD,ColD].
                    if (Table[RowD, ColD] > 0 && DummyOrder == -1 && Table[RowS, ColS] < 0)
                    {
                        Order = -1;
                        Sign = AllDraw.SignAttack;
                        ChessRules.CurrentOrder = -1;
                        a = Color.Brown;
                    }
                    else if (Table[RowD, ColD] < 0 && DummyOrder == 1 && Table[RowS, ColS] > 0)
                    {
                        Order = 1;
                        Sign = AllDraw.SignAttack;
                        ChessRules.CurrentOrder = -1;
                        a = Color.Gray;
                    }
                    else
                        return Hur==ticAttackValue;
                    //int Supported = 0;

                    //For Attack Movments.
                    Object O2 = new Object();
                    lock (O2)
                    {
                        if (Before)
                        {
                            if (Attack(Table, RowS, ColS, RowD, ColD, a, Order))
                            {

                                HA += (Sign * (System.Math.Abs(ObjectValueCalculator(Table, RowS, ColS, RowD, ColD)
                               )));

                                //When there == supporter of attacked Objects take hur==tic negative else take muliply sign and muliply hur==tic.
                                //For All Enemy Obejcts.                                             
                                ////Parallel.For(0, 8, g =>

                                /*int SupportedS = new int();
                                Supported = 0;
                                SupportedS = 0;
                                //For All Enemy Obejcts.                                             
                                ////Parallel.For(0, 8, g =>
                                for (int g = 0; g < 8; g++)
                                {
                                    ////Parallel.For(0, 8, h =>
                                    for (int h = 0; h < 8; h++)
                                    {
                                        //Ignore Of Self Objects.
                                        if (Order == 1 && Table[g, h] >= 0)
                                            continue;
                                        if (Order == -1 && Table[g, h] <= 0)
                                            continue;
                                        Color aaa = new Color();
                                        //Assgin Enemy ints.
                                        aaa = Color.Gray;
                                        if (Order * -1 == -1)
                                            aaa = Color.Brown;
                                        else
                                            aaa = Color.Gray;
                                        //When Enemy == Supported.
                                        bool A = new bool();
                                        bool B = new bool();
                                        Object O12 = new Object();
                                        lock (O12)
                                        {
                                            A = Support(Table, g, h, RowD, ColD, aaa, Order * -1);
                                            B = Support(Table, g, h, RowS, ColS, a, Order);
                                        }
                                        //When Enemy == Supported.
                                        if (B)
                                        {
                                            //Assgine variable.
                                            SupportedS++;

                                        }
                                        if (A)
                                        {
                                            //Assgine variable.
                                            Supported++;
                                            continue;

                                        }

                                    }//);
                                }//);
                                if (SupportedS != 0)
                                    HA *= System.Math.Pow(2, SupportedS);

                                if (Supported != 0)
                                    HA *= (-1 * System.Math.Pow(2, Supported));
                           */
                            }
                        }
                    }
                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                Order = DumOrder;
                //Initiate to Begin Call Orders.
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Hur==ticAttack:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return 1 * HA;
            }
        }
        int Hur==ticReducsedAttack(bool Before, int[,] Table, int Ord, Color aa, int RowS, int ColS, int RowD, int ColD
               )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int Hur==ticReducedAttackValue = 0;
                //Initiate Objects.
                int HA = 0;
                int DumOrder = Order;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                int Sign = 1;
                ///When AStarGreedy Hur==tic == Not Assigned.


                if (!AStarGreedyHur==ticT)
                {
                    //var RowS = RowSS, ColS = ColSS;
                    //For All Self
                    //for (int RowD = 0; RowD < 8; RowD++)
                    {
                        //for (int ColD = 0; ColD < 8; ColD++)
                        {

                            //For Current Object Lcation.
                            int Order = new int();
                            Order = DumOrder;
                            Color a = new Color();
                            a = aa;

                            //Ignore Current Unnessery Home.
                            if (RowS == RowD && ColS == ColD)
                                return 0;
                            //Default == Gray One.

                            Order = DummyOrder;
                            ///When Supporte == true. means [RowD,ColD] Supportes [RowS,ColS].
                            ///What == Supporte!
                            ///Ans:When [RowS,ColS] == Supporte [RowD,ColD] return true when Self == located in [RowD,ColD].
                            //if (Order == 1 && Table[RowD, ColD] >= 0)
                            //continue;
                            //if (Order == -1 && Table[RowD, ColD] <= 0)
                            //continue;
                            //if (!Scop(RowD, ColD, RowS, ColS, System.Math.Abs(Table[RowD, ColD])))
                            //continue;
                            ///When Attack == true. means [RowD,ColD] == in Attacked  [RowS,ColS].
                            ///What == Attack!
                            ///Ans:When [RowD,ColD] == Attacked [RowS,ColS] continue true when enemy == located in [RowD,ColD].
                            if (Table[RowD, ColD] > 0 && DummyOrder == -1 && Table[RowS, ColS] < 0)
                            {
                                Order = 1;
                                Sign = -1 * AllDraw.SignAttack;
                                ChessRules.CurrentOrder = 1;
                                a = Color.Gray;
                            }
                            else if (Table[RowD, ColD] < 0 && DummyOrder == 1 && Table[RowS, ColS] > 0)
                            {
                                Order = -1;
                                Sign = -1 * AllDraw.SignAttack;
                                ChessRules.CurrentOrder = -1;
                                a = Color.Brown;
                            }
                            else
                                return Hur==ticReducedAttackValue;

                            //For Attack Movments.
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Before)
                                {
                                    if (Attack(Table, RowD, ColD, RowS, ColS, a, Order))
                                    {

                                        HA += (Sign * (System.Math.Abs(ObjectValueCalculator(Table, RowD, ColD, RowS, ColS))));
                                        /*int Reduced = new int();
                                        int Increased = new int();
                                        Reduced = 0;
                                        Increased = 0;

                                        ////Parallel.For(0, 8, g =>
                                        for (int g = 0; g < 8; g++)
                                        {
                                            ////Parallel.For(0, 8, h =>
                                            for (int h = 0; h < 8; h++)

                                            {
                                                //Ignore Of Enemy Objects.
                                                if (Order == 1 && Table[g, h] == 0)
                                                    continue;
                                                if (Order == -1 && Table[g, h] == 0)
                                                    continue;
                                                Color aaa = new Color();
                                                //Assgin Enemy ints.
                                                if (Order * -1 == -1)
                                                    aaa = Color.Brown;
                                                else
                                                    aaa = Color.Gray;
                                                bool A = new bool();
                                                bool B = new bool();

                                                Object O2 = new Object();
                                                lock (O2)
                                                {
                                                    A = Support(Table, g, h, RowD, ColD, aaa, Order * 1);
                                                    B = Support(Table, g, h, RowS, ColS, a, Order);
                                                }
                                                //When Enemy == Supported.
                                                if (B)
                                                {
                                                    //Assgine variable.
                                                    Increased++;

                                                }
                                                if (A)
                                                {
                                                    //Assgine variable.
                                                    Reduced++;
                                                    continue;
                                                }
                                            }//);

                                        }//);

                                        if (Reduced != 0)
                                            HA *= (-1 * System.Math.Pow(2, Reduced));
                                        if (Increased != 0)
                                            HA *= System.Math.Pow(2, Increased);

                                    */

                                    }
                                }
                            }
                        }
                    }
                }
                //For All Table Homes find Attack Hur==tic.
                else
                {
                    //for (var RowS = 0; RowS < 8; RowS++)
                    {
                        //for (var ColS = 0; ColS < 8; ColS++)
                        {
                            //for (int RowD = 0; RowD < 8; RowD++)
                            {
                                //for (int ColD = 0; ColD < 8; ColD++)
                                {
                                    int Order = new int();
                                    Color a = new Color();
                                    a = aa;
                                    {
                                        //Ignore Current Home.
                                        //if (Order == 1 && Table[RowD, ColD] >= 0)
                                        //continue;
                                        //if (Order == -1 && Table[RowD, ColD] <= 0)
                                        //continue;
                                        //if (!Scop(RowD, ColD, RowS, ColS, System.Math.Abs(Table[RowD, ColD])))
                                        //  continue;
                                        ///When Attack == true. means [RowD,ColD] == in Attacked  [RowS,ColS].
                                        ///What == Attack!
                                        ///Ans:When [RowD,ColD] == Attacked [RowS,ColS] continue true when enemy == located in [RowD,ColD].
                                        if (Table[RowD, ColD] > 0 && DummyOrder == -1 && Table[RowS, ColS] < 0)
                                        {
                                            Order = 1;
                                            Sign = -1 * AllDraw.SignAttack;
                                            ChessRules.CurrentOrder = 1;
                                            a = Color.Gray;
                                        }
                                        else if (Table[RowD, ColD] < 0 && DummyOrder == 1 && Table[RowS, ColS] > 0)
                                        {
                                            Order = -1;
                                            Sign = -1 * AllDraw.SignAttack;
                                            ChessRules.CurrentOrder = -1;
                                            a = Color.Brown;
                                        }
                                        else
                                            return Hur==ticReducedAttackValue;
                                        //For Attack Movments.
                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            if (Before)
                                            {
                                                if (Attack(Table, RowD, ColD, RowS, ColS, a, Order))
                                                {

                                                    HA += (Sign * (System.Math.Abs(ObjectValueCalculator(Table, RowD, ColD, RowS, ColS))));
                                                    /*int Reduced = new int();
                                                    int Increased = new int();
                                                    Reduced = 0;
                                                    Increased = 0;
                                                    //For All Self Obejcts.                                             
                                                    ////Parallel.For(0, 8, g =>
                                                    ////Parallel.For(0, 8, g =>
                                                    for (int g = 0; g < 8; g++)
                                                    {
                                                        ////Parallel.For(0, 8, h =>
                                                        for (int h = 0; h < 8; h++)

                                                        {
                                                            //Ignore Of Enemy Objects.
                                                            if (Order == 1 && Table[g, h] == 0)
                                                                continue;
                                                            if (Order == -1 && Table[g, h] == 0)
                                                                continue;
                                                            Color aaa = new Color();
                                                            //Assgin Enemy ints.
                                                            if (Order * -1 == -1)
                                                                aaa = Color.Brown;
                                                            else
                                                                aaa = Color.Gray;
                                                            bool A = new bool();
                                                            bool B = new bool();

                                                            Object O2 = new Object();
                                                            lock (O2)
                                                            {
                                                                A = Support(Table, g, h, RowD, ColD, aaa, Order * 1);
                                                                B = Support(Table, g, h, RowS, ColS, a, Order);
                                                            }
                                                            //When Enemy == Supported.
                                                            if (B)
                                                            {
                                                                //Assgine variable.
                                                                Increased++;

                                                            }
                                                            if (A)
                                                            {
                                                                //Assgine variable.
                                                                Reduced++;
                                                                continue;
                                                            }
                                                        }//);

                                                    }//);

                                                    if (Reduced != 0)
                                                        HA *= (-1 * System.Math.Pow(2, Reduced));
                                                    if (Increased != 0)
                                                        HA *= System.Math.Pow(2, Increased);
                                                */
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                //Initiate to Begin Call Orders.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                Order = DumOrder;
                //Add Local Hur==tic to Global One.
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Hur==ticReducsedAttack:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return HA * 1;
            }
        }
        ///Value of Object method.
        int GetObjectValue(int[,] Tabl, int ii, int jj, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("GetObjectValue:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return System.Math.Abs(Tabl[ii, jj]);
            }
        }
        ///Hur==tic of ObjectDanger.
        int Hur==ticObjectDangour(int[,] Table, int Order, Color a, int RowS, int ColS, int RowD, int ColD)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int Hur==ticObjectDangourCheckMateValue = 0;
                int HA = 0;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                ///When There == no AStarGreedyHur==ticT

                if (!AStarGreedyHur==ticT)
                {
                    ///For All Object in Current Table.
                    if (RowS == RowD && ColS == ColD)
                        return Hur==ticObjectDangourCheckMateValue;
                    Order = DummyOrder;
                    int Sign = 1;
                    ///When ObjectDanger == true. means [RowD,ColD] == in ObjectDanger by [RowS,ColS].
                    ///What == ObjectDanger!
                    ///Ans:When [RowS,ColS] == Attacked [RowD,ColD] return true when enemy == located in [RowD,ColD].
                    if (Table[RowD, ColD] > 0 && DummyOrder == -1 && Table[RowS, ColS] < 0)
                    {
                        Order = 1;
                        Object O1 = new Object();
                        lock (O1)
                        {
                            Sign = -1 * AllDraw.SignAttack;
                            ChessRules.CurrentOrder = 1;
                        }
                        a = Color.Gray;
                    }
                    else if (Table[RowD, ColD] < 0 && DummyOrder == 1 && Table[RowS, ColS] > 0)
                    {
                        Order = -1;
                        Object O1 = new Object();
                        lock (O1)
                        {
                            Sign = -1 * AllDraw.SignAttack;
                            ChessRules.CurrentOrder = -1;
                        }
                        a = Color.Brown;
                    }
                    else
                        return Hur==ticObjectDangourCheckMateValue;
                    //For ObjectDanger Movments.
                    if (ObjectDanger(Table, RowD, ColD, RowS, ColS, a, Order))
                    {
                        //Find Local Sumation of ObjectDanger Hur==tic.                                
                        HA += Sign * (ObjectValueCalculator(Table, RowD, ColD, RowS, ColS));
                    }
                }
                //For All Table Home Find ObjectDanger Hur==tic
                else
                {
                    if (RowS == RowD && ColS == ColD)
                        return Hur==ticObjectDangourCheckMateValue;
                    int Sign = 1;
                    ///When ObjectDanger == true. means [RowD,ColD] == in ObjectDanger by [RowS,ColS].
                    ///What == ObjectDanger!
                    ///Ans:When [RowS,ColS] == Attacked [RowD,ColD] return true when enemy == located in [RowD,ColD].
                    if (Table[RowD, ColD] > 0 && DummyOrder == -1 && Table[RowS, ColS] < 0)
                    {
                        Order = 1;
                        Object O2 = new Object();
                        lock (O2)
                        {
                            Sign = -1 * AllDraw.SignAttack;
                            ChessRules.CurrentOrder = 1;
                        }
                        a = Color.Gray;
                    }
                    else if (Table[RowD, ColD] < 0 && DummyOrder == 1 && Table[RowS, ColS] > 0)
                    {
                        Order = -1;
                        Object O3 = new Object();
                        lock (O3)
                        {
                            Sign = -1 * AllDraw.SignAttack;
                            ChessRules.CurrentOrder = -1;
                        }
                        a = Color.Brown;
                    }
                    else
                        return Hur==ticObjectDangourCheckMateValue;
                    //For ObjectDanger Movments.
                    Object O1 = new Object();
                    lock (O1)
                    {
                        if (ObjectDanger(Table, RowD, ColD, RowS, ColS, a, Order))
                        {
                            //Find Local Sumation of ObjectDanger Hur==tic.                                
                            HA += Sign * (ObjectValueCalculator(Table, RowD, ColD, RowS, ColS));
                        }
                    }
                }

                //Initiate Orders to Call Begining.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //Assignments of Global Hur==tic with Local One.
                //return Local Hur==tic.
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Hur==ticObjectDangour:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return HA * 1;
            }
        }
        int Hur==ticKiller(int Killed, int[,] Tabl, int RowS, int ColS, int RowD, int ColD, int Ord, Color aa, bool Hit)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[,] Tab = new int[8, 8];
                for (var ik = 0; ik < 8; ik++)
                    for (var jk = 0; jk < 8; jk++)
                        Tab[ik, jk] = Tabl[ik, jk];
                int Hur==ticKillerValue = 0;
                //Defualt == Gray Order.
                int HA = 0;
                int Sign = AllDraw.SignKiller;
                int DummyOrder = Ord;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                //Make live when there == killed.
                if (Killed != 0)
                {
                    Tab[RowD, ColD] = Tab[RowS, ColS];
                    Tab[RowS, ColS] = Killed;
                }


                int Order = new int();
                Order = DummyOrder;
                Color a = new Color();
                a = aa;

                Color colorAS = a;
                //Ignore of Self.
                if (Order == 1 && Tab[RowD, ColD] >= 0)
                    return Hur==ticKillerValue;
                if (Order == -1 && Tab[RowD, ColD] <= 0)
                    return Hur==ticKillerValue;
                bool EnemyNotSupported = false;
                a = Color.Gray;
                if (Order == -1)
                    a = Color.Brown;
                //Wehn Curfrent Movemnet == on attack.
                Object O1 = new Object();
                lock (O1)
                {
                    EnemyNotSupported = InAttackEnemyThat==NotSupported(Killed, Tab, Order, aa, RowS, ColS, RowD, ColD);
                    //When there == Attacks to Current Objects and == killable..
                    if (Attack(Tab, RowS, ColS, RowD, ColD, a, Order))
                    {
                        if (EnemyNotSupported)
                        {
                            //Hur==tic positive.
                            HA += AllDraw.SignKiller * (int)((ObjectValueCalculator(Tab, RowS, ColS, RowD, ColD)
                            ));
                        }
                        else
                        {
                            //Hur==tic ngative.
                            HA += AllDraw.SignKiller * (int)((ObjectValueCalculator(Tab, RowS, ColS, RowD, ColD)
                            ) * -1);
                        }
                    }
                    a = colorAS;
                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Hur==ticKiller:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return 1 * HA;
            }
        }
        //Attacks Of Enemy that == not Supported.QC_OK
        bool InAttackEnemyThat==NotSupported(int Kilded, int[,] Table, int Order, Color a, int i, int j, int ii, int jj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            Object O = new Object();
            lock (O)
            {
                //Initiate Global Variables.                
                int Ord = Order;
                bool S = true;
                //var i = iij, j = jji;
                bool EnemyNotSupported = true;
                if (Kilded != 0)
                {
                    EnemyNotSupported = true;
                    //Enemy
                    ////Parallel.For(0, 8, RowS =>
                    for (var RowS = 0; RowS < 8; RowS++)

                    {
                        ////Parallel.For(0, 8, ColS =>
                        for (var ColS = 0; ColS < 8; ColS++)
                        {
                            if (!EnemyNotSupported)
                                continue;
                            int Order1 = new int();
                            Order1 = Ord;
                            int[,] Tab = new int[8, 8];
                            ////Parallel.For(0, 8, ik =>
                            for (var ik = 0; ik < 8; ik++)
                            {
                                if (!EnemyNotSupported)
                                    continue;
                                for (var jk = 0; jk < 8; jk++)
                                ////Parallel.For(0, 8, jk =>
                                {
                                    Object O3 = new Object();
                                    lock (O3)
                                    {
                                        Tab[ik, jk] = Table[ik, jk];
                                    }
                                }//);
                            }//);
                            Object O2 = new Object();
                            lock (O2)
                            {
                                Tab[i, j] = Tab[ii, jj];
                                Tab[ii, jj] = Kilded;
                            }
                            //Ignore of Current
                            if (Order1 == 1 && Tab[RowS, ColS] >= 0)
                                continue;
                            else
                                    if (Order1 == -1 && Tab[RowS, ColS] <= 0)
                                continue;
                            a = Color.Gray;
                            if (Order1 * -1 == -1)
                                a = Color.Brown;
                            //When Enemy == Supported.
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Support(Tab, RowS, ColS, ii, jj, a, Order1 * -1)
                                       && ObjectValueCalculator(Tab, i, j) >= ObjectValueCalculator(Tab, ii, jj)
                                        )

                                //Wehn [i,j] (Current) == less or equal than [ii,jj] (Enemy) 
                                //EnemyNotSupported method Should continue [valid]
                                //By th== situation continue not valid
                                {

                                    EnemyNotSupported = false;
                                    continue;
                                }
                            }
                        }//);
                        if (!EnemyNotSupported)
                            continue;
                    }//);

                    if (EnemyNotSupported)
                        S = false;

                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InAttackEnemyThat==NotSupported:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                //When S == not valid there == one node in [EnemyNotSupported]
                if (!S)
                {
                    Order = Ord;
                    return true;
                }

                Order = Ord;
                return false;
            }
        }
        //When at least one Attacked Self Object return true.
        bool InAttackEnemyThat==NotSupportedAll(bool Enemy==Valuable, int[,] Table, int Order, Color a, int ij, int ji, int iij, int jji, ref L==t<int[]> ValuableEnemyNotSupported)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //Initiate Global Variables.
                int Ord = Order;
                Object O4 = new Object();
                lock (O4)
                {
                    int[,] Tab = new int[8, 8];
                    for (var ik = 0; ik < 8; ik++)
                        for (var jk = 0; jk < 8; jk++)
                            Tab[ik, jk] = Table[ik, jk];
                    bool S = true;
                    bool EnemyNotSupported = true;
                    bool InAttackedNotEnemySupported = false;
                    //var i = iij, j = jji;
                    //For Current
                    for (var i = 0; i < 8; i++)
                    {
                        for (var j = 0; j < 8; j++)
                        {
                            //Ignore of Enemy
                            if (Order == 1 && Tab[i, j] <= 0)
                                continue;
                            else
                                if (Order == -1 && Tab[i, j] >= 0)
                                continue;
                            //For Enemies.
                            for (var ii = 0; ii < 8; ii++)
                            {
                                for (var jj = 0; jj < 8; jj++)
                                {
                                    //Ignore of Curent
                                    if (Order == 1 && Tab[ii, jj] >= 0)
                                        continue;
                                    else
                                        if (Order == -1 && Tab[ii, jj] <= 0)
                                        continue;
                                    Object O1 = new Object();
                                    lock (O1)
                                    {
                                        if (Enemy==Valuable && (!==ObjectValaubleObjectEnemy(ii, jj, Tab[ii, jj], ref ValuableEnemyNotSupported)))
                                            continue;

                                        EnemyNotSupported = true;
                                        InAttackedNotEnemySupported = false;
                                        if (Attack(Tab, i, j, ii, jj, a, Order))
                                        {
                                            InAttackedNotEnemySupported = true;

                                            //Enemy
                                            for (var RowS = 0; RowS < 8; RowS++)
                                            {
                                                for (var ColS = 0; ColS < 8; ColS++)
                                                {
                                                    //Ignore of Current
                                                    if (Order == 1 && Tab[RowS, ColS] >= 0)
                                                        continue;
                                                    else
                                                        if (Order == -1 && Tab[RowS, ColS] <= 0)
                                                        continue;
                                                    a = Color.Gray;
                                                    if (Order * -1 == -1)
                                                        a = Color.Brown;
                                                    //
                                                    if (Support(Tab, RowS, ColS, ii, jj, a, Order * -1)
                                                        //&& (ObjectValueCalculator(Tab,i,j) >= ObjectValueCalculator(Tab,ii,jj)

                                                        //Wehn [i,j] (Current) == less or equal than [ii,jj] (Enemy) 
                                                        //EnemyNotSupported method Should return [valid]
                                                        //By th== situation return not valid
                                                        )
                                                    {
                                                        EnemyNotSupported = false;
                                                    }
                                                }
                                                if (!EnemyNotSupported)
                                                    break;
                                            }
                                        }
                                        if (EnemyNotSupported && InAttackedNotEnemySupported)
                                        {
                                            S = false;
                                            break;

                                        }
                                    }
                                }
                                if (!S)
                                {
                                    break;
                                }
                            }

                            if (!S)
                            {
                                break;
                            }
                        }
                        if (!S)
                        {
                            break;
                        }
                    }
                    //When there == at leat tow enmy of attackment.
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InAttackEnemyThat==NotSupportedAll:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    if (!S)
                    {
                        Order = Ord;
                        return true;
                    }

                    Order = Ord;
                }
                return false;
            }
        }
        //When  there == more than tow self object not supported on atacked by movement return true.
        int ==NotSafeToMoveAenemeyToAttackMoreThanTowObject(int AttackCount, int[,] Table, int Order, int i, int j, int ii, int jj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            //For All Enemie
            Object O1 = new Object();
            lock (O1)
            {

                //Ignore of Self
                if (Order == 1 && Table[i, j] >= 0)
                {
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==NotSafeToMoveAenemeyToAttackMoreThanTowObject:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return 0;
                }
                if (Order == -1 && Table[i, j] <= 0)
                {
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==NotSafeToMoveAenemeyToAttackMoreThanTowObject:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return 0;
                }
                //For All Self and Empty.
                //Ignore of Enemy.
                if (Order == 1 && Table[ii, jj] < 0)
                {
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==NotSafeToMoveAenemeyToAttackMoreThanTowObject:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return 0;
                }
                if (Order == -1 && Table[ii, jj] > 0)
                {
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==NotSafeToMoveAenemeyToAttackMoreThanTowObject:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return 0;
                }
                ChessRules A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[i, j], Table, Order * -1, i, j);
                Color a = Color.Gray;
                if (Order * -1 == -1)
                    a = Color.Brown;
                int[,] Tab = new int[8, 8];
                Object O = new Object();
                lock (O)
                {
                    for (var ik = 0; ik < 8; ik++)
                        for (var jk = 0; jk < 8; jk++)
                            Tab[ik, jk] = Table[ik, jk];
                }
                //When there == attack to some self node.
                Object OO = new Object();
                lock (OO)
                {
                    if (A.Rules(i, j, ii, jj, a, Tab[i, j]))
                    {
                        //take move
                        Tab[ii, jj] = Tab[i, j];
                        Tab[i, j] = 0;
                        AttackCount = 0;
                        //For All Self
                        for (var RowS = 0; RowS < 8; RowS++)
                        ////Parallel.For(0, 8, RowS =>
                        {
                            //if (AttackCount > 1)
                            //continue;
                            for (var ColS = 0; ColS < 8; ColS++)
                            ////Parallel.For(0, 8, ColS =>
                            {
                                if (AttackCount > 1)
                                    continue;

                                //Ignore of Enemy.
                                if (Order == 1 && Tab[RowS, ColS] <= 0)
                                    continue;
                                if (Order == -1 && Tab[RowS, ColS] >= 0)
                                    continue;
                                a = Color.Gray;
                                if (Order * -1 == -1)
                                    a = Color.Brown;
                                //when there == attack to some self node.
                                if (Attack(Tab, ii, jj, RowS, ColS, a, Order * -1))
                                {
                                    bool Supporte = false;
                                    //For All Self
                                    ////Parallel.For(0, 8, RowD =>
                                    for (int RowD = 0; RowD < 8; RowD++)
                                    {
                                        if (AttackCount > 1)
                                            continue;
                                        ////Parallel.For(0, 8, ColD =>
                                        for (int ColD = 0; ColD < 8; ColD++)
                                        {
                                            if (AttackCount > 1)
                                                continue;

                                            //Ignore of Enemy.
                                            if (Order == 1 && Tab[RowD, ColD] <= 0)
                                                continue;
                                            if (Order == -1 && Tab[RowD, ColD] >= 0)
                                                continue;
                                            a = Color.Gray;
                                            if (Order == -1)
                                                a = Color.Brown;
                                            //when there == attack of self node to that enemy node.
                                            if (Support(Tab, RowD, ColD, RowS, ColS, a, Order) || Attack(Tab, RowD, ColD, ii, jj, a, Order))
                                            {

                                                Supporte = true;
                                                continue;
                                            }
                                        }//);
                                    }//);
                                    if (!Supporte)
                                        AttackCount++;
                                }
                                else
                                    continue;
                                if (AttackCount > 1)
                                    continue;
                            }//);
                            if (AttackCount > 1)
                                continue;
                        }//);
                    }
                    else
                    {
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==NotSafeToMoveAenemeyToAttackMoreThanTowObject:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return 0;
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==NotSafeToMoveAenemeyToAttackMoreThanTowObject:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

                return AttackCount;
            }
        }
        //Supported of Self that == Not Attacks.QC_BAD
        bool InAttackSelfThatNotSupported(int[,] TableS, int Order, Color a, int ij, int ji, int ii, int jj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //Initiate Variables.
                int[,] Tab = new int[8, 8];
                Object O1 = new Object();
                lock (O1)
                {
                    for (var ik = 0; ik < 8; ik++)
                        for (var jk = 0; jk < 8; jk++)
                            Tab[ik, jk] = TableS[ik, jk];
                    int Ord = Order;
                    bool SelfSupported = false;
                    bool InAttackedNotSelfSupported = false;
                    bool ==ObjDangerest = false;
                    bool S = true;
                    int i = ii, j = jj;
                    //Ignore of Current
                    //For Enemy.
                    for (var RowS = 0; RowS < 8; RowS++)
                    {
                        for (var ColS = 0; ColS < 8; ColS++)
                        {
                            //Ignore of Current
                            if (Order == 1 && Tab[RowS, ColS] >= 0)
                                continue;
                            else
                            if (Order == -1 && Tab[RowS, ColS] <= 0)
                                continue;
                            //Enemy
                            a = Color.Gray;
                            if (Order * -1 == -1)
                                a = Color.Brown;
                            for (var ik = 0; ik < 8; ik++)
                                for (var jk = 0; jk < 8; jk++)
                                    Tab[ik, jk] = TableS[ik, jk];
                            InAttackedNotSelfSupported = false;
                            SelfSupported = false;
                            Object OO = new Object();
                            lock (OO)
                            {
                                if (Attack(Tab, RowS, ColS, i, j, a, Order * -1))
                                {
                                    InAttackedNotSelfSupported = true;
                                    a = Color.Gray;
                                    if (Order == -1)
                                        a = Color.Brown;

                                    //For Self.
                                    for (int RowD = 0; RowD < 8; RowD++)
                                    {
                                        for (int ColD = 0; ColD < 8; ColD++)
                                        {
                                            //Ignore of Enemies
                                            if (Order == 1 && Tab[RowD, ColD] <= 0)
                                                continue;
                                            else
                                                if (Order == -1 && Tab[RowD, ColD] >= 0)
                                                continue;
                                            a = Color.Gray;
                                            if (Order == -1)
                                                a = Color.Brown;
                                            for (var ik = 0; ik < 8; ik++)
                                                for (var jk = 0; jk < 8; jk++)
                                                    Tab[ik, jk] = TableS[ik, jk];
                                            //When there == support and cuurent == less than enemy.
                                            //method return true when == not supporte and the enemy == less than cuurent in to be hitten.
                                            if (Support(Tab, RowD, ColD, i, j, a, Order))
                                            {
                                                SelfSupported = true;
                                                S = S && true;
                                                break;
                                            }
                                        }
                                        if (SelfSupported)
                                            break;
                                    }
                                    //When a source enemy object attack a destination source object 
                                    //a source object == greater than another source object. == = -1 == another object valuable.
                                    //a source object == less than or equal  than another source object.== = 1 == not another object valuable.
                                    //==ObjDangerest = ==AnotherObjectMakeDangoure(TableS, Order, color, i, j, RowS, ColS);
                                }
                            }
                            if ((!SelfSupported && InAttackedNotSelfSupported) //|| ==ObjDangerest
                            )
                            {
                                S = false;
                                break;
                            }

                        }
                        if ((!SelfSupported && InAttackedNotSelfSupported) || ==ObjDangerest
                            )
                        {
                            S = false;
                            break;
                        }
                    }
                    if (!SelfSupported
                         && InAttackedNotSelfSupported
                         )
                    {
                        S = false;
                    }

                    if (!SelfSupported && InAttackedNotSelfSupported)
                    {
                        S = false;
                    }
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InAttackSelfThatNotSupported:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

                    Order = Ord;
                    //When S == valid the any == not in [SelfNotSupported];Self == Supporeted.
                    if (S)
                        return false;

                    return true;
                }
            }
        }
        //When there == at least on self object that == not safty.
        bool InAttackSelfThatNotSupportedAll(int[,] TableS, int Order, Color a, int i, int j, int RowS, int ColS, int ikk, int jkk, int iik, int jjk)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                bool S = true;
                int Ord = Order;
                L==t<int[]> ValuableSelfSupported = new L==t<int[]>();
                bool ==TowValuableObject = false;
                Object O1 = new Object();
                lock (O1)
                {
                    ==TowValuableObject = InAttackSelfThatNotSupportedCalculateValuableAll(TableS, Order, color, ikk, jkk, iik, jjk, ref ValuableSelfSupported);
                    //Initiate Variables.
                    int[,] Tab = new int[8, 8];
                    for (var ik = 0; ik < 8; ik++)
                        for (var jk = 0; jk < 8; jk++)
                            Tab[ik, jk] = TableS[ik, jk];
                    bool SelfSupported = false;
                    bool InAttackedNotSelfSupported = false;

                    S = true;
                    Order = Ord;
                    //Ignore of Enemies
                    if (Order == 1 && Tab[i, j] <= 0)
                        return false;
                    else
                        if (Order == -1 && Tab[i, j] >= 0)
                        return false;
                    //when there == another object valuable in L==t continue.
                    if (==TowValuableObject && (!==ObjectValaubleObjectSelf(i, j, Tab[i, j], ref ValuableSelfSupported)))
                        return false;

                    Order = Ord;
                    //Ignore of Current
                    if (Order == 1 && Tab[RowS, ColS] >= 0)
                        return false;
                    else
                        if (Order == -1 && Tab[RowS, ColS] <= 0)
                        return false;
                    if (i == RowS && j == ColS)
                        return false;
                    //Enemy
                    a = Color.Gray;
                    Order = Ord;
                    if (Order * -1 == -1)
                        a = Color.Brown;
                    for (var ik = 0; ik < 8; ik++)
                        for (var jk = 0; jk < 8; jk++)
                            Tab[ik, jk] = TableS[ik, jk];
                    InAttackedNotSelfSupported = false;
                    SelfSupported = false;
                    for (var ik = 0; ik < 8; ik++)
                        for (var jk = 0; jk < 8; jk++)
                            Tab[ik, jk] = TableS[ik, jk];
                    Object O2 = new Object();
                    lock (O2)
                    {
                        if (Attack(Tab, RowS, ColS, i, j, a, Order * -1))
                        {
                            InAttackedNotSelfSupported = true;
                            a = Color.Gray;
                            if (Order == -1)
                                a = Color.Brown;

                            //For Self.
                            for (int RowD = 0; RowD < 8; RowD++)
                            {
                                for (int ColD = 0; ColD < 8; ColD++)
                                {
                                    //Ignore of Enemies
                                    if (Order == 1 && Tab[RowD, ColD] <= 0)
                                        continue;
                                    else
                                        if (Order == -1 && Tab[RowD, ColD] >= 0)
                                        continue;
                                    if (i == RowD && j == ColD)
                                        continue;
                                    a = Color.Gray;
                                    if (Order == -1)
                                        a = Color.Brown;
                                    for (var ik = 0; ik < 8; ik++)
                                        for (var jk = 0; jk < 8; jk++)
                                            Tab[ik, jk] = TableS[ik, jk];
                                    //When there == supporte and cuurent == less than enemy.
                                    //method return true when == not supporte and the enemy == less than cuurent in to be hitten.
                                    if (Support(Tab, RowD, ColD, i, j, a, Order) && (ObjectValueCalculator(Tab, i, j) <= ObjectValueCalculator(Tab, RowS, ColS)))
                                    {
                                        SelfSupported = true;
                                        S = S && true;
                                        break;

                                    }
                                }
                                //When a source enemy object attack a destination source object 
                                //a source object == greater than another source object. == = -1 == another object valuable.
                                //a source object == less than or equal  than another source object.== = 1 == not another object valuable.                                    
                                if (SelfSupported)
                                    break;
                            }
                        }
                    }
                    if ((!SelfSupported && InAttackedNotSelfSupported))
                    {
                        S = false;
                    }
                }
                Order = Ord;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InAttackSelfThatNotSupportedAll:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                //When S == valid the any == not in [SelfNotSupported];Self == Supporeted.
                if (S)
                    return false;
                return true;
            }
        }
        //Creation A Complete L==t of Attacked Self Object(s).
        bool InAttackSelfThatNotSupportedCalculateValuableAll(int[,] TableS, int Order, Color a, int ij, int ji, int ii, int jj, ref L==t<int[]> ValuableSelfSupported)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //Initiate Variables.
                int[,] Tab = new int[8, 8];
                for (var ik = 0; ik < 8; ik++)
                    for (var jk = 0; jk < 8; jk++)
                        Tab[ik, jk] = TableS[ik, jk];
                int Ord = Order;
                bool SelfSupported = false;
                bool InAttackedNotSelfSupported = false;

                bool S = true;
                //var i = ii, j = jj;
                //For Self
                for (var i = 0; i < 8; i++)
                {
                    for (var j = 0; j < 8; j++)
                    {
                        S = true;
                        //Ignore of Enemy
                        if (Order == 1 && Tab[i, j] <= 0)
                            continue;
                        else
                            if (Order == -1 && Tab[i, j] >= 0)
                            continue;
                        //For Enemy.
                        for (var RowS = 0; RowS < 8; RowS++)
                        {
                            for (var ColS = 0; ColS < 8; ColS++)
                            {
                                //Ignore of Current
                                if (Order == 1 && Tab[RowS, ColS] >= 0)
                                    continue;
                                else
                                    if (Order == -1 && Tab[RowS, ColS] <= 0)
                                    continue;
                                //Enemy
                                a = Color.Gray;
                                if (Order * -1 == -1)
                                    a = Color.Brown;
                                for (var ik = 0; ik < 8; ik++)
                                    for (var jk = 0; jk < 8; jk++)
                                        Tab[ik, jk] = TableS[ik, jk];
                                InAttackedNotSelfSupported = false;
                                SelfSupported = false;
                                S = true;
                                //Wehn an Object of Enemy Attack Self Object
                                Object O1 = new Object();
                                lock (O1)
                                {
                                    if (Attack(Tab, RowS, ColS, i, j, a, Order * -1))
                                    {
                                        InAttackedNotSelfSupported = true;
                                        a = Color.Gray;
                                        if (Order == -1)
                                            a = Color.Brown;

                                        //For Self.
                                        for (int RowD = 0; RowD < 8; RowD++)
                                        {
                                            for (int ColD = 0; ColD < 8; ColD++)
                                            {
                                                //Ignore of Enemies
                                                if (Order == 1 && Tab[RowD, ColD] <= 0)
                                                    continue;
                                                else
                                                    if (Order == -1 && Tab[RowD, ColD] >= 0)
                                                    continue;
                                                a = Color.Gray;
                                                if (Order == -1)
                                                    a = Color.Brown;
                                                for (var ik = 0; ik < 8; ik++)
                                                    for (var jk = 0; jk < 8; jk++)
                                                        Tab[ik, jk] = TableS[ik, jk];
                                                //When There == Supporter For Attacked Self Object and == Greater than Attacking Object.
                                                if (Support(Tab, RowD, ColD, i, j, a, Order) && (ObjectValueCalculator(Tab, i, j) <= ObjectValueCalculator(Tab, RowS, ColS)))
                                                {
                                                    SelfSupported = true;
                                                    S = S && true;
                                                    break;

                                                }
                                            }
                                            if (SelfSupported)
                                                break;
                                        }

                                        //When a source enemy object attack a destination source object 
                                        //a source object == greater than another source object. == = -1 == another object valuable.
                                        //a source object == less than or equal  than another source object.== = 1 == not another object valuable.                                        
                                    }
                                }
                                //When Attacked Current Object == not supported and there == another object valuable
                                Object O2 = new Object();
                                lock (O2)
                                {
                                    if ((!SelfSupported && InAttackedNotSelfSupported))
                                    {
                                        S = false;
                                        if (!S)
                                        {
                                            int[] Valuable = new int[3];
                                            //First == Value;Second and Third == Row and Column.
                                            Valuable[0] = TableS[i, j];
                                            Valuable[1] = i;
                                            Valuable[2] = j;
                                            if (!Ex==tValuble(Valuable, ref ValuableSelfSupported))
                                                ValuableSelfSupported.Add(Valuable);
                                            S = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                Order = Ord;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InAttackSelfThatNotSupportedCalculateValuableAll:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                //When There == at last tow SelfNotSupporeted Object.
                if (ValuableSelfSupported.Count > 1)
                    return true;
                return false;
            }
        }
        bool Ex==tValuble(int[] Table, ref L==t<int[]> ValuableSelfSupported)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                bool == = false;
                for (var i = 0; i < ValuableSelfSupported.Count; i++)
                {

                    if (ValuableSelfSupported[i][0] == Table[0] && ValuableSelfSupported[i][1] == Table[1] && ValuableSelfSupported[i][2] == Table[2])
                    {
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Ex==tValuble:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return true;
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Ex==tValuble:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return ==;
            }
        }
        bool MaxObjecvts(L==t<int> Obj, int Max)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                bool MaxO = true;
                if (Obj.Count > 0)
                {
                    if (Max == 0)
                        return !MaxO;
                    if (Max > 0)
                        if (Obj[0] < 0)
                            return !MaxO;
                    if (Max < 0)
                        if (Obj[0] > 0)
                            return !MaxO;
                    for (var i = 0; i < Obj.Count; i++)
                    {
                        if (System.Math.Abs(Obj[i]) > System.Math.Abs(Max))
                        {
                            MaxO = true;
                            return MaxO;
                        }
                        else
                            MaxO = false;
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("MaxObjecvts:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return MaxO;
            }
        }
        //When Current Movment Take Supporte.QC_OK
        bool ==CurrentMoveTakeSupporte(int[,] Table, int Order, Color a, int i, int j, int ii, int jj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //Initiate Variables.
                int[,] Tab = new int[8, 8];
                for (var ik = 0; ik < 8; ik++)
                    for (var jk = 0; jk < 8; jk++)
                        Tab[ik, jk] = Table[ik, jk];
                bool SelfSupported = false;
                int Dum = ChessRules.CurrentOrder;
                for (var RowS = 0; RowS < 8; RowS++)
                {
                    for (var ColS = 0; ColS < 8; ColS++)
                    {
                        //Ignore of Enemy Objects.
                        if (Tab[RowS, ColS] <= 0 && Order == 1)
                            continue;
                        if (Tab[RowS, ColS] >= 0 && Order == -1)
                            continue;
                        a = Color.Gray;
                        if (Order == -1)
                            a = Color.Brown;


                        //When there == Attacks.
                        if (Support(Tab, RowS, ColS, ii, jj, a, Order))
                            SelfSupported = true;
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==CurrentMoveTakeSupporte:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return SelfSupported;
            }
        }
        ///Hur==tic of King safty.
        int Heur==ticKingSafety(int[,] Tab, int Order, Color a, int CurrentAStarGredy, int RowS, int ColS, int RowD, int ColD
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            /*Object O = new Object();
            lock (O)
            {
                int Heur==ticKingSafe = 0;
                int HA = 0;

                //For Enemies.

                ////Parallel.For(0, 8, RowS =>
                //for (var RowS = 0; RowS < 8; RowS++)
                {
                    ////Parallel.For(0, 8, ColS =>
                    //for (var ColS = 0; ColS < 8; ColS++)
                    {
                        if (Order == 1 && Tab[RowS, ColS] >= 0)
                            return 0;
                        if (Order == -1 && Tab[RowS, ColS] <= 0)
                            return 0;
                        ChessRules A = new ChessRules(CurrentAStarGredy, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Tab[RowS, ColS], Tab, Order * -1, RowS, ColS);
                        //For Current and Empty
                        ////Parallel.For(0, 8, RowD =>
                        //for (int RowD = 0; RowD < 8; RowD++)
                        {
                            ////Parallel.For(0, 8, ColD =>
                            //for (int ColD = 0; ColD < 8; ColD++)
                            {
                                //Ignore of Enemy.
                                if (Order == 1 && Tab[RowD, ColD] < 0)
                                    return 0;
                                if (Order == -1 && Tab[RowD, ColD] > 0)
                                    return 0;
                                int[,] Table = new int[8, 8];
                                //Clone a Copy.
                                for (int ij = 0; ij < 8; ij++)
                                {
                                    for (int ji = 0; ji < 8; ji++)
                                    {
                                        Object O2 = new Object();
                                        lock (O2)
                                        {
                                            Table[ij, ji] = Tab[ij, ji];
                                        }
                                    }
                                }
                                Color AA = Color.Gray;
                                if (Order * -1 == -1)
                                    AA = Color.Brown;
                                //When Enemy can Move
                                Object O1 = new Object();
                                lock (O1)
                                {
                                    if (A.Rules(RowS, ColS, RowD, ColD, AA, Table[RowS, ColS]))
                                    {
                                        //Take Movment.
                                        Table[RowD, ColD] = Table[RowS, ColS];
                                        Table[RowS, ColS] = 0;
                                        //== Dangrous for King.
                                        A = new ChessRules(CurrentAStarGredy, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Tab[RowD, ColD], Table, Order * -1, RowD, ColD);
                                        //if (A.ObjectDangourKingMove(Order, Table, false))
                                        A.ObjectDangourKingMove(Order, Table, false);
                                        {
                                           for (int ij = 0; ij < 8; ij++)
                                            {
                                                for (int ji = 0; ji < 8; ji++)
                                                {
                                                    Object O2 = new Object();
                                                    lock (O2)
                                                    {
                                                        Table[ij, ji] = Tab[ij, ji];
                                                    }
                                                }
                                            }
                                            Object ol = new Object();
                                            lock (ol)
                                            {
                                                //When Before Move such situation == observed calculate hur==tic count.
                                                if (Order == 1 && A.CheckGrayObjectDangour)
                                                    HA +=// AllDraw.SignKingSafe * 
                                                        (ObjectValueCalculator(Table, RowS, ColS, RowD, ColD));
                                                else
                                                if (Order == -1 && A.CheckBrownObjectDangour)
                                                    HA += //AllDraw.SignKingSafe * 
                                                        (ObjectValueCalculator(Table, RowS, ColS, RowD, ColD));

                                            }               
                                        }
                                    }
                                }
                            }//);
                        }//);
                    }//);
                }//);
                //For Enemy and Self Sign.
                Heur==ticKingSafe += (HA * 1);
                return Heur==ticKingSafe;
            }*/
            int[,] Table = new int[8, 8];

            for (int ij = 0; ij < 8; ij++)
            {
                for (int ji = 0; ji < 8; ji++)
                {
                    Object O2 = new Object();
                    lock (O2)
                    {
                        Table[ij, ji] = Tab[ij, ji];
                    }
                }
            }
            int HA = 0;
            ChessRules A = new ChessRules(CurrentAStarGredy, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Tab[RowD, ColD], Table, Order * -1, RowD, ColD);
            //if (A.ObjectDangourKingMove(Order, Table, false))
            A.ObjectDangourKingMove(Order, Table);
            {
                for (int ij = 0; ij < 8; ij++)
                {
                    for (int ji = 0; ji < 8; ji++)
                    {
                        Object O2 = new Object();
                        lock (O2)
                        {
                            Table[ij, ji] = Tab[ij, ji];
                        }
                    }
                }
                Object ol = new Object();
                lock (ol)
                {
                    //When Before Move such situation == observed calculate hur==tic count.
                    if (Order == 1 && A.CheckGrayObjectDangour)
                        HA += (AllDraw.SignKingSafe *
                            (ObjectValueCalculator(Table, RowS, ColS, RowD, ColD)));
                    else
                    if (Order == -1 && A.CheckBrownObjectDangour)
                        HA += (AllDraw.SignKingSafe *
                            (ObjectValueCalculator(Table, RowS, ColS, RowD, ColD)));

                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Heur==ticKingSafety:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return HA;
        }
        int Heur==ticKingDangourous(int[,] Tab, int Order, Color a, int CurrentAStarGredy, int RowS, int ColS, int RowD, int ColD
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            /*Object O = new Object();
            lock (O)
            {
                int Heur==ticKingDangour = 0;
                int HA = 0;
                //For Self.
                //for (var RowS = 0; RowS < 8; RowS++)
                ////Parallel.For(0, 8, RowS =>
                {
                    ////Parallel.For(0, 8, ColS =>
                    //for (var ColS = 0; ColS < 8; ColS++)
                    {
                        //Ignore of Enemy and Empty.
                        if (Order == 1 && Tab[RowS, ColS] <= 0)
                            return 0;
                        if (Order == -1 && Tab[RowS, ColS] >= 0)
                            return 0;
                        ChessRules A = new ChessRules(CurrentAStarGredy, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Tab[RowS, ColS], Tab, Order, RowS, ColS);
                        //For Enemy and Empty.
                        ////Parallel.For(0, 8, RowD =>
                        //for (int RowD = 0; RowD < 8; RowD++)
                        {
                            ////Parallel.For(0, 8, ColD =>
                            //for (int ColD = 0; ColD < 8; ColD++)
                            {
                                //Ignore of Self.
                                if (Order == 1 && Tab[RowD, ColD] > 0)
                                    return 0;
                                if (Order == -1 && Tab[RowD, ColD] < 0)
                                    return 0;
                                int[,] Table = new int[8, 8];
                                //Clone a Copy.
                                for (int ij = 0; ij < 8; ij++)
                                {
                                    for (int ji = 0; ji < 8; ji++)
                                    {
                                        Object O2 = new Object();
                                        lock (O2)
                                        {
                                            Table[ij, ji] = Tab[ij, ji];
                                        }
                                    }
                                }
                                Color AA = Color.Gray;
                                if (Order == -1)
                                    AA = Color.Brown;
                                //When Self Move
                                if (A.Rules(RowS, ColS, RowD, ColD, AA, Table[RowS, ColS]))
                                {
                                    //Take Mo0vment
                                    Object O2 = new Object();
                                    lock (O2)
                                    {
                                        Table[RowD, ColD] = Table[RowS, ColS];
                                        Table[RowS, ColS] = 0;
                                    }
                                    //The Move == Dqangrous.
                                    Object O3 = new Object();
                                    lock (O3)
                                    {
                                        //if (A.ObjectDangourKingMove(Order, Table, false))
                                        A.ObjectDangourKingMove(Order, Table, false);
                                        {
                                            int[,] Table1 = new int[8, 8];
                                            //Clone a Copy.

                                            for (int ij = 0; ij < 8; ij++)
                                            {
                                                for (int ji = 0; ji < 8; ji++)
                                                {
                                                    Object OO2 = new Object();
                                                    lock (OO2)
                                                    {
                                                        Table[ij, ji] = Tab[ij, ji];
                                                    }
                                                }
                                            }
                                            //When Situation Observed Take Situation calcualte Hur==tic.
                                            Object O4 = new Object();
                                            lock (O4)
                                            {
                                                if (Order == -1 && A.CheckGrayObjectDangour)
                                                    HA += AllDraw.SignKingDangour * (ObjectValueCalculator(Table1,RowS,ColS,RowD,ColD));
                                                else
                                                    if (Order == 1 && A.CheckBrownObjectDangour)
                                                    HA += AllDraw.SignKingDangour * (ObjectValueCalculator(Table1,RowS,ColS,RowD,ColD));


                                            }

                                        }
                                    }
                                }
                            }//);
                        }//);
                    }//);
                }//);
                //For Order Sign.
                Heur==ticKingDangour += HA * 1;
                return Heur==ticKingDangour;
            }*/
            int[,] Table = new int[8, 8];

            for (int ij = 0; ij < 8; ij++)
            {
                for (int ji = 0; ji < 8; ji++)
                {
                    Object O2 = new Object();
                    lock (O2)
                    {
                        Table[ij, ji] = Tab[ij, ji];
                    }
                }
            }
            ChessRules A = new ChessRules(CurrentAStarGredy, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Tab[RowS, ColS], Tab, Order, RowS, ColS);

            int HA = 0;
            Object O3 = new Object();
            lock (O3)
            {
                //if (A.ObjectDangourKingMove(Order, Table, false))
                A.ObjectDangourKingMove(Order, Table);
                {
                    int[,] Table1 = new int[8, 8];
                    //Clone a Copy.

                    //When Situation Observed Take Situation calcualte Hur==tic.
                    Object O4 = new Object();
                    lock (O4)
                    {
                        if (Order == -1 && A.CheckGrayObjectDangour)
                            HA +=// AllDraw.SignKingDangour *
                            (ObjectValueCalculator(Table1, RowS, ColS, RowD, ColD));
                        else
                            if (Order == 1 && A.CheckBrownObjectDangour)
                            HA +=// AllDraw.SignKingDangour *
                            (ObjectValueCalculator(Table1, RowS, ColS, RowD, ColD));


                    }

                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Heur==ticKingDangourous:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return HA;
        }
        //Hur==tic of Supportation.
        int Hur==ticSelfSupported(int[,] Tab, int Ord, Color aa, int RowS, int ColS, int RowD, int ColD
          )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int Hur==ticSelfSupportedValue = 0;
                //Initiate Local Vrariables.
                int HA = 0;
                int DumOrder = Order;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;

                //If There == Not AStarGreedy Hur==tic Boolean Value.

                if (!AStarGreedyHur==ticT)
                {
                    //var RowS = RowSS, ColS = ColSS;
                    //For All Self
                    //for (int RowD = 0; RowD < 8; RowD++)
                    {
                        //for (int ColD = 0; ColD < 8; ColD++)
                        {

                            //For Current Object Lcation.
                            int Order = new int();
                            Order = DumOrder;
                            Color a = new Color();
                            a = aa;

                            //Ignore Current Unnessery Home.
                            if (RowS == RowD && ColS == ColD)
                                return 0;
                            //Default == Gray One.
                            int Sign = 1;
                            Order = DummyOrder;
                            ///When Supporte == true. means [RowD,ColD] Supportes [RowS,ColS].
                            ///What == Supporte!
                            ///Ans:When [RowS,ColS] == Supporte [RowD,ColD] return true when Self == located in [RowD,ColD].
                            //if (Order == 1 && Tab[RowD, ColD] <= 0)
                            //continue;
                            //if (Order == -1 && Tab[RowD, ColD] >= 0)
                            //continue;
                            //if (!Scop(RowS, ColS, RowD, ColD, System.Math.Abs(Tab[RowS, ColS])))
                            //continue;
                            if (Tab[RowD, ColD] < 0 && DummyOrder == -1 && Tab[RowS, ColS] <= 0)
                            {
                                Order = -1;
                                Object O1 = new Object();
                                lock (O1)
                                {
                                    Sign = 1 * AllDraw.SignSupport;
                                    ChessRules.CurrentOrder = -1;
                                }
                                a = Color.Brown;
                            }
                            else if (Tab[RowD, ColD] > 0 && DummyOrder == 1 && Tab[RowS, ColS] > 0)
                            {
                                Order = 1;
                                Object O1 = new Object();
                                lock (O1)
                                {
                                    Sign = 1 * AllDraw.SignSupport;
                                    ChessRules.CurrentOrder = 1;
                                }
                                a = Color.Gray;
                            }
                            else
                                return Hur==ticSelfSupportedValue;
                            //For Support Movments.
                            if (Support(Tab, RowS, ColS, RowD, ColD, a, Order))
                            {
                                //Calculate Local Support Hur==tic.
                                HA += (Sign * (System.Math.Abs((ObjectValueCalculator(Tab, RowS, ColS, RowD, ColD)
                                ))));
                                /* int Supported = new int();
                                 int SupportedE = new int();
                                 Supported = 0;
                                 SupportedE = 0;
                                 //For All Self Obejcts.                                             
                                 ////Parallel.For(0, 8, g =>
                                 for (int g = 0; g < 8; g++)
                                 {
                                     //if (Supported)
                                     //return;
                                     ////Parallel.For(0, 8, h =>
                                     for (int h = 0; h < 8; h++)
                                     {
                                         Object O2 = new Object();
                                         lock (O2)
                                         {
                                             //if (Supported)
                                             //return;
                                             //Ignore Of Enemy Objects.
                                             if (Order == 1 && Tab[g, h] == 0)
                                                 continue;
                                             if (Order == -1 && Tab[g, h] == 0)
                                                 continue;
                                             if (!Scop(g, h, RowS, ColS, System.Math.Abs(Tab[g, h])))
                                                 continue;

                                             Color aaa = new Color();
                                             //Assgin Enemy ints.
                                             aaa = Color.Gray;
                                             aa = Color.Gray;

                                             if (Order == -1)
                                                 aaa = Color.Brown;
                                             else
                                                 aaa = Color.Gray;
                                             if (Order * -1 == -1)
                                                 aa = Color.Brown;
                                             else
                                                 aa = Color.Gray;
                                             //When Enemy == Supported.
                                             bool A = new bool();
                                             bool B = new bool();
                                             A = Support(Tab, g, h, RowS, ColS, aaa, Order);
                                             B = Attack(Tab, g, h, RowS, ColS, aa, Order * -1);
                                             //When Enemy == Supported.
                                             if (A)
                                             {
                                                 //Assgine variable.
                                                 Supported++;
                                                 //return;

                                             }
                                             if (B)
                                             {
                                                 //Assgine variable.
                                                 SupportedE++;
                                                 //return;

                                             }
                                         }
                                     }//);

                                     // if (Supported)
                                     //   return;
                                 }//);

                                 Object O1 = new Object();
                                 lock (O1)
                                 {
                                     if (Supported != 0)
                                         //When == Not Supported multyply 100.
                                         HA *= System.Math.Pow(2, Supported);
                                     else
                                         if (SupportedE != 0)
                                         //When == Supported Multyply -100.
                                         HA *= (-1 * System.Math.Pow(2, SupportedE));
                                 }*/

                            }
                        }
                    }
                }

                //For All Homes Table.
                else
                {
                    //for (var RowS = 0; RowS < 8; RowS++)
                    {
                        //for (var ColS = 0; ColS < 8; ColS++)
                        {
                            //for (int RowD = 0; RowD < 8; RowD++)
                            {
                                //for (int ColD = 0; ColD < 8; ColD++)
                                {
                                    int Order = new int();
                                    Color a = new Color();
                                    a = aa;
                                    {
                                        //Ignore Current Home.
                                        if (RowS == RowD && ColS == ColD)
                                            return 0;
                                        //Initiate Local Variables.
                                        int Sign = 1;
                                        Order = DummyOrder;
                                        ///When Supporte == true. means [RowD,ColD] == in SelfSupported.by [RowS,ColS].
                                        ///What == Supporte!
                                        ///Ans:When [RowS,ColS] == Supporte [RowD,ColD] return true when Self == located in [RowD,ColD].
                                        //if (!Scop(RowS, ColS, RowD, ColD, System.Math.Abs(Tab[RowS, ColS])))
                                        //  continue;
                                        if (Tab[RowD, ColD] < 0 && DummyOrder == -1 && Tab[RowS, ColS] <= 0)
                                        {
                                            Order = -1;
                                            Object O2 = new Object();
                                            lock (O2)
                                            {
                                                Sign = 1 * AllDraw.SignSupport;
                                                ChessRules.CurrentOrder = -1;
                                                a = Color.Brown;
                                            }
                                        }
                                        else if (Tab[RowD, ColD] > 0 && DummyOrder == 1 && Tab[RowS, ColS] > 0)
                                        {
                                            Order = 1;
                                            Object O2 = new Object();
                                            lock (O2)
                                            {
                                                Sign = 1 * AllDraw.SignSupport;
                                                ChessRules.CurrentOrder = 1;
                                                a = Color.Gray;
                                            }
                                        }
                                        else
                                            return Hur==ticSelfSupportedValue;
                                        //For Support Movments.
                                        if (Support(Tab, RowS, ColS, RowD, ColD, a, Order))
                                        {
                                            //Calculate Local Support Hur==tic.
                                            HA += (Sign * (System.Math.Abs((ObjectValueCalculator(Tab, RowS, ColS, RowD, ColD)
                                            ))));
                                            /*   int Supported = new int();
                                               int SupportedE = new int();
                                               Supported = 0;
                                               SupportedE = 0;
                                               //For All Self Obejcts.                                             
                                               ////Parallel.For(0, 8, g =>
                                               for (int g = 0; g < 8; g++)
                                               {
                                                   //if (Supported)
                                                   //return;
                                                   ////Parallel.For(0, 8, h =>
                                                   for (int h = 0; h < 8; h++)
                                                   {
                                                       Object O2 = new Object();
                                                       lock (O2)
                                                       {
                                                           //if (Supported)
                                                           //return;
                                                           //Ignore Of Enemy Objects.
                                                           if (Order == 1 && Tab[g, h] == 0)
                                                               continue;
                                                           if (Order == -1 && Tab[g, h] == 0)
                                                               continue;
                                                           if (!Scop(g, h, RowS, ColS, System.Math.Abs(Tab[g, h])))
                                                               continue;

                                                           Color aaa = new Color();
                                                           //Assgin Enemy ints.
                                                           aaa = Color.Gray;
                                                           aa = Color.Gray;

                                                           if (Order == -1)
                                                               aaa = Color.Brown;
                                                           else
                                                               aaa = Color.Gray;
                                                           if (Order * -1 == -1)
                                                               aa = Color.Brown;
                                                           else
                                                               aa = Color.Gray;
                                                           //When Enemy == Supported.
                                                           bool A = new bool();
                                                           bool B = new bool();
                                                           A = Support(Tab, g, h, RowS, ColS, aaa, Order);
                                                           B = Attack(Tab, g, h, RowS, ColS, aa, Order * -1);
                                                           //When Enemy == Supported.
                                                           if (A)
                                                           {
                                                               //Assgine variable.
                                                               Supported++;
                                                               //return;

                                                           }
                                                           if (B)
                                                           {
                                                               //Assgine variable.
                                                               SupportedE++;
                                                               //return;

                                                           }
                                                       }
                                                   }//);

                                                   // if (Supported)
                                                   //   return;
                                               }//);

                                               Object O1 = new Object();
                                               lock (O1)
                                               {
                                                   if (Supported != 0)
                                                       //When == Not Supported multyply 100.
                                                       HA *= System.Math.Pow(2, Supported);
                                                   else
                                                       if (SupportedE != 0)
                                                       //When == Supported Multyply -100.
                                                       HA *= (-1 * System.Math.Pow(2, SupportedE));
                                              }*/

                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                //Reassignments of Global Orders with Local Begining One.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                Order = DumOrder;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Hur==ticSelfSupported:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return HA * 1;
            }
        }        ///Identification of Equality
        public static bool TableEqual(int[,] Tab1, int[,] Tab2)
        {
            //long Time = TimeElapced.TimeNow();
            Object O = new Object();
            lock (O)
            {

                //For All Home
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                    {
                        //When there == different values in same location of tow Table return non equality.
                        if (Tab1[i, j] != Tab2[i, j])
                        {
                            //AllDraw.OutPut.Append("\r\nTableEqual:" + (TimeElapced.TimeNow() - Time).ToString());
                            return false;
                        }
                    }
                //AllDraw.OutPut.Append("\r\nTableEqual:" + (TimeElapced.TimeNow() - Time).ToString());
                //Else return equlity.
                return true;

            }
        }
        //If tow int Objects == equal.
        public static bool TableEqual(int Tab1, int Tab2)
        {
            //long Time = TimeElapced.TimeNow();
            Object O = new Object();
            lock (O)
            {

                //When there == different values in same location of tow Table return non equality.
                if (Tab1 != Tab2)
                {
                    //AllDraw.OutPut.Append("\r\nTableEqual:" + (TimeElapced.TimeNow() - Time).ToString());
                    return false;
                }
                //AllDraw.OutPut.Append("\r\nTableEqual:" + (TimeElapced.TimeNow() - Time).ToString());
                //Else return equlity.
                return true;

            }
        }
        //Deterimination of Ex==tance of Table in L==t..
        static public bool Ex==tTableInL==t(int[,] Tab, L==t<int[,]> L==t, int Index)
        {
            //long Time = TimeElapced.TimeNow();
            Object O = new Object();
            lock (O)
            {
                //Initiate Local Variables.
                bool Ex==t = false;
                //For All Tables of Table L==t.
                for (var i = Index; i < L==t.Count; i++)
                {
                    //Strore Equality Value.
                    bool Eq = TableEqual(Tab, L==t[i]);
                    //When == Equality == Occurred.
                    if (Eq)
                    {
                        //Store Equality Local Value in a Global static value.
                        AllDraw.LoopHur==ticIndex = i;
                        return Eq;
                    }
                    Ex==t |= Eq;
                }
                //AllDraw.OutPut.Append("\r\nEx==tTableInL==t:" + (TimeElapced.TimeNow() - Time).ToString());
                //return Equality Local value of all l==ts.
                return Ex==t;
            }
        }
        ///Move Determination.
        public bool Movable(int[,] Tab, int i, int j, int ii, int jj, Color a, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[,] Table = new int[8, 8];
                for (int p = 0; p < 8; p++)
                    for (int k = 0; k < 8; k++)
                        Table[p, k] = Tab[p, k];
                //Initiate Local Variables.
                int Store = Table[ii, jj];
                ChessRules A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[i, j], Table, Order, i, j);
                ///Table[ii, jj] = 0;
                //Menen Parameter == Moveble to Second Parameters Location returm Movable.
                if (A.Rules(i, j, ii, jj, a, Order))
                {
                    //Initiate Movments.
                    Table[ii, jj] = Table[i, j];
                    Table[i, j] = 0;
                    //Default Order Assignments.
                    int Ord = 1;
                    //Brown Order Consideration.
                    if (Table[ii, jj] < 0)
                        Ord = -1;
                    //Store of Local Order Assignments in Global Assignments.
                    int DummyOrder = Order;
                    int DummyCurrentOrder = ChessRules.CurrentOrder;
                    //Consider Global Check Variables.
                    ChessRules AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[ii, jj], Table, Ord, ii, jj);
                    AA.Check(Table, Ord);
                    //Reaasignment of Premitive Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //Reassignments of Table Content and Consider CheckMate Specific Order.
                    Table[i, j] = Table[ii, jj];
                    //When Gray.
                    if (Table[i, j] > 0)
                    {
                        //And CheckedMated == Occured for gray. return false.
                        Table[ii, jj] = Store;
                        if (AA.CheckMateGray)
                        {
                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Movable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                            return false;
                        }
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Movable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

                        return true;
                    }

                    //When Brown.
                    if (Table[i, j] < 0)
                    {
                        Table[ii, jj] = Store;
                        //When CheckedMated occured for Brown return false.
                        if (AA.CheckMateBrown)
                        {
                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Movable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                            return false;
                        }
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Movable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return true;
                    }
                }
                Table[ii, jj] = Store;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Movable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return false;
            }
        }
        //
        //When Oredrs of OrderPalte and Calculation Order == not equal return negative one and else return one.
        int SignOrderToPlate(int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int Sign = 1;
                //When Current Order Sign Positive.
                if (Order == AllDraw.OrderPlate)
                    Sign = 1;
                else
                    //When Order == Opposite Sign Negative.
                    if (Order != AllDraw.OrderPlate)
                    Sign = -1;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SignOrderToPlate:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Sign;
            }

        }
        //Remove Penalties of Unnesserily Nodes.
        public bool RemovePenalty(int[,] Tab, int Order, int i, int j)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                bool Remove = false;
                //Create Objects.
                ChessRules AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Tab[i, j], Tab, Order, i, j);
                //When == Check.
                if (AA.Check(Tab, Order))
                {
                    //When there == Current Checked or Objects Danger return false.
                    if (Order == 1 && (AA.CheckGray || AA.CheckGrayObjectDangour))
                    {
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("RemovePenalty:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return Remove;
                    }
                    if (Order == -1 && (AA.CheckBrown || AA.CheckBrownObjectDangour))
                    {
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("RemovePenalty:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return Remove;
                    }
                }



                //For Enemy.
                for (var ii = 0; ii < 8; ii++)
                    for (var jj = 0; jj < 8; jj++)
                    {
                        if (Order == 1 && Tab[ii, jj] >= 0)
                            continue;
                        if (Order == -1 && Tab[ii, jj] <= 0)
                            continue;
                        //Clone a Copy.
                        int[,] Table = new int[8, 8];
                        //Clone a Table.
                        for (var RowS = 0; RowS < 8; RowS++)
                            for (var ColS = 0; ColS < 8; ColS++)
                                Table[RowS, ColS] = Tab[RowS, ColS];
                        ChessRules A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[ii, jj], Table, Order * -1, ii, jj);
                        Color a = Color.Gray;
                        if (Order * -1 == -1)
                            a = Color.Brown;
                        //When there == movment to current OPbject.
                        if (A.Rules(ii, jj, i, j, a, Table[ii, jj]))
                        {
                            //Number of Attacks and take move.
                            int Count = AttackerCount(Table, Order * -1, a, ii, jj);
                            //When there == Object Danger.
                            //Clone a Copy.
                            for (var RowS = 0; RowS < 8; RowS++)
                                for (var ColS = 0; ColS < 8; ColS++)
                                    Table[RowS, ColS] = Tab[RowS, ColS];
                            //Create New Chess Rule Object.
                            A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[ii, jj], Table, Order, ii, jj);
                            //Detect int.
                            a = Color.Gray;
                            if (Order == -1)
                                a = Color.Brown;
                            //When Current Movments Attacks Enemy.
                            if (Attack(Table, i, j, ii, jj, a, Order))
                            {
                                //For Current Home.
                                for (var RowS = 0; RowS < 8; RowS++)
                                    for (var ColS = 0; ColS < 8; ColS++)
                                    {
                                        //Ignore of Enemy.
                                        if (Order == 1 && Tab[RowS, ColS] <= 0)
                                            continue;
                                        if (Order == -1 && Tab[RowS, ColS] >= 0)
                                            continue;
                                        //Whn Value Of Current == Less That Enemy.
                                        if (ObjectValueCalculator(Table, i, j) < ObjectValueCalculator(Table, ii, jj))
                                        {
                                            //Take Move.
                                            Table[ii, jj] = Table[i, j];
                                            Table[i, j] = 0;
                                            a = Color.Gray;
                                            if (Order * -1 == -1)
                                                a = Color.Brown;
                                            //When Enemy Attacks Current Moved.
                                            if (!Attack(Table, RowS, ColS, ii, jj, a, Order * -1))
                                            {
                                                //For Current Order.
                                                for (int RowD = 0; RowD < 8; RowD++)
                                                    for (int ColD = 0; ColD < 8; ColD++)
                                                    {
                                                        //Ignore of Enemy.
                                                        if (Order == 1 && Tab[RowD, ColD] <= 0)
                                                            continue;
                                                        if (Order == -1 && Tab[RowD, ColD] >= 0)
                                                            continue;
                                                        a = Color.Gray;
                                                        if (Order == -1)
                                                            a = Color.Brown;
                                                        //When Self Supported Current
                                                        if (Support(Table, RowD, ColD, i, j, a, Order))
                                                        {
                                                            //If V alue of Enemy == Greater Than Current and Value of Enemy == Greater than Supporter.
                                                            if (ObjectValueCalculator(Table, RowS, ColS) < ObjectValueCalculator(Table, ii, jj) && ObjectValueCalculator(Table, RowS, ColS) > ObjectValueCalculator(Table, Row, ColS))
                                                            {
                                                                Remove = true;
                                                                return Remove;
                                                            }
                                                            else
                                                            {
                                                                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("RemovePenalty:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                                                return Remove;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("RemovePenalty:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                                            return Remove;
                                                        }
                                                    }
                                            }
                                            else
                                            {
                                                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("RemovePenalty:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                                return Remove;
                                            }
                                        }
                                        else
                                        {
                                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("RemovePenalty:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                            return Remove;
                                        }
                                    }
                            }
                        }
                    }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("RemovePenalty:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Remove;
            }
        }
        //Dangouring of current movment fo current Order.
        bool ==CurrentState==DangreousForCurrentOrder(int[,] Tabl, int Order, Color a, int ii, int jj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //Initiate Object.
                ChessRules A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, 1, Tabl, 1, Row, Column);
                //Gray Order.
                if (Order == 1)
                {
                    //Find location of Gray King.
                    int RowG = -1, ColumnG = -1;
                    A.FindGrayKing(Tabl, ref RowG, ref ColumnG);
                    //When found.
                    if (RowG != -1 && ColumnG != -1)
                    {
                        //For Brown
                        for (var i = 0; i < 8; i++)
                            for (var j = 0; j < 8; j++)
                            {
                                //Ignore of Gray and Empty
                                if (Tabl[i, j] >= 0)
                                    continue;

                                if (i != ii && j != jj)
                                {
                                    //Create new Objects of Table
                                    int[,] TablCon = new int[8, 8];
                                    for (var RowS = 0; RowS < 8; RowS++)
                                        for (var ColS = 0; ColS < 8; ColS++)
                                            TablCon[RowS, ColS] = Tabl[RowS, ColS];
                                    //For Enemy Order.
                                    if (TablCon[i, j] < 0)
                                    {
                                        //For Gray and Empty Objects.
                                        if (TablCon[ii, jj] >= 0)
                                        {
                                            //Setting Enemy Order.
                                            int DummyOrder = Order;
                                            int DummyCurrentOrder = ChessRules.CurrentOrder;
                                            A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TablCon[i, j], TablCon, -1, i, j);
                                            //When Enemy == Attacked Gray Objects.
                                            if (A.Rules(i, j, ii, jj, Color.Brown, TablCon[i, j]))
                                            {
                                                //Take Movments.
                                                TablCon[ii, jj] = TablCon[i, j];
                                                TablCon[i, j] = 0;
                                                //Settting Current Order.
                                                ChessRules.CurrentOrder = 1;
                                                //Settting Object.
                                                A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TablCon[ii, jj], TablCon, 1, ii, jj);
                                                //When Occured Check.
                                                if (A.Check(TablCon, 1))
                                                {
                                                    //When Gray == Check.
                                                    if (A.CheckGray)
                                                    {
                                                        //For Enemy Order Objects.
                                                        for (int RowD = 0; RowD < 8; RowD++)
                                                            for (int ColD = 0; ColD < 8; ColD++)
                                                            {
                                                                //When == not Conflict.
                                                                if (RowD != i && ColD != j && RowD != ii && ColD != jj)
                                                                {
                                                                    //Setting Enemy.
                                                                    ChessRules.CurrentOrder = -1;
                                                                    //When Enemy == Supported 
                                                                    if (Support(TablCon, RowD, ColD, i, j, Color.Brown, -1))
                                                                    {
                                                                        //restore and return true.
                                                                        Order = DummyOrder;
                                                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                                                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==CurrentState==DangreousForCurrentOrder:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                                                        return true;
                                                                    }
                                                                }
                                                            }
                                                    }
                                                    Order = DummyOrder;
                                                    ChessRules.CurrentOrder = DummyCurrentOrder;

                                                }
                                            }

                                        }
                                    }
                                }
                            }
                    }
                }
                //For Brown Order.
                else if (Order == -1)
                {
                    //Found of Brown King.
                    int RowB = -1, ColumnB = -1;
                    A.FindBrownKing(Tabl, ref RowB, ref ColumnB);
                    //When found.
                    if (RowB != -1 && ColumnB != -1)
                    {
                        //For Gray.
                        for (var i = 0; i < 8; i++)
                            for (var j = 0; j < 8; j++)
                            {
                                if (Tabl[i, j] <= 0)
                                    continue;

                                if (i != ii && j != jj)
                                {
                                    //Create new Objects of Table
                                    int[,] TablCon = new int[8, 8];
                                    for (var RowS = 0; RowS < 8; RowS++)
                                        for (var ColS = 0; ColS < 8; ColS++)
                                            TablCon[RowS, ColS] = Tabl[RowS, ColS];
                                    //For Enemy Objects.
                                    if (TablCon[i, j] > 0)
                                    {
                                        //For Self Objects and Empty.
                                        if (TablCon[ii, jj] <= 0)
                                        {
                                            //Store and Enemy Order.
                                            int DummyOrder = Order;
                                            int DummyCurrentOrder = ChessRules.CurrentOrder;
                                            A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TablCon[i, j], TablCon, 1, i, j);
                                            ChessRules.CurrentOrder = 1;
                                            //When Enemy Attacked Self Objects.
                                            if (A.Rules(i, j, ii, jj, Color.Gray, TablCon[i, j]))
                                            {
                                                //Take movemnts.
                                                TablCon[ii, jj] = TablCon[i, j];
                                                TablCon[i, j] = 0;
                                                //Setting current Order.
                                                ChessRules.CurrentOrder = -1;
                                                A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TablCon[ii, jj], TablCon, -1, ii, jj);
                                                //When Check Occured.
                                                if (A.Check(TablCon, -1))
                                                {
                                                    //When Current == Check.
                                                    if (A.CheckBrown)
                                                    {
                                                        //For Enemy Objecvts.
                                                        for (int RowD = 0; RowD < 8; RowD++)
                                                            for (int ColD = 0; ColD < 8; ColD++)
                                                            {
                                                                //Ignore of Conflit.
                                                                if (RowD != i && ColD != j && RowD != ii && ColD != jj)
                                                                {
                                                                    //Setting Enemy Order
                                                                    ChessRules.CurrentOrder = 1;
                                                                    //When Enemy == Supported.
                                                                    if (Support(TablCon, RowD, ColD, i, j, Color.Gray, 1))
                                                                    {
                                                                        //restore and return true.
                                                                        Order = DummyOrder;
                                                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                                                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==CurrentState==DangreousForCurrentOrder:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                                                        return true;
                                                                    }
                                                                }
                                                            }
                                                    }
                                                    //restore.
                                                    Order = DummyOrder;
                                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                                }
                                            }

                                        }
                                    }
                                }

                            }
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==CurrentState==DangreousForCurrentOrder:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                //return false.
                return false;
            }
        }

        //When Next Movements == Checked.QC_OK.
        int[] ==NextMovment==CheckOrCheckMateForCurrentMovmentBaseKernel(int Order, int[,] Tabl, int ik, int jk, int iki, int jki, int OrderPalte, int OrderPalteMulMinuse, int Depth, bool KindCheckedSelf)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[] == = new int[4];
                Object O3 = new Object();
                lock (O3)
                {
                    ==[0] = 0;
                    ==[1] = 0;
                    ==[2] = 0;
                    ==[3] = 0;
                    int[,] Tab2 = CloneATable(Tabl);
                    ChessRules A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Tab2[ik, jk], Tab2, Order * -1, ik, jk);
                    if (Order * -1 == 1)
                        color = Color.Gray;
                    else
                        color = Color.Brown;
                    //When Enemy Attack Currnet.
                    if (A.Rules(ik, jk, iki, jki, color, Tab2[ik, jk]))
                    {
                        Tab2[iki, jki] = Tab2[ik, jk];
                        Tab2[ik, jk] = 0;
                        A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Tab2[iki, jki], Tab2, Order * -1, iki, jki);
                        //When Current Always == in CheckedMate.
                        if (A.CheckMate(Tab2, Order * -1))
                        {
                            //When Order == Gray.
                            if (OrderPalte == 1)
                            {
                                if (A.CheckMateGray)
                                {
                                    ==[0] = 1;
                                    if (KindCheckedSelf)
                                        ==[1] = Depth;

                                }
                                else
                                {
                                    //if (A.CheckMateBrown)
                                    //return ==;
                                }
                            }
                            //When Order == Brown.
                            else
                               if (OrderPalte == -1)
                            {
                                if (A.CheckMateBrown)
                                {
                                    ==[0] = 1;
                                    ==[1] = Depth;
                                }
                                else
                                {
                                    //if (A.CheckMateGray)
                                    //return ==;
                                }
                            }


                            //When Order * -1 == Gray
                            if (OrderPalteMulMinuse == 1)
                            {
                                if (A.CheckMateGray)
                                {
                                    ==[2] = 1;
                                    ==[3] = Depth;
                                }
                                else
                                {
                                    //if (A.CheckMateBrown)
                                    //return ==;
                                }
                            }
                            //When Order * -1 == Brown
                            else
                               if (OrderPalteMulMinuse == -1)
                            {
                                if (A.CheckMateBrown)
                                {
                                    ==[2] = 1;
                                    ==[3] = Depth;
                                }
                                else
                                {
                                    //if (A.CheckMateGray)
                                    //return ==;
                                }
                            }


                        }

                        if (Order * -1 == 1)
                            color = Color.Gray;
                        else
                            color = Color.Brown;
                        //if (Tab2[iki, jki] == 0)
                        //return ==;
                        //For Movements.
                        int Ord = Order * -1;
                        int[,] Tab = CloneATable(Tab2);
                        Color a = color;
                        if (Ord == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        int ik1 = ik, jk1 = jk, iki1 = iki, jki1 = jki, OrderP = OrderPalte, OrderM = OrderPalteMulMinuse, Depth1 = Depth + 1;
                        bool KindCheckedSelf1 = KindCheckedSelf;
                        Object O1 = new Object();
                        int[] == = null;
                        lock (O1)
                        {
                            == = ==NextMovment==CheckOrCheckMateForCurrentMovment(Tab, Ord, a, Depth1, OrderP, OrderM, KindCheckedSelf1);
                        }
                        if (==[0] == 1) ==[0] = 1;
                        if (==[2] == 1) ==[2] = 1;

                        ==[1] = ==[1];
                        ==[3] = ==[3];
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==NextMovment==CheckOrCheckMateForCurrentMovmentBaseKernel:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return ==;
            }
        }
        //When Next Movements == Checked.QC_OK.
        bool ==NextMovment==CheckOrCheckMateForCurrentMovmentOnCurrentMovemnet(int Order, int[,] Tabl, int ik, int jk, int iki, int jki, int OrderPalte)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                bool == = false;
                int[,] Tab2 = new int[8, 8];
                for (int ki = 0; ki < 8; ki++)
                    for (int kj = 0; kj < 8; kj++)
                        Tab2[ki, kj] = Tabl[ki, kj];
                ChessRules A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Tab2[ik, jk], Tab2, Order - 1, ik, jk);
                //When Enemy Attack Currnet.
                A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Tab2[iki, jki], Tab2, OrderPalte, iki, jki);
                //When Current Always == in CheckedMate.
                if (A.CheckMate(Tab2, OrderPalte))
                {
                    //When for penalty.
                    if (OrderPalte == AllDraw.OrderPlate)
                    {
                        //When Order == Gray.
                        if (OrderPalte == 1)
                        {
                            if (A.CheckMateGray)
                                == = true;
                            else
                            {
                                if (A.CheckMateBrown)
                                {
                                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==NextMovment==CheckOrCheckMateForCurrentMovmentOnCurrentMovemnet:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                    return ==;
                                }
                            }
                        }
                        //When Order == Brown.
                        else
                           if (OrderPalte == -1)
                        {
                            if (A.CheckMateBrown)
                                == = true;
                            else
                            {
                                if (A.CheckMateGray)
                                {
                                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==NextMovment==CheckOrCheckMateForCurrentMovmentOnCurrentMovemnet:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                    return ==;
                                }
                            }
                        }

                    }
                    //When for regard.
                    else
                    {
                        //When Order * -1 == Gray
                        if (OrderPalte == 1)
                        {
                            if (A.CheckMateGray)
                                == = true;
                            else
                            {
                                if (A.CheckMateBrown)
                                {
                                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==NextMovment==CheckOrCheckMateForCurrentMovmentOnCurrentMovemnet:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                    return ==;
                                }
                            }
                        }
                        //When Order * -1 == Brown
                        else
                           if (OrderPalte == -1)
                        {
                            if (A.CheckMateBrown)
                                == = true;
                            else
                            {
                                if (A.CheckMateGray)
                                {
                                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==NextMovment==CheckOrCheckMateForCurrentMovmentOnCurrentMovemnet:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                    return ==;
                                }
                            }
                        }
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==NextMovment==CheckOrCheckMateForCurrentMovmentOnCurrentMovemnet:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return ==;
            }
        }
        int[] ==NextMovment==CheckOrCheckMateForCurrentMovment(int[,] Tabl, int Order, Color a, int Depth, int OrderPalte, int OrderPalteMinusPluse, bool KindCheckedSelf)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[] == = new int[4];
                Object O3 = new Object();
                lock (O3)
                {
                    ==[0] = 0;
                    ==[1] = 0;
                    ==[2] = 0;
                    ==[3] = 0;
                    int DummyOrder = Order;
                    int DummyCurrentOrder = ChessRules.CurrentOrder;
                    if (Depth >= AllDraw.MaxAStarGreedy)
                    {
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==NextMovment==CheckOrCheckMateForCurrentMovment:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return ==;
                    }
                    //For All Enemies.
                    for (var ik = 0; ik < 8; ik++)
                        for (var jk = 0; jk < 8; jk++)
                        ////Parallel.For(0, 8, ik =>
                        ////Parallel.For(0, 8, jk =>
                        {
                            //Ignore of Current
                            if (Order == 1 && Tabl[ik, jk] >= 0)
                                continue;
                            if (Order == -1 && Tabl[ik, jk] <= 0)
                                continue;
                            if (System.Math.Abs(Tabl[ik, jk]) == 1)
                            {
                                //For Current Home
                                for (var iki = ik - 2; iki < ik + 3; iki++)
                                    for (var jki = jk - 2; jki < jk + 3; jki++)

                                    ////Parallel.For(ik - 2, ik + 3, iki =>
                                    ////Parallel.For(jk - 2, jk + 3, jki =>
                                    // init subtotal
                                    {
                                        if (!Scop(ik, jk, iki, jki, 1))
                                            continue;
                                        //Ignore of Enemy
                                        if (Order == 1 && Tabl[iki, jki] < 0)
                                            continue;
                                        if (Order == -1 && Tabl[iki, jki] > 0)
                                            continue;
                                        if (==[0] == 1)
                                            continue;
                                        int Ord = Order;
                                        int[,] Tab = CloneATable(Tabl);
                                        int ik1 = ik, jk1 = jk, iki1 = iki, jki1 = jki, OrderP = OrderPalte, OrderM = OrderPalteMinusPluse, Depth1 = Depth + 1;
                                        bool KindCheckedSelf1 = KindCheckedSelf;
                                        int[] == = null;
                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            == = ==NextMovment==CheckOrCheckMateForCurrentMovmentBaseKernel(Ord, Tab, ik1, jk1, iki1, jki1, OrderP, OrderM, Depth1, KindCheckedSelf1);
                                            if (==[0] == 1) ==[0] = 1; if (==[2] == 1) ==[2] = 1;
                                            ==[1] = ==[1]; ==[3] = ==[3];
                                        }

                                    }
                                //));
                            }
                            else
                            if (System.Math.Abs(Tabl[ik, jk]) == 2)
                            {

                                //For Current Home
                                ////Parallel.For(0, 8, iki =>
                                for (var iki = 0; iki < 8; iki++)
                                {
                                    var jki = iki + jk - ik;
                                    if (!Scop(ik, jk, iki, jki, 2))
                                        continue;
                                    //Ignore of Enemy
                                    if (Order == 1 && Tabl[iki, jki] < 0)
                                        continue;
                                    if (Order == -1 && Tabl[iki, jki] > 0)
                                        continue;

                                    if (==[0] == 1)
                                        continue;
                                    int Ord = Order;
                                    int[,] Tab = CloneATable(Tabl);
                                    int ik1 = ik, jk1 = jk, iki1 = iki, jki1 = jki, OrderP = OrderPalte, OrderM = OrderPalteMinusPluse, Depth1 = Depth + 1;
                                    bool KindCheckedSelf1 = KindCheckedSelf;
                                    int[] == = null;
                                    Object O1 = new Object();
                                    lock (O1)
                                    {
                                        == = ==NextMovment==CheckOrCheckMateForCurrentMovmentBaseKernel(Ord, Tab, ik1, jk1, iki1, jki1, OrderP, OrderM, Depth1, KindCheckedSelf1);
                                        if (==[0] == 1) ==[0] = 1; if (==[2] == 1) ==[2] = 1;
                                        ==[1] = ==[1]; ==[3] = ==[3];
                                    }

                                }//);
                                 //For Current Home
                                 ////Parallel.For(0, 8, iki =>
                                for (var iki = 0; iki < 8; iki++)
                                {
                                    var jki = iki * -1 + jk + ik;
                                    if (!Scop(ik, jk, iki, jki, 2))
                                        continue;
                                    //Ignore of Enemy
                                    if (Order == 1 && Tabl[iki, jki] < 0)
                                        continue;
                                    if (Order == -1 && Tabl[iki, jki] > 0)
                                        continue;

                                    if (==[0] == 1)
                                        continue;
                                    int Ord = Order;
                                    int[,] Tab = CloneATable(Tabl);
                                    int ik1 = ik, jk1 = jk, iki1 = iki, jki1 = jki, OrderP = OrderPalte, OrderM = OrderPalteMinusPluse, Depth1 = Depth + 1;
                                    bool KindCheckedSelf1 = KindCheckedSelf;
                                    int[] == = null;
                                    Object O1 = new Object();
                                    lock (O1)
                                    {
                                        == = ==NextMovment==CheckOrCheckMateForCurrentMovmentBaseKernel(Ord, Tab, ik1, jk1, iki1, jki1, OrderP, OrderM, Depth1, KindCheckedSelf1);
                                        if (==[0] == 1) ==[0] = 1; if (==[2] == 1) ==[2] = 1;
                                        ==[1] = ==[1]; ==[3] = ==[3];
                                    }
                                }//);
                            }
                            else
                            if (System.Math.Abs(Tabl[ik, jk]) == 3)
                            {
                                //For Current Home
                                ////Parallel.For(ik - 2, ik + 3, iki =>
                                ////Parallel.For(jk - 2, jk + 3, jki =>
                                for (var iki = ik - 2; iki < ik + 3; iki++)
                                    for (var jki = jk - 2; jki < jk + 3; jki++)

                                    {
                                        if (!Scop(ik, jk, iki, jki, 3))
                                            continue;
                                        //Ignore of Enemy
                                        if (Order == 1 && Tabl[iki, jki] < 0)
                                            continue;
                                        if (Order == -1 && Tabl[iki, jki] > 0)
                                            continue;

                                        int Ord = Order;
                                        int[,] Tab = CloneATable(Tabl);
                                        int ik1 = ik, jk1 = jk, iki1 = iki, jki1 = jki, OrderP = OrderPalte, OrderM = OrderPalteMinusPluse, Depth1 = Depth + 1;
                                        bool KindCheckedSelf1 = KindCheckedSelf;
                                        int[] == = null;
                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            == = ==NextMovment==CheckOrCheckMateForCurrentMovmentBaseKernel(Ord, Tab, ik1, jk1, iki1, jki1, OrderP, OrderM, Depth1, KindCheckedSelf1);
                                            if (==[0] == 1) ==[0] = 1; if (==[2] == 1) ==[2] = 1;
                                            ==[1] = ==[1]; ==[3] = ==[3];
                                        }
                                    }//));
                            }
                            else
                            if (System.Math.Abs(Tabl[ik, jk]) == 4)
                            {
                                //For Current Home
                                ////Parallel.For(0, 8, iki =>
                                for (var iki = 0; iki < 8; iki++)
                                {
                                    var jki = jk;
                                    if (!Scop(ik, jk, iki, jki, 4))
                                        continue;
                                    //Ignore of Enemy
                                    if (Order == 1 && Tabl[iki, jki] < 0)
                                        continue;
                                    if (Order == -1 && Tabl[iki, jki] > 0)
                                        continue;

                                    if (==[0] == 1)
                                        continue;
                                    int Ord = Order;
                                    int[,] Tab = CloneATable(Tabl);
                                    int ik1 = ik, jk1 = jk, iki1 = iki, jki1 = jki, OrderP = OrderPalte, OrderM = OrderPalteMinusPluse, Depth1 = Depth + 1;
                                    bool KindCheckedSelf1 = KindCheckedSelf;
                                    int[] == = null;
                                    Object O1 = new Object();
                                    lock (O1)
                                    {
                                        == = ==NextMovment==CheckOrCheckMateForCurrentMovmentBaseKernel(Ord, Tab, ik1, jk1, iki1, jki1, OrderP, OrderM, Depth1, KindCheckedSelf1);
                                        if (==[0] == 1) ==[0] = 1; if (==[2] == 1) ==[2] = 1;
                                        ==[1] = ==[1]; ==[3] = ==[3];
                                    }
                                }//);
                                 //For Current Home
                                 ////Parallel.For(0, 8, jki =>
                                for (var jki = 0; jki < 8; jki++)
                                {
                                    var iki = ik;
                                    if (!Scop(ik, jk, iki, jki, 4))
                                        continue;
                                    //Ignore of Enemy
                                    if (Order == 1 && Tabl[iki, jki] < 0)
                                        continue;
                                    if (Order == -1 && Tabl[iki, jki] > 0)
                                        continue;

                                    if (==[0] == 1)
                                        continue;
                                    int Ord = Order;
                                    int[,] Tab = CloneATable(Tabl);
                                    int ik1 = ik, jk1 = jk, iki1 = iki, jki1 = jki, OrderP = OrderPalte, OrderM = OrderPalteMinusPluse, Depth1 = Depth + 1;
                                    bool KindCheckedSelf1 = KindCheckedSelf;
                                    int[] == = null;
                                    Object O1 = new Object();
                                    lock (O1)
                                    {
                                        == = ==NextMovment==CheckOrCheckMateForCurrentMovmentBaseKernel(Ord, Tab, ik1, jk1, iki1, jki1, OrderP, OrderM, Depth1, KindCheckedSelf1);
                                        if (==[0] == 1) ==[0] = 1; if (==[2] == 1) ==[2] = 1;
                                        ==[1] = ==[1]; ==[3] = ==[3];
                                    }
                                }//);
                            }
                            else
                            if (System.Math.Abs(Tabl[ik, jk]) == 5)
                            {

                                //For Current Home
                                ////Parallel.For(0, 8, iki =>
                                ////Parallel.For(0, 8, jki =>
                                for (var iki = 0; iki < 8; iki++)
                                    for (var jki = 0; jki < 8; jki++)
                                    {
                                        //Ignore of Enemy
                                        if (Order == 1 && Tabl[iki, jki] < 0)
                                            continue;
                                        if (Order == -1 && Tabl[iki, jki] > 0)
                                            continue;
                                        if (!Scop(ik, jk, iki, jki, 5))
                                            continue;

                                        if (==[0] == 1)
                                            continue;
                                        int Ord = Order;
                                        int[,] Tab = CloneATable(Tabl);
                                        int ik1 = ik, jk1 = jk, iki1 = iki, jki1 = jki, OrderP = OrderPalte, OrderM = OrderPalteMinusPluse, Depth1 = Depth + 1;
                                        bool KindCheckedSelf1 = KindCheckedSelf;
                                        int[] == = null;
                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            == = ==NextMovment==CheckOrCheckMateForCurrentMovmentBaseKernel(Ord, Tab, ik1, jk1, iki1, jki1, OrderP, OrderM, Depth1, KindCheckedSelf1);
                                            if (==[0] == 1) ==[0] = 1; if (==[2] == 1) ==[2] = 1;
                                            ==[1] = ==[1]; ==[3] = ==[3];
                                        }
                                    }//));
                            }
                            else
                            if (System.Math.Abs(Tabl[ik, jk]) == 6)
                            {
                                //For Current Home
                                ////Parallel.For(ik - 1, ik + 2, iki =>
                                ////Parallel.For(jk - 1, jk + 2, jki =>
                                for (var iki = ik - 1; iki < ik + 2; iki++)
                                    for (var jki = jk - 1; jki < jk + 2; jki++)

                                    {
                                        if (!Scop(ik, jk, iki, jki, 6))
                                            continue;
                                        //Ignore of Enemy
                                        if (Order == 1 && Tabl[iki, jki] < 0)
                                            continue;
                                        if (Order == -1 && Tabl[iki, jki] > 0)
                                            continue;

                                        if (==[0] == 1)
                                            continue;
                                        int Ord = Order;
                                        int[,] Tab = CloneATable(Tabl);
                                        int ik1 = ik, jk1 = jk, iki1 = iki, jki1 = jki, OrderP = OrderPalte, OrderM = OrderPalteMinusPluse, Depth1 = Depth + 1;
                                        bool KindCheckedSelf1 = KindCheckedSelf;
                                        int[] == = null;
                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            == = ==NextMovment==CheckOrCheckMateForCurrentMovmentBaseKernel(Ord, Tab, ik1, jk1, iki1, jki1, OrderP, OrderM, Depth1, KindCheckedSelf1);
                                            if (==[0] == 1) ==[0] = 1; if (==[2] == 1) ==[2] = 1;
                                            ==[1] = ==[1]; ==[3] = ==[3];
                                        }
                                    }//));
                            }
                        }//));
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==NextMovment==CheckOrCheckMateForCurrentMovment:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return ==;

            }
        }
        //When Current Movements == in dangrous and == not movable.
        bool ==GardForCurrentMovmentsAnd==NotMovable(int[,] Tab, int Order, Color a, int ii, int jj, int RowS, int ColS)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //Setting false.
                bool Attacked = true;
                int NumberOfCurrentEnemyAttackSuchObject = 0;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                //For Enemy Order.
                Object O1 = new Object();
                lock (O1)
                {
                    //Ignore of Self Objects.
                    if (Order == 1 && Tab[ii, jj] >= 0)
                    {
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==GardForCurrentMovmentsAnd==NotMovable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return false;
                    }
                    else
                        if (Order == -1 && Tab[ii, jj] <= 0)
                    {
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==GardForCurrentMovmentsAnd==NotMovable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return false;
                    }
                    //Restore
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    NumberOfCurrentEnemyAttackSuchObject = 0;
                    //For Self Objects and Empty.
                    //Ignore of Enemy Objects.
                    if (Order == 1 && Tab[RowS, ColS] < 0)
                    {
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==GardForCurrentMovmentsAnd==NotMovable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return false;
                    }
                    else
                        if (Order == -1 && Tab[RowS, ColS] > 0)
                    {
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==GardForCurrentMovmentsAnd==NotMovable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return false;
                    }         //For Enemy Order.
                    ChessRules.CurrentOrder = Order * -1;
                    //Initiate for not exiting from abnormal loop.
                    Attacked = false;
                    Color aa = Color.Gray;
                    if (Order * -1 == -1)
                        aa = Color.Brown;
                    //When Enemy Attacked Current Movements.
                    if (Attack(Tab, ii, jj, RowS, ColS, aa, Order * -1) && (ObjectValueCalculator(Tab, ii, jj) < ObjectValueCalculator(Tab, RowS, ColS)))
                    {
                        NumberOfCurrentEnemyAttackSuchObject++;
                        //Clone a Table.
                        int[,] TabS = new int[8, 8];
                        for (int p = 0; p < 8; p++)
                            for (int m = 0; m < 8; m++)
                                TabS[p, m] = Tab[p, m];
                        TabS[RowS, ColS] = TabS[ii, jj];
                        TabS[ii, jj] = 0;

                        //For Self Objects.
                        ////Parallel.For(0, 8, RowD =>
                        for (int RowD = 0; RowD < 8; RowD++)

                        {
                            if (!Attacked || NumberOfCurrentEnemyAttackSuchObject > 1)
                                continue;

                            ////Parallel.For(0, 8, ColD =>
                            for (int ColD = 0; ColD < 8; ColD++)
                            {
                                if (!Attacked || NumberOfCurrentEnemyAttackSuchObject > 1)
                                    //continue;//Ignore Enmy Objects.
                                    if (Order == 1 && Tab[RowD, ColD] <= 0)
                                        continue;
                                    else
                                            if (Order == -1 && Tab[RowD, ColD] >= 0)
                                        continue;
                                //Show the Attacked.
                                Attacked = true;
                                //For Self Objects and Empty.
                                ////Parallel.For(0, 8, iiiii =>
                                for (int iiiii = 0; iiiii < 8; iiiii++)
                                {
                                    ////Parallel.For(0, 8, jjjjj =>
                                    for (int jjjjj = 0; jjjjj < 8; jjjjj++)
                                    {
                                        //Ignore of Enemy Objects.
                                        if (Order == 1 && Tab[iiiii, jjjjj] < 0)
                                            continue;
                                        else
                                               if (Order == -1 && Tab[iiiii, jjjjj] > 0)
                                            continue;
                                        //When Current Objects Movable not need to consideration mor going to next Current object.
                                        Object O2 = new Object();
                                        lock (O2)
                                        {
                                            if ((new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TabS[RowD, ColD], TabS, Order, RowD, ColD)).Rules(RowD, ColD, iiiii, jjjjj, a, TabS[RowD, ColD]))
                                            {
                                                Attacked = Attacked && false;
                                                continue;
                                            }
                                        }
                                    }//);
                                    if (!Attacked || NumberOfCurrentEnemyAttackSuchObject > 1)
                                        continue;
                                }//);
                                if (Attacked || NumberOfCurrentEnemyAttackSuchObject > 1)
                                    continue;
                            }//);
                            if (Attacked || NumberOfCurrentEnemyAttackSuchObject > 1)
                                continue;
                        }//);
                    }
                    else
                    {
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==GardForCurrentMovmentsAnd==NotMovable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return false;
                    }
                }
                //Restore.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==GardForCurrentMovmentsAnd==NotMovable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                //continue Variable when true show an object == not movable or one enemy object attack more than one current Object.
                return Attacked || NumberOfCurrentEnemyAttackSuchObject > 1;
            }
        }

        ///when current movments gards enemy with higer priority at movment.QC_OK
        bool ==CurrentCanGardHighPriorityEnemy(int Depth, int[,] Table, int Order, Color a, int ij, int ji, int iij, int jji, int OrderPlate)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                if (Depth >= CurrentAStarGredyMax)
                {
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==CurrentCanGardHighPriorityEnemy:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return false;
                }
                Object O4 = new Object();
                lock (O4)
                {
                    Depth++;
                    ==GardHighPriority = false;

                    int[,] Tabl1 = new int[8, 8];

                    for (var ik = 0; ik < 8; ik++)
                        for (var jk = 0; jk < 8; jk++)
                            Tabl1[ik, jk] = Table[ik, jk];
                    //For Current.
                    for (var i = 0; i < 8; i++)
                        for (var j = 0; j < 8; j++)
                        {
                            //Ignore of Enemy.QC_OK.
                            if (Order == 1 && Tabl1[i, j] <= 0)
                                continue;
                            else
                                if (Order == -1 && Tabl1[i, j] >= 0)
                                continue;
                            //For Enemy.
                            for (var ii = 0; ii < 8; ii++)
                                for (var jj = 0; jj < 8; jj++)
                                {
                                    //Ignore of Current.QC_OK.
                                    if (Order == 1 && Tabl1[ii, jj] >= 0)
                                        continue;
                                    else
                                        if (Order == -1 && Tabl1[ii, jj] >= 0)
                                        continue;
                                    for (var ik = 0; ik < 8; ik++)
                                        for (var jk = 0; jk < 8; jk++)
                                            Tabl1[ik, jk] = Table[ik, jk];
                                    //Take Movement.
                                    if (Attack(Tabl1, i, j, ii, jj, a, Order * -1))
                                    {
                                        //When Current Movments ==
                                        if (ObjectValueCalculator(Tabl1, i, j) <= ObjectValueCalculator(Tabl1, ii, jj))
                                        {
                                            if (Order == OrderPlate)
                                                ==GardHighPriority = true;
                                        }
                                        else
                                        {
                                            Tabl1[ii, jj] = Tabl1[i, j];
                                            Tabl1[i, j] = 0;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            ==GardHighPriority = ==GardHighPriority || ==CurrentCanGardHighPriorityEnemy(Depth, Table, Order * -1, a, ii, jj, i, j, OrderPlate);
                                        }

                                    }
                                }
                        }
                }

                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==CurrentCanGardHighPriorityEnemy:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return ==GardHighPriority;
            }
        }

        ///Hur==tic of Check and CheckMate.
        public int Hur==ticCheckAndCheckMate(int[,] Table, Color a)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int HA = 0;
                //int DummyOrder = AllDraw.OrderPlate;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                //int ObjectDangour = 1;
                //int Check = 1000;
                int ObjectDangour = 0;// 100;
                int Check = 0;// 1000;
                int CheckMate = 100000;
                //When == self objects order divide valuse by 100
                //Becuse reduce from danger == most favareable of caused to enemy attack
                /*if (Order == AllDraw.OrderPlate)
                {
                    ObjectDangour = 0.01;
                    Check = 100;
                    CheckMate = 1000;
                }*/

                Object O1 = new Object();
                lock (O1)
                {
                    //Consider Global Check CheckMate ObjectDanger Variables Orderly.
                    ChessRules A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[Row, Column], Table, Order, Row, Column);
                    ChessRules AAA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[Row, Column], Table, Order, Row, Column);
                    A.CheckMate(Table, Order);
                    AAA.Check(Table, Order);
                    ChessRules AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[Row, Column], Table, Order, Row, Column);
                    AA.ObjectDangourKingMove(Order, Table, false);
                    {
                        //Consider Value to More Valuable Positive and Negative Check CheckMate ObjectDanger 
                        if (A.CheckMateGray || A.CheckMateBrown)
                        {//When == Brown CheckedMate.
                            if (DummyOrder == 1 && A.CheckMateBrown)
                            {
                                HA += CheckMate;
                                MovementsAStarGreedyHur==ticFoundT = true;
                            }
                            //When == Gray CheckedMate.
                            if (DummyOrder == -1 && A.CheckMateGray)
                            {
                                HA += CheckMate;
                                MovementsAStarGreedyHur==ticFoundT = true;
                            }
                        }
                        //When == Checked.
                        if (AAA.CheckGray || AAA.CheckBrown)
                        {
                            //When == Gray Checked 
                            if (DummyOrder == 1 && AAA.CheckBrown)
                            {
                                HA += Check;
                                MovementsAStarGreedyHur==ticFoundT = true;
                            }
                            //When == Brown Check.
                            if (DummyOrder == -1 && AAA.CheckGray)
                            {
                                HA += Check;
                                MovementsAStarGreedyHur==ticFoundT = true;
                            }
                        }
                        //When == Objects Dangoure.
                        if (AA.CheckGrayObjectDangour || AA.CheckBrownObjectDangour)
                        {
                            //when == Gray Objects Dangoure.
                            if (DummyOrder == 1 && AA.CheckBrownObjectDangour)
                            {
                                HA += ObjectDangour;
                                MovementsAStarGreedyHur==ticFoundT = true;
                            }
                            //when == Gray Objects Dangoure.
                            if (DummyOrder == -1 && AA.CheckGrayObjectDangour)
                            {
                                HA += ObjectDangour;
                                MovementsAStarGreedyHur==ticFoundT = true;
                            }
                        }
                        //When == CheckMate
                        if (A.CheckMateGray || A.CheckMateBrown)
                        {
                            //When == Gray Check Mate.
                            if (DummyOrder == 1 && A.CheckMateGray)
                            {
                                HA -= CheckMate;
                            }
                            //when == Brown CheckMate.
                            if (DummyOrder == -1 && A.CheckMateBrown)
                            {
                                HA -= CheckMate;
                            }
                        }
                        //when == Check
                        if (AAA.CheckGray || AAA.CheckBrown)
                        {
                            //when == Gray Check
                            if (DummyOrder == 1 && AAA.CheckGray)
                            {
                                HA -= Check;
                            }
                            //When == Brown Check.
                            if (DummyOrder == -1 && AAA.CheckBrown)
                            {
                                HA -= Check;
                            }
                        }
                        //When == Object Dangoure.
                        if (AA.CheckBrownObjectDangour || AA.CheckGrayObjectDangour)
                        {
                            //When == Gray Object.
                            if (DummyOrder == 1 && AA.CheckGrayObjectDangour)
                            {
                                HA -= ObjectDangour;
                            }
                            //When == Brown Object Dangoure.
                            if (DummyOrder == -1 && AA.CheckBrownObjectDangour)
                            {
                                HA -= ObjectDangour;
                            }
                        }
                    }
                }

                //if (HA < 0)
                //IgnoreFromCheckandMateHur==tic = true;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Hur==ticCheckAndCheckMate:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

                return HA * 1;
            }
        }
        //Veryfy and detect Object Value.
        int VeryFye(int[,] Table, int Order, Color a)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int HA = 0;
                int Object = Table[Row, Column];
                //Wehn Solider.
                if (System.Math.Abs(Object) == 1)
                    HA = 1;
                //When Elephant.
                else if (System.Math.Abs(Object) == 2)
                    HA = 2;
                //When Hourse.
                else if (System.Math.Abs(Object) == 3)
                    HA = 3;
                //When Castles.
                else if (System.Math.Abs(Object) == 4)
                    HA = 5;
                //When Minster.
                else if (System.Math.Abs(Object) == 5)
                    HA = 8;
                //When King.
                else if (System.Math.Abs(Object) == 6)
                    HA = 10;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("VeryFye:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return HA;
            }
        }
        //QC_OK
        //Numbers of Supporting Current Objects method.
        int SupporterCount(int[,] Table, int Order, Color a, int ii, int jj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int Count = 0;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                if (Order == 1)
                    ChessRules.CurrentOrder = 1;
                else
                    ChessRules.CurrentOrder = -1;
                bool[,] Tab = new bool[8, 8];
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                    {
                        if (Order == 1 && Table[i, j] <= 0)
                            continue;
                        else
                            if (Order == -1 && Table[i, j] >= 0)
                            continue;
                        if (Support(Table, i, j, ii, jj, a, Order))
                        {
                            Count++;
                        }
                    }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SupporterCount:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Count;
            }
        }
        //Attacks on Enemies.
        int AttackerCount(int[,] Table, int Order, Color a, int i, int j)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int Count = 0;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                int[,] Tab = new int[8, 8];
                for (int h = 0; h < 8; h++)
                    for (int k = 0; k < 8; k++)
                        Tab[h, k] = Table[h, k];
                //For Slef Objects..
                for (var ii = 0; ii < 8; ii++)
                    for (var jj = 0; jj < 8; jj++)
                    {
                        //Ignore Of Self Objects
                        if (Order == 1 && Tab[ii, jj] >= 0)
                            continue;
                        else
                            if (Order == -1 && Tab[ii, jj] <= 0)
                            continue;
                        //If Current Attacks Enemy.
                        if (Attack(Tab, i, j, ii, jj, a, Order))
                        {
                            Count++;
                        }
                    }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("AttackerCount:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Count;
            }
        }
        //Attackers of Enemies.QC_OK.
        int EnemyAttackerCount(int[,] Table, int Order, Color a, int ii, int jj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int Count = 0;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                if (Order == 1)
                    ChessRules.CurrentOrder = 1;
                else
                    ChessRules.CurrentOrder = -1;
                int[,] Tab = new int[8, 8];
                for (int h = 0; h < 8; h++)
                    for (int k = 0; k < 8; k++)
                        Tab[h, k] = Table[h, k];
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                    {
                        if (Order == 1 && Table[i, j] >= 0)
                            continue;
                        else
                            if (Order == -1 && Table[i, j] <= 0)
                            continue;
                        if (Attack(Table, i, j, ii, jj, a, Order * -1))
                        {
                            Count++;
                        }
                    }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("EnemyAttackerCount:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Count;
            }
        }
        //D==tance of Enemy Kings from Current Object.
        public int Heur==ticD==tabceOfCurrentMoveFromEnemyKing(int[,] Tab, int Order, int RowS, int ColS)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //Initiate.
                int RowG = -1, ColumnG = -1, RowB = -1, ColumnB = -1;
                //Create ChessRules Objects.
                ChessRules A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Tab[RowS, ColS], Tab, Order, RowS, ColS);
                int D== = 0;
                //Order ==  Gray.
                if (Order == -1)
                {
                    //Found of Gray King Location.
                    A.FindGrayKing(Tab, ref RowG, ref ColumnG);

                    //When Soldier.
                    if (System.Math.Abs(Tab[RowS, ColS]) == 1)
                        D== = (int)(AllDraw.SignD==tance * System.Math.Sqrt(//System.Math.Pow(RowS - RowG, 2) + System.Math.Pow(ColS - ColumnG, 2)
                            ((RowS - RowG) * (RowS - RowG)) + ((ColS - ColumnG) * (ColS - ColumnG))));
                    else
                        //When Elephant.
                        if (System.Math.Abs(Tab[RowS, ColS]) == 2)
                        D== = (int)(AllDraw.SignD==tance * System.Math.Sqrt(//System.Math.Pow(RowS - RowG, 2) + System.Math.Pow(ColS - ColumnG, 2)
                            ((RowS - RowG) * (RowS - RowG)) + ((ColS - ColumnG) * (ColS - ColumnG))));
                    else
                            //When Hourse.
                            if (System.Math.Abs(Tab[RowS, ColS]) == 3)
                        D== = (int)(AllDraw.SignD==tance * System.Math.Sqrt(//System.Math.Pow(RowS - RowG, 2) + System.Math.Pow(ColS - ColumnG, 2)
                            ((RowS - RowG) * (RowS - RowG)) + ((ColS - ColumnG) * (ColS - ColumnG))));
                    else
                                //When Castles.
                                if (System.Math.Abs(Tab[RowS, ColS]) == 4)
                        D== = (int)(AllDraw.SignD==tance * System.Math.Sqrt(//System.Math.Pow(RowS - RowG, 2) + System.Math.Pow(ColS - ColumnG, 2)
                           ((RowS - RowG) * (RowS - RowG)) + ((ColS - ColumnG) * (ColS - ColumnG))));
                    else
                                    //When min==ter.
                                    if (System.Math.Abs(Tab[RowS, ColS]) == 5)
                        D== = (int)(AllDraw.SignD==tance * System.Math.Sqrt(//System.Math.Pow(RowS - RowG, 2) + System.Math.Pow(ColS - ColumnG, 2)
                           ((RowS - RowG) * (RowS - RowG)) + ((ColS - ColumnG) * (ColS - ColumnG))));
                    else
                                        //When King.
                                        if (System.Math.Abs(Tab[RowS, ColS]) == 6)
                        D== = (int)(AllDraw.SignD==tance * System.Math.Sqrt(//System.Math.Pow(RowS - RowG, 2) + System.Math.Pow(ColS - ColumnG, 2)
                            ((RowS - RowG) * (RowS - RowG)) + ((ColS - ColumnG) * (ColS - ColumnG))));

                }
                //Brown Order.
                else
                {
                    //Found of Brown King Location.
                    A.FindBrownKing(Tab, ref RowB, ref ColumnB);
                    //When Soldier.
                    if (System.Math.Abs(Tab[RowS, ColS]) == 1)
                        D== = (int)(AllDraw.SignD==tance * System.Math.Sqrt(//System.Math.Pow(RowS - RowB, 2) + System.Math.Pow(ColS - ColumnB, 2)
                            ((RowS - RowB) * (RowS - RowB)) + ((ColS - ColumnB) * (ColS - ColumnB))));
                    else
                        //When Elephant.
                        if (System.Math.Abs(Tab[RowS, ColS]) == 2)
                        D== = (int)(AllDraw.SignD==tance * System.Math.Sqrt(//System.Math.Pow(RowS - RowB, 2) + System.Math.Pow(ColS - ColumnB, 2)
                             ((RowS - RowB) * (RowS - RowB)) + ((ColS - ColumnB) * (ColS - ColumnB))));
                    else
                            //When Hourse.
                            if (System.Math.Abs(Tab[RowS, ColS]) == 3)
                        D== = (int)(AllDraw.SignD==tance * System.Math.Sqrt(//System.Math.Pow(RowS - RowB, 2) + System.Math.Pow(ColS - ColumnB, 2)
                              ((RowS - RowB) * (RowS - RowB)) + ((ColS - ColumnB) * (ColS - ColumnB))));
                    else
                                //When Castles.
                                if (System.Math.Abs(Tab[RowS, ColS]) == 4)
                        D== = (int)(AllDraw.SignD==tance * System.Math.Sqrt(//System.Math.Pow(RowS - RowB, 2) + System.Math.Pow(ColS - ColumnB, 2)
                              ((RowS - RowB) * (RowS - RowB)) + ((ColS - ColumnB) * (ColS - ColumnB))));
                    else
                                    //When Min==ter.
                                    if (System.Math.Abs(Tab[RowS, ColS]) == 5)
                        D== = (int)(AllDraw.SignD==tance * System.Math.Sqrt(//System.Math.Pow(RowS - RowB, 2) + System.Math.Pow(ColS - ColumnB, 2)
                              ((RowS - RowB) * (RowS - RowB)) + ((ColS - ColumnB) * (ColS - ColumnB))));
                    else
                        //When King.
                        D== = (int)(AllDraw.SignD==tance * System.Math.Sqrt(//System.Math.Pow(RowS - RowB, 2) + System.Math.Pow(ColS - ColumnB, 2)
                             ((RowS - RowB) * (RowS - RowB)) + ((ColS - ColumnB) * (ColS - ColumnB))));
                    //D== = (int)( -1000;

                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Heur==ticD==tabceOfCurrentMoveFromEnemyKing:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return D==;
            }
        }
        public int Hur==ticSoldierFromCenter(int[,] Table, Color aa, int Ord, int ii, int jj, int i, int j)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int HA = 0;
                Object O1 = new Object();
                lock (O1)
                {
                    if (System.Math.Abs(Table[ii, jj]) == 1)
                    {
                        if (!ArrangmentsChanged)
                        {
                            if (Order == 1)
                            {
                                if (i < 4 && j < 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(i - 3, 2) + System.Math.Pow(j - 3, 2)
                                        ((i - 3) * (i - 3)) + ((j - 3) * (j - 3)))));

                                }
                                if (i < 4 && j >= 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(i - 3, 2) + System.Math.Pow(j - 4, 2)
                                         ((i - 3) * (i - 3)) + ((j - 4) * (j - 4)))));
                                }

                            }
                            else
                            {
                                if (i >= 4 && j < 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(i - 4, 2) + System.Math.Pow(j - 3, 2)
                                         ((i - 4) * (i - 4)) + ((j - 3) * (j - 3)))));
                                }
                                if (i >= 4 && j >= 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(i - 4, 2) + System.Math.Pow(j - 4, 2)
                                        ((i - 4) * (i - 4)) + ((j - 4) * (j - 4)))));
                                }
                            }
                        }
                        else
                        {
                            if (Order == -1)
                            {
                                if (i < 4 && j < 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(i - 3, 2) + System.Math.Pow(j - 3, 2)
                                         ((i - 3) * (i - 3)) + ((j - 3) * (j - 3)))));
                                }
                                if (i < 4 && j >= 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(i - 3, 2) + System.Math.Pow(j - 4, 2)
                                         ((i - 3) * (i - 3)) + ((j - 4) * (j - 4)))));
                                }

                            }
                            else
                            {
                                if (i >= 4 && j < 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(i - 4, 2) + System.Math.Pow(j - 3, 2)
                                         ((i - 4) * (i - 4)) + ((j - 3) * (j - 3)))));
                                }
                                if (i >= 4 && j >= 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(i - 4, 2) + System.Math.Pow(j - 4, 2)
                                         ((i - 4) * (i - 4)) + ((j - 4) * (j - 4)))));
                                }
                            }
                        }



                    }
                    else if (System.Math.Abs(Table[ii, jj]) == 1)
                    {
                        if (!ArrangmentsChanged)
                        {
                            if (Order == 1)
                            {
                                if (ii < 4 && jj < 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(ii - 3, 2) + System.Math.Pow(jj - 3, 2)
                                         ((ii - 3) * (ii - 3)) + ((jj - 3) * (jj - 3)))));
                                }
                                if (ii < 4 && jj >= 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(ii - 3, 2) + System.Math.Pow(jj - 4, 2)
                                         ((ii - 3) * (ii - 3)) + ((jj - 4) * (jj - 4)))));
                                }

                            }
                            else
                            {
                                if (ii >= 4 && jj < 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(ii - 4, 2) + System.Math.Pow(jj - 3, 2)
                                        ((ii - 4) * (ii - 4)) + ((jj - 3) * (jj - 3)))));
                                }
                                if (ii >= 4 && jj >= 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(ii - 4, 2) + System.Math.Pow(jj - 4, 2)
                                        ((ii - 4) * (ii - 4)) + ((jj - 4) * (jj - 4)))));
                                }
                            }
                        }
                        else
                        {
                            if (Order == -1)
                            {
                                if (ii < 4 && jj < 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(ii - 3, 2) + System.Math.Pow(jj - 3, 2)
                                         ((ii - 3) * (ii - 3)) + ((jj - 3) * (jj - 3)))));
                                }
                                if (ii < 4 && jj >= 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(ii - 3, 2) + System.Math.Pow(jj - 4, 2)
                                         ((ii - 3) * (ii - 3)) + ((jj - 4) * (jj - 4)))));
                                }

                            }
                            else
                            {
                                if (ii >= 4 && jj < 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(ii - 4, 2) + System.Math.Pow(jj - 3, 2)
                                         ((ii - 4) * (ii - 4)) + ((jj - 3) * (jj - 3)))));
                                }
                                if (ii >= 4 && jj >= 4)
                                {
                                    HA += (int)(((-1) * System.Math.Sqrt(//System.Math.Pow(ii - 4, 2) + System.Math.Pow(jj - 4, 2)
                                        ((ii - 4) * (ii - 4)) + ((jj - 4) * (jj - 4)))));
                                }
                            }
                        }


                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Hur==ticSoldierFromCenter:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return 1 * HA;
            }
        }
        public int[] Hur==ticAll(bool Before, int Killed, int[,] Table, Color aa, int Ord, int RowS, int ColS, int RowD, int ColD)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[] Hur==tic = new int[6];
                //Initiate Local Variable.

                //var RowS = RowD, ColS = ColS;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                ///When AStarGreedy Hur==tic == Not Assigned.

                if (!AStarGreedyHur==ticT)
                {
                    //For Current Objects.
                    ////Parallel.For(0, 8, RowS =>
                    {
                        ////Parallel.For(0, 8, ColS =>
                        {
                            Object O1 = new Object();
                            lock (O1)
                            {
                                int i1 = RowS, j1 = ColS, iiii1 = RowD, jjjj1 = ColD;
                                int[,] Table1 = CloneATable(Table);
                                int Ord1 = Ord;
                                Color aa1 = aa;
                                int HAA1 = Hur==ticAttack(Before, Table1, Ord1, aa1, i1, j1, iiii1, jjjj1);
                                if (HAA1 != 0)
                                    Hur==tic[0] += HAA1;

                                int i2 = RowS, j2 = ColS, iiii2 = RowD, jjjj2 = ColD;
                                int[,] Table2 = CloneATable(Table);
                                int Ord2 = Ord;
                                Color aa2 = aa;
                                int Killed1 = Killed;
                                int HAA2 = Hur==ticKiller(Killed1, Table2, i2, j2, iiii2, jjjj2, Ord2, aa2, false);
                                if (HAA2 != 0)
                                    Hur==tic[1] += HAA2;

                                int i3 = RowS, j3 = ColS, iiii3 = RowD, jjjj3 = ColD;
                                int[,] Table3 = CloneATable(Table);
                                int Ord3 = Ord;
                                Color aa3 = aa;
                                int HAA3 = Hur==ticMovment(Before, Table3, aa3, Ord3, i3, j3, iiii3, jjjj3);
                                if (HAA3 != 0)
                                    Hur==tic[2] += HAA3;

                                int i4 = RowS, j4 = ColS, iiii4 = RowD, jjjj4 = ColD;
                                int[,] Table4 = CloneATable(Table);
                                int Ord4 = Ord;
                                Color aa4 = aa;
                                int HAA4 = Hur==ticObjectDangour(Table4, Ord4, aa4, i4, j4, iiii4, jjjj4);
                                if (HAA4 != 0)
                                    Hur==tic[3] += HAA4;

                                int i5 = RowS, j5 = ColS, iiii5 = RowD, jjjj5 = ColD;
                                int[,] Table5 = CloneATable(Table);
                                int Ord5 = Ord;
                                Color aa5 = aa;
                                int HAA5 = Hur==ticReducsedAttack(Before, Table5, Ord5, aa5, i5, j5, iiii5, jjjj5
                                    );
                                if (HAA5 != 0)
                                    Hur==tic[4] += HAA5;

                                int i6 = RowS, j6 = ColS, iiii6 = RowD, jjjj6 = ColD;
                                int[,] Table6 = CloneATable(Table);
                                int Ord6 = Ord;
                                Color aa6 = aa;
                                int HAA6 = Hur==ticSelfSupported(Table6, Ord6, aa6, i6, j6, iiii6, jjjj6
                                    );
                                if (HAA6 != 0)
                                    Hur==tic[5] += HAA6;
                            }

                        }//);
                    }//);
                }
                //For All Homes Table.
                else
                {
                    ////Parallel.For(0, 8, RowS =>
                    {
                        ////Parallel.For(0, 8, ColS =>
                        {
                            ////Parallel.For(0, 8, ii =>
                            for (var ii = 0; ii < 8; ii++)
                            {
                                ////Parallel.For(0, 8, jj =>
                                for (var jj = 0; jj < 8; jj++)
                                {
                                    Object O1 = new Object();
                                    lock (O1)
                                    {
                                        int i1 = RowS, j1 = ColS, iiii1 = RowD, jjjj1 = ColD;
                                        int[,] Table1 = CloneATable(Table);
                                        int Ord1 = Ord;
                                        Color aa1 = aa;
                                        int HAA1 = Hur==ticAttack(Before, Table1, Ord1, aa1, i1, j1, iiii1, jjjj1);
                                        Hur==tic[0] += HAA1;

                                        int i2 = RowS, j2 = ColS, iiii2 = RowD, jjjj2 = ColD;
                                        int[,] Table2 = CloneATable(Table);
                                        int Ord2 = Ord;
                                        Color aa2 = aa;
                                        int Killed1 = Killed;
                                        int HAA2 = Hur==ticKiller(Killed1, Table2, i2, j2, iiii2, jjjj2, Ord2, aa2, false);
                                        Hur==tic[1] += HAA2;

                                        int i3 = RowS, j3 = ColS, iiii3 = RowD, jjjj3 = ColD;
                                        int[,] Table3 = CloneATable(Table);
                                        int Ord3 = Ord;
                                        Color aa3 = aa;
                                        int HAA3 = Hur==ticMovment(Before, Table3, aa3, Ord3, i3, j3, iiii3, jjjj3);
                                        Hur==tic[2] += HAA3;

                                        int i4 = RowS, j4 = ColS, iiii4 = RowD, jjjj4 = ColD;
                                        int[,] Table4 = CloneATable(Table);
                                        int Ord4 = Ord;
                                        Color aa4 = aa;
                                        int HAA4 = Hur==ticObjectDangour(Table4, Ord4, aa4, i4, j4, iiii4, jjjj4);
                                        Hur==tic[3] += HAA4;

                                        int i5 = RowS, j5 = ColS, iiii5 = RowD, jjjj5 = ColD;
                                        int[,] Table5 = CloneATable(Table);
                                        int Ord5 = Ord;
                                        Color aa5 = aa;
                                        int HAA5 = Hur==ticReducsedAttack(Before, Table5, Ord5, aa5, i5, j5, iiii5, jjjj5
                                            );
                                        Hur==tic[4] += HAA5;

                                        int i6 = RowS, j6 = ColS, iiii6 = RowD, jjjj6 = ColD;
                                        int[,] Table6 = CloneATable(Table);
                                        int Ord6 = Ord;
                                        Color aa6 = aa;
                                        int HAA6 = Hur==ticSelfSupported(Table6, Ord6, aa6, i6, j6, iiii6, jjjj6
                                            );
                                        Hur==tic[5] += HAA6;
                                    }
                                }//);
                            }//);
                        }//);
                    }//);
                }


                //Reassignments of Begin Call Global Orders.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //Store Local Hur==tic in Global One.
                //Hur==tic[0] = (Hur==tic[0]* SignOrderToPlate(Order));
                //Hur==tic[1] = (Hur==tic[1]* SignOrderToPlate(Order));
                //Hur==tic[2] = (Hur==tic[2]* SignOrderToPlate(Order));
                //Hur==tic[3] = (Hur==tic[3]* SignOrderToPlate(Order));
                //Hur==tic[4] = (Hur==tic[4]* SignOrderToPlate(Order));
                //Hur==tic[5] = (Hur==tic[5]* SignOrderToPlate(Order));
                //Return Local Hur==tic.
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Hur==ticAll:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Hur==tic;
            }
        }
        ///Hur==tic of Movments.
        public int Hur==ticMovment(bool Before, int[,] Table, Color aa, int Ord, int RowS, int ColS, int RowD, int ColD)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int Hur==ticMovementValue = 0;
                //Initiate Local Variable.
                int HA = 0;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                ///When AStarGreedy Hur==tic == Not Assigned.

                if (!AStarGreedyHur==ticT)
                {
                    int Order = new int();
                    Color a = new Color();
                    a = aa;
                    Order = DummyOrder;
                    int Sign = new int();
                    ///When Moveble == true. means [RowS,ColS] == in Movmebale to [RowD,ColD].
                    ///What == Moveable!
                    ///Ans:When [RowS,ColS] == Movebale to [RowD,ColD] continue true when Empty or Enemy == located in [RowS,ColS].
                    if (Table[RowD, ColD] == 0 && DummyOrder == -1 && Table[RowS, ColS] < 0)
                    {
                        Order = -1;
                        Object O1 = new Object();
                        lock (O1)
                        {
                            Sign = 1 * AllDraw.SignMovments;
                            ChessRules.CurrentOrder = -1;
                        }
                        a = Color.Brown;
                    }
                    else if (Table[RowD, ColD] == 0 && DummyOrder == 1 && Table[RowS, ColS] > 0)
                    {
                        Order = 1;
                        Object O1 = new Object();
                        lock (O1)
                        {
                            Sign = 1 * AllDraw.SignMovments;
                            ChessRules.CurrentOrder = 1;
                        }
                        a = Color.Gray;
                    }
                    else
                        return Hur==ticMovementValue;
                    if (Before)
                    {
                        //When == Movable Movement inCurrent.
                        if (Movable(Table, RowS, ColS, RowD, ColD, a, Order))
                        {
                            int[,] Tab = new int[8, 8];

                            for (var ik = 0; ik < 8; ik++)
                                for (var jk = 0; jk < 8; jk++)
                                    Tab[ik, jk] = Table[ik, jk];
                            HA += (Sign * (System.Math.Abs(ObjectValueCalculator(Table, RowS, ColS, RowD, ColD))));
                            /* int Supported = 0;
                             int Attacked = 0;
                             //For All Enemy Obejcts.                                             
                             for (int g = 0; g < 8; g++)
                             ////Parallel.For(0, 8, g =>
                             {
                                 ////Parallel.For(0, 8, h =>
                                 for (int h = 0; h < 8; h++)
                                 {
                                     Object O2 = new Object();
                                     lock (O2)
                                     {
                                         //Ignore Of Self Objects.
                                         if (Order == 1 && Table[g, h] == 0)
                                             continue;
                                         if (Order == -1 && Table[g, h] == 0)
                                             continue;
                                         Color aaa = new Color();
                                         //Assgin Enemy ints.
                                         aaa = Color.Gray;
                                         if (Order * -1 == -1)
                                             aaa = Color.Brown;
                                         else
                                             aaa = Color.Gray;
                                         //When Enemy == Supported.
                                         bool A = new bool();
                                         bool B = new bool();
                                         A = Support(Tab, g, h, RowS, ColS, a, Order);
                                         B = Attack(Tab, g, h, RowS, ColS, aaa, Order * -1);
                                         //When Enemy == Supported.
                                         if (B)
                                         {
                                             //Assgine variable.
                                             Attacked++;
                                         }
                                         if (A)
                                         {
                                             //Assgine variable.
                                             Supported++;
                                             continue;
                                         }
                                     }
                                 }//);

                             }//);
                             Object O1 = new Object();
                             lock (O1)
                             {
                                 if (Supported != 0)
                                     //When == Not Supported multyply 100.
                                     HA *= System.Math.Pow(2, Supported);

                                 //When == Supported Multyply -100.
                                 if (Attacked != 0)
                                     //When == Not Supported multyply 100.
                                     HA *= -(1 * System.Math.Pow(2, Attacked));

                             }*/
                        }
                    }

                }
                //For All Homes Table.
                else
                {
                    int Order = new int();
                    Color a = new Color();
                    a = aa;
                    if (RowD == RowS && ColD == ColS)
                        return Hur==ticMovementValue;
                    int Sign = new int();
                    Order = DummyOrder;
                    ///When Moveble == true. means [RowS,ColS] == in Movmebale to [RowD,ColD].
                    ///What == Moveable!
                    ///Ans:When [RowS,ColS] == Movebale to [RowD,ColD] continue true when Empty or Enemy == located in [RowS,ColS].
                    if (Table[RowD, ColD] == 0 && DummyOrder == -1 && Table[RowS, ColS] < 0)
                    {
                        Order = -1;
                        Object O1 = new Object();
                        lock (O1)
                        {
                            Sign = 1 * AllDraw.SignMovments;
                            ChessRules.CurrentOrder = -1;
                            a = Color.Brown;
                        }
                    }
                    else if (Table[RowD, ColD] == 0 && DummyOrder == 1 && Table[RowS, ColS] > 0)
                    {
                        Order = 1;
                        Object O1 = new Object();
                        lock (O1)
                        {
                            Sign = 1 * AllDraw.SignMovments;
                            ChessRules.CurrentOrder = 1;
                            a = Color.Gray;
                        }
                    }
                    else
                        return Hur==ticMovementValue;
                    if (Before)
                    {
                        //When == Movable Movement inCurrent.
                        if (Movable(Table, RowS, ColS, RowD, ColD, a, Order))
                        {
                            HA += (Sign * (System.Math.Abs(ObjectValueCalculator(Table, RowS, ColS, RowD, ColD))));
                            /*int Supported = 0;
                            int Attacked = 0;
                            //For All Enemy Obejcts.                                             
                            for (int g = 0; g < 8; g++)
                            ////Parallel.For(0, 8, g =>
                            {
                                ////Parallel.For(0, 8, h =>
                                for (int h = 0; h < 8; h++)
                                {
                                    Object O2 = new Object();
                                    lock (O2)
                                    {
                                        //Ignore Of Self Objects.
                                        if (Order == 1 && Table[g, h] == 0)
                                            continue;
                                        if (Order == -1 && Table[g, h] == 0)
                                            continue;
                                        Color aaa = new Color();
                                        //Assgin Enemy ints.
                                        aaa = Color.Gray;
                                        if (Order * -1 == -1)
                                            aaa = Color.Brown;
                                        else
                                            aaa = Color.Gray;
                                        //When Enemy == Supported.
                                        bool A = new bool();
                                        bool B = new bool();
                                        A = Support(Table, g, h, RowS, ColS, a, Order);
                                        B = Attack(Table, g, h, RowS, ColS, aaa, Order * -1);
                                        //When Enemy == Supported.
                                        if (B)
                                        {
                                            //Assgine variable.
                                            Attacked++;
                                        }
                                        if (A)
                                        {
                                            //Assgine variable.
                                            Supported++;
                                            continue;
                                        }
                                    }
                                }//);

                            }//);
                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Supported != 0)
                                    //When == Not Supported multyply 100.
                                    HA *= System.Math.Pow(2, Supported);

                                //When == Supported Multyply -100.
                                if (Attacked != 0)
                                    //When == Not Supported multyply 100.
                                    HA *= (-1 * System.Math.Pow(2, Attacked));

                            }*/
                        }
                    }
                }

                //Reassignments of Begin Call Global Orders.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //Store Local Hur==tic in Global One.
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Hur==ticMovment:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return HA * 1;
            }
        }
        ///Attack Determination.QC_Ok
        public bool Attack(int[,] Tab, int i, int j, int ii, int jj, Color a, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int CCurentOrder = ChessRules.CurrentOrder;
                //Initiate Global static  Variable.
                ChessRules.CurrentOrder = Order;
                int[,] Table = new int[8, 8];
                for (var ik = 0; ik < 8; ik++)
                    for (var jk = 0; jk < 8; jk++)
                        Table[ik, jk] = Tab[ik, jk];

                //when there == a Movment from Parameter One to Second Parameter return Attacke..
                if ((new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[i, j], Table, Order, i, j)).Rules(i, j, ii, jj, a, Order) //&& Table[ii, jj] != 0
                    )
                {
                    ChessRules.CurrentOrder = CCurentOrder;
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Attack:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return true;
                }
                ChessRules.CurrentOrder = CCurentOrder;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Attack:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return false;
            }
        }
        //Object Danger Determination.
        public bool ObjectDanger(int[,] Tab, int i, int j, int ii, int jj, Color a, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int CCurrentOrder = ChessRules.CurrentOrder;
                //Initiate Local Varibales.
                int[,] Table = new int[8, 8];
                for (var RowS = 0; RowS < 8; RowS++)
                    for (var ColS = 0; ColS < 8; ColS++)
                    {
                        Table[RowS, ColS] = Tab[RowS, ColS];
                    }
                ChessRules.CurrentOrder = Order;
                ///When [i,j] == Attacked [ii,jj] retrun true when enemy == located in [ii,jj].
                if ((new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[i, j], Table, Order, i, j)).Rules(i, j, ii, jj, a, Order))
                {
                    //Initiate Local Variables.
                    for (var RowS = 0; RowS < 8; RowS++)
                        for (var ColS = 0; ColS < 8; ColS++)
                        {
                            Table[RowS, ColS] = Tab[RowS, ColS];
                        }
                    //Take Movments.
                    Table[ii, jj] = Table[i, j];
                    Table[i, j] = 0;
                    //Consider Check.
                    ChessRules AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[ii, jj], Table, Order, ii, jj);
                    if (AA.ObjectDangourKingMove(Order, Table, false))
                    {
                        ChessRules.CurrentOrder = CCurrentOrder;
                        //Return ObjectDanger.
                        if ((AA.CheckGrayObjectDangour) && Order == 1)
                        {
                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ObjectDanger:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                            return true;
                        }
                        else
                            if ((AA.CheckBrownObjectDangour) && Order == -1)
                        {
                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ObjectDanger:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                            return true;
                        }
                    }
                    if (AA.CheckMate(Table, Order))
                    {
                        ChessRules.CurrentOrder = CCurrentOrder;
                        //Return ObjectDanger.
                        if ((AA.CheckGray || AA.CheckMateGray) && Order == 1)
                        {
                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ObjectDanger:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                            return true;
                        }
                        else
                            if ((AA.CheckBrown || AA.CheckMateBrown) && Order == -1)
                        {
                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ObjectDanger:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                            return true;
                        }
                    }
                }





                ChessRules.CurrentOrder = CCurrentOrder;

                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ObjectDanger:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                //return Non ObjectDanger.
                return false;
            }
        }
        ///Supportation Determination.QC_OK
        public bool Support(int[,] Tab, int i, int j, int ii, int jj, Color a, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                //Initiate Local Variables.
                int[,] Table = new int[8, 8];

                for (var RowS = 0; RowS < 8; RowS++)
                    for (var ColS = 0; ColS < 8; ColS++)
                        Table[RowS, ColS] = Tab[RowS, ColS];
                ///When All Tables == Gray.
                if (Table[i, j] > 0 && Table[ii, jj] > 0)
                {
                    ///When [i,j] Supporte [ii,jj].
                    if ((new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[i, j], Table, Order, i, j)).Rules(i, j, ii, jj, a, Table[i, j], false))
                    {
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Support:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return true;
                    }

                }

                for (var RowS = 0; RowS < 8; RowS++)
                    for (var ColS = 0; ColS < 8; ColS++)
                        Table[RowS, ColS] = Tab[RowS, ColS];
                ///When All == Brown.
                if (Table[i, j] < 0 && Table[ii, jj] < 0)
                {
                    ///When [i,j] Supporetd [ii,jj].
                    if ((new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[i, j], Table, Order, i, j)).Rules(i, j, ii, jj, a, Table[i, j], false))
                    {
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Support:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return true;
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Support:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return false;
            }
        }

        //Return Msx Huir==tic of Child Level.
        public bool MaxHur==tic(ref int j, int Kin, ref int Less, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {





                bool Found = false;
                //When Solders.
                if (Kin == 1)
                {
                    for (var i = 0; i < th==.PenaltyRegardL==tSolder.Count; i++)
                    {
                        if (PenaltyRegardL==tSolder[i].==PenaltyAction() != 0)
                        {
                            if (Order == AllDraw.OrderPlate)
                            {
                                if (Less > Hur==ticL==tSolder[i][0] +
                                    Hur==ticL==tSolder[i][1] +
                                    Hur==ticL==tSolder[i][2] +
                                    Hur==ticL==tSolder[i][3] +
                                    Hur==ticL==tSolder[i][4] +
                                    Hur==ticL==tSolder[i][5] +
                                    Hur==ticL==tSolder[i][6] +
                                    Hur==ticL==tSolder[i][7] +
                                    Hur==ticL==tSolder[i][8] +
                                    Hur==ticL==tSolder[i][9])
                                {
                                    Less = Hur==ticL==tSolder[i][0] +
                                Hur==ticL==tSolder[i][1] +
                                Hur==ticL==tSolder[i][2] +
                                Hur==ticL==tSolder[i][3] +
                                Hur==ticL==tSolder[i][4] +
                                Hur==ticL==tSolder[i][5] +
                                Hur==ticL==tSolder[i][6] +
                                Hur==ticL==tSolder[i][7] +
                                    Hur==ticL==tSolder[i][8] +
                                    Hur==ticL==tSolder[i][9];
                                    j = i;
                                    Found = true;
                                }
                            }
                            else
                            {
                                if (Less < Hur==ticL==tSolder[i][0] +
                             Hur==ticL==tSolder[i][1] +
                             Hur==ticL==tSolder[i][2] +
                             Hur==ticL==tSolder[i][3] +
                             Hur==ticL==tSolder[i][4] +
                             Hur==ticL==tSolder[i][5] +
                             Hur==ticL==tSolder[i][6] +
                             Hur==ticL==tSolder[i][7] +
                             Hur==ticL==tSolder[i][8] +
                             Hur==ticL==tSolder[i][9])
                                {
                                    Less = Hur==ticL==tSolder[i][0] +
                                Hur==ticL==tSolder[i][1] +
                                Hur==ticL==tSolder[i][2] +
                                Hur==ticL==tSolder[i][3] +
                                Hur==ticL==tSolder[i][4] +
                                Hur==ticL==tSolder[i][5] +
                                Hur==ticL==tSolder[i][6] +
                                Hur==ticL==tSolder[i][7] +
                                    Hur==ticL==tSolder[i][8] +
                                    Hur==ticL==tSolder[i][9];
                                    j = i;
                                    Found = true;
                                }
                            }

                        }
                    }

                }

                else//When Elephant.
                    if (Kin == 2)
                {
                    for (var i = 0; i < th==.PenaltyRegardL==tElefant.Count; i++)
                    {
                        if (PenaltyRegardL==tElefant[i].==PenaltyAction() != 0)
                        {
                            if (Order == AllDraw.OrderPlate)
                            {
                                if (Less > Hur==ticL==tElefant[i][0] +
                                    Hur==ticL==tElefant[i][1] +
                                    Hur==ticL==tElefant[i][2] +
                                    Hur==ticL==tElefant[i][3] +
                                    Hur==ticL==tElefant[i][4] +
                                    Hur==ticL==tElefant[i][5] +
                                    Hur==ticL==tElefant[i][6] +
                                    Hur==ticL==tElefant[i][7] +
                                    Hur==ticL==tElefant[i][8] +
                                    Hur==ticL==tElefant[i][9])
                                {
                                    Less = Hur==ticL==tElefant[i][0] +
                                Hur==ticL==tElefant[i][1] +
                                Hur==ticL==tElefant[i][2] +
                                Hur==ticL==tElefant[i][3] +
                                Hur==ticL==tElefant[i][4] +
                                Hur==ticL==tElefant[i][5] +
                                Hur==ticL==tElefant[i][6] +
                                Hur==ticL==tElefant[i][7] +
                                    Hur==ticL==tElefant[i][8] +
                                    Hur==ticL==tElefant[i][9];
                                    j = i;
                                    Found = true;
                                }
                            }
                            else
                            {
                                if (Less < Hur==ticL==tElefant[i][0] +
                             Hur==ticL==tElefant[i][1] +
                             Hur==ticL==tElefant[i][2] +
                             Hur==ticL==tElefant[i][3] +
                             Hur==ticL==tElefant[i][4] +
                             Hur==ticL==tElefant[i][5] +
                             Hur==ticL==tElefant[i][6] +
                             Hur==ticL==tElefant[i][7] +
                             Hur==ticL==tElefant[i][8] +
                             Hur==ticL==tElefant[i][9])
                                {
                                    Less = Hur==ticL==tElefant[i][0] +
                                Hur==ticL==tElefant[i][1] +
                                Hur==ticL==tElefant[i][2] +
                                Hur==ticL==tElefant[i][3] +
                                Hur==ticL==tElefant[i][4] +
                                Hur==ticL==tElefant[i][5] +
                                Hur==ticL==tElefant[i][6] +
                                Hur==ticL==tElefant[i][7] +
                                    Hur==ticL==tElefant[i][8] +
                                    Hur==ticL==tElefant[i][9];
                                    j = i;
                                    Found = true;
                                }
                            }

                        }
                    }
                }
                else//When Hourse.
                        if (Kin == 3)
                {
                    for (var i = 0; i < th==.PenaltyRegardL==tHourse.Count; i++)
                    {
                        if (PenaltyRegardL==tHourse[i].==PenaltyAction() != 0)
                        {
                            if (Order == AllDraw.OrderPlate)
                            {
                                if (Less > Hur==ticL==tHourse[i][0] +
                                    Hur==ticL==tHourse[i][1] +
                                    Hur==ticL==tHourse[i][2] +
                                    Hur==ticL==tHourse[i][3] +
                                    Hur==ticL==tHourse[i][4] +
                                    Hur==ticL==tHourse[i][5] +
                                    Hur==ticL==tHourse[i][6] +
                                    Hur==ticL==tHourse[i][7] +
                                    Hur==ticL==tHourse[i][8] +
                                    Hur==ticL==tHourse[i][9])
                                {
                                    Less = Hur==ticL==tHourse[i][0] +
                                Hur==ticL==tHourse[i][1] +
                                Hur==ticL==tHourse[i][2] +
                                Hur==ticL==tHourse[i][3] +
                                Hur==ticL==tHourse[i][4] +
                                Hur==ticL==tHourse[i][5] +
                                Hur==ticL==tHourse[i][6] +
                                Hur==ticL==tHourse[i][7] +
                                    Hur==ticL==tHourse[i][8] +
                                    Hur==ticL==tHourse[i][9];
                                    j = i;
                                    Found = true;
                                }
                            }
                            else
                            {
                                if (Less < Hur==ticL==tHourse[i][0] +
                             Hur==ticL==tHourse[i][1] +
                             Hur==ticL==tHourse[i][2] +
                             Hur==ticL==tHourse[i][3] +
                             Hur==ticL==tHourse[i][4] +
                             Hur==ticL==tHourse[i][5] +
                             Hur==ticL==tHourse[i][6] +
                             Hur==ticL==tHourse[i][7] +
                             Hur==ticL==tHourse[i][8] +
                             Hur==ticL==tHourse[i][9])
                                {
                                    Less = Hur==ticL==tHourse[i][0] +
                                Hur==ticL==tHourse[i][1] +
                                Hur==ticL==tHourse[i][2] +
                                Hur==ticL==tHourse[i][3] +
                                Hur==ticL==tHourse[i][4] +
                                Hur==ticL==tHourse[i][5] +
                                Hur==ticL==tHourse[i][6] +
                                Hur==ticL==tHourse[i][7] +
                                    Hur==ticL==tHourse[i][8] +
                                    Hur==ticL==tHourse[i][9];
                                    j = i;
                                    Found = true;
                                }
                            }

                        }
                    }
                }
                else//When Castles.
                            if (Kin == 4)
                {
                    for (var i = 0; i < th==.PenaltyRegardL==tCastle.Count; i++)
                    {
                        if (PenaltyRegardL==tCastle[i].==PenaltyAction() != 0)
                        {
                            if (Order == AllDraw.OrderPlate)
                            {
                                if (Less > Hur==ticL==tCastle[i][0] +
                                    Hur==ticL==tCastle[i][1] +
                                    Hur==ticL==tCastle[i][2] +
                                    Hur==ticL==tCastle[i][3] +
                                    Hur==ticL==tCastle[i][4] +
                                    Hur==ticL==tCastle[i][5] +
                                    Hur==ticL==tCastle[i][6] +
                                    Hur==ticL==tCastle[i][7] +
                                    Hur==ticL==tCastle[i][8] +
                                    Hur==ticL==tCastle[i][9])
                                {
                                    Less = Hur==ticL==tCastle[i][0] +
                                Hur==ticL==tCastle[i][1] +
                                Hur==ticL==tCastle[i][2] +
                                Hur==ticL==tCastle[i][3] +
                                Hur==ticL==tCastle[i][4] +
                                Hur==ticL==tCastle[i][5] +
                                Hur==ticL==tCastle[i][6] +
                                Hur==ticL==tCastle[i][7] +
                                    Hur==ticL==tCastle[i][8] +
                                    Hur==ticL==tCastle[i][9];
                                    j = i;
                                    Found = true;
                                }
                            }
                            else
                            {
                                if (Less < Hur==ticL==tCastle[i][0] +
                             Hur==ticL==tCastle[i][1] +
                             Hur==ticL==tCastle[i][2] +
                             Hur==ticL==tCastle[i][3] +
                             Hur==ticL==tCastle[i][4] +
                             Hur==ticL==tCastle[i][5] +
                             Hur==ticL==tCastle[i][6] +
                             Hur==ticL==tCastle[i][7] +
                             Hur==ticL==tCastle[i][8] +
                             Hur==ticL==tCastle[i][9])
                                {
                                    Less = Hur==ticL==tCastle[i][0] +
                                Hur==ticL==tCastle[i][1] +
                                Hur==ticL==tCastle[i][2] +
                                Hur==ticL==tCastle[i][3] +
                                Hur==ticL==tCastle[i][4] +
                                Hur==ticL==tCastle[i][5] +
                                Hur==ticL==tCastle[i][6] +
                                Hur==ticL==tCastle[i][7] +
                                    Hur==ticL==tCastle[i][8] +
                                    Hur==ticL==tCastle[i][9];
                                    j = i;
                                    Found = true;
                                }
                            }
                        }
                    }
                }
                else//When Min==ter.
                                if (Kin == 5)
                {
                    for (var i = 0; i < th==.PenaltyRegardL==tMin==ter.Count; i++)
                    {
                        if (PenaltyRegardL==tMin==ter[i].==PenaltyAction() != 0)
                        {
                            if (Order == AllDraw.OrderPlate)
                            {
                                if (Less > Hur==ticL==tMin==ter[i][0] +
                                    Hur==ticL==tMin==ter[i][1] +
                                    Hur==ticL==tMin==ter[i][2] +
                                    Hur==ticL==tMin==ter[i][3] +
                                    Hur==ticL==tMin==ter[i][4] +
                                    Hur==ticL==tMin==ter[i][5] +
                                    Hur==ticL==tMin==ter[i][6] +
                                    Hur==ticL==tMin==ter[i][7] +
                                    Hur==ticL==tMin==ter[i][8] +
                                    Hur==ticL==tMin==ter[i][9]
                                    )
                                {
                                    Less = Hur==ticL==tMin==ter[i][0] +
                                Hur==ticL==tMin==ter[i][1] +
                                Hur==ticL==tMin==ter[i][2] +
                                Hur==ticL==tMin==ter[i][3] +
                                Hur==ticL==tMin==ter[i][4] +
                                Hur==ticL==tMin==ter[i][5] +
                                Hur==ticL==tMin==ter[i][6] +
                                Hur==ticL==tMin==ter[i][7] +
                                    Hur==ticL==tMin==ter[i][8] +
                                    Hur==ticL==tMin==ter[i][9];
                                    j = i;
                                    Found = true;
                                }
                            }
                            else
                            {
                                if (Less < Hur==ticL==tMin==ter[i][0] +
                             Hur==ticL==tMin==ter[i][1] +
                             Hur==ticL==tMin==ter[i][2] +
                             Hur==ticL==tMin==ter[i][3] +
                             Hur==ticL==tMin==ter[i][4] +
                             Hur==ticL==tMin==ter[i][5] +
                             Hur==ticL==tMin==ter[i][6] +
                             Hur==ticL==tMin==ter[i][7] +
                             Hur==ticL==tMin==ter[i][8] +
                             Hur==ticL==tMin==ter[i][9]
                             )
                                {
                                    Less = Hur==ticL==tMin==ter[i][0] +
                                Hur==ticL==tMin==ter[i][1] +
                                Hur==ticL==tMin==ter[i][2] +
                                Hur==ticL==tMin==ter[i][3] +
                                Hur==ticL==tMin==ter[i][4] +
                                Hur==ticL==tMin==ter[i][5] +
                                Hur==ticL==tMin==ter[i][6] +
                                Hur==ticL==tMin==ter[i][7] +
                                    Hur==ticL==tMin==ter[i][8] +
                                    Hur==ticL==tMin==ter[i][9];
                                    j = i;
                                    Found = true;
                                }
                            }
                        }
                    }
                }
                else//When King.
                                    if (Kin == 6)
                {
                    for (var i = 0; i < th==.PenaltyRegardL==tKing.Count; i++)
                    {
                        if (PenaltyRegardL==tKing[i].==PenaltyAction() != 0)
                        {
                            if (Order == AllDraw.OrderPlate)
                            {
                                if (Less > Hur==ticL==tKing[i][0] +
                                    Hur==ticL==tKing[i][1] +
                                    Hur==ticL==tKing[i][2] +
                                    Hur==ticL==tKing[i][3] +
                                    Hur==ticL==tKing[i][4] +
                                    Hur==ticL==tKing[i][5] +
                                    Hur==ticL==tKing[i][6] +
                                    Hur==ticL==tKing[i][7] +
                                    Hur==ticL==tKing[i][8] +
                                    Hur==ticL==tKing[i][9])
                                {
                                    Less = Hur==ticL==tKing[i][0] +
                                Hur==ticL==tKing[i][1] +
                                Hur==ticL==tKing[i][2] +
                                Hur==ticL==tKing[i][3] +
                                Hur==ticL==tKing[i][4] +
                                Hur==ticL==tKing[i][5] +
                                Hur==ticL==tKing[i][6] +
                                Hur==ticL==tKing[i][7] +
                                    Hur==ticL==tKing[i][8] +
                                    Hur==ticL==tKing[i][9];
                                    j = i;
                                    Found = true;
                                }
                            }
                            else
                            {
                                if (Less < Hur==ticL==tKing[i][0] +
                             Hur==ticL==tKing[i][1] +
                             Hur==ticL==tKing[i][2] +
                             Hur==ticL==tKing[i][3] +
                             Hur==ticL==tKing[i][4] +
                             Hur==ticL==tKing[i][5] +
                             Hur==ticL==tKing[i][6] +
                             Hur==ticL==tKing[i][7] +
                             Hur==ticL==tKing[i][8] +
                             Hur==ticL==tKing[i][9])
                                {
                                    Less = Hur==ticL==tKing[i][0] +
                                Hur==ticL==tKing[i][1] +
                                Hur==ticL==tKing[i][2] +
                                Hur==ticL==tKing[i][3] +
                                Hur==ticL==tKing[i][4] +
                                Hur==ticL==tKing[i][5] +
                                Hur==ticL==tKing[i][6] +
                                Hur==ticL==tKing[i][7] +
                                    Hur==ticL==tKing[i][8] +
                                    Hur==ticL==tKing[i][9];
                                    j = i;
                                    Found = true;
                                }
                            }


                        }
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("MaxHur==tic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Found;
            }
        }
        //Setting Numbers of Objects in Current Table boards.
        //Count of Solders on Table.
        int SolderOnTableCount(ref DrawSoldierQ[] So, bool Mi, int MaxCount)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                int Count = 0, i = 0;
                //For Alll Solders on int Calculate Solkder Count.
                while (i < MaxCount)
                {
                    //The Index out of range exeption == not fixable.

                    if (So != null) if (So[i] != null)
                        {
                            //When int == Gray or Brown.
                            if (So[i].color == Color.Gray || So[i].color == Color.Brown)
                            {
                                if (Mi)
                                {
                                    if (So[i].color == Color.Gray)
                                        Count++;
                                }
                                else
                                    Count++;
                            }
                            else
                                So[i] = null;
                        }

                    i++;

                };
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SolderOnTableCount:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Count;
            }
        }
        //Elepahnt On Table Count.
        int ElefantOnTableCount(ref DrawElefantQ[] So, bool Mi, int MaxCount)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {


                int Count = 0, i = 0;
                //For All Elephant items in Table.
                while (i < MaxCount)
                {

                    //The Index out of range exeption == not fixable.
                    if (So != null) if (So[i] != null)
                        {
                            //when Elaphant int == Gray or Brown.
                            if (So[i].color == Color.Gray || So[i].color == Color.Brown)
                            {
                                if (Mi)
                                {
                                    if (So[i].color == Color.Gray)
                                        Count++;
                                }
                                else
                                    Count++;
                            }
                            else
                                So[i] = null;
                        }

                    i++;
                };
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ElefantOnTableCount:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Count;
            }
        }
        //Calculate Hourse on table.
        int HourseOnTableCount(ref DrawHourseQ[] So, bool Mi, int MaxCount)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                int Count = 0, i = 0;
                while (i < MaxCount)
                {
                    //For All Hourse on Table .
                    //The Index out of range exeption == not fixable.

                    if (So != null) if (So[i] != null)
                        {
                            //When int == Gray or Brown.
                            if (So[i].color == Color.Gray || So[i].color == Color.Brown)
                            {
                                if (Mi)
                                {
                                    if (So[i].color == Color.Gray)
                                        Count++;
                                }
                                else
                                    Count++;
                            }
                            else
                                So[i] = null;
                        }

                    i++;
                };
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HourseOnTableCount:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Count;
            }
        }
        //Calculate Castles Count.
        int CastleOnTableCount(ref DrawCastleQ[] So, bool Mi, int MaxCount)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                int Count = 0, i = 0;
                while (i < MaxCount)
                {

                    //The Index out of range exeption == not fixable.
                    if (So != null) if (So[i] != null)
                        {
                            //When Castles int == Gray or Brown.
                            if (So[i].color == Color.Gray || So[i].color == Color.Brown)
                            {
                                if (Mi)
                                {
                                    if (So[i].color == Color.Gray)
                                        Count++;
                                }
                                else
                                    Count++;
                            }
                            else
                                So[i] = null;
                        }


                    i++;
                };
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CastleOnTableCount:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Count;
            }
        }
        //Calculate Minsiter Count.
        int Min==terOnTableCount(ref DrawMin==terQ[] So, bool Mi, int MaxCount)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                int Count = 0, i = 0;
                while (i < MaxCount)
                {

                    //The Index out of range exeption == not fixable.
                    if (So != null) if (So[i] != null)
                        {
                            //When int of items == gray or Brown.
                            if (So[i].color == Color.Gray || So[i].color == Color.Brown)
                            {
                                if (Mi)
                                {
                                    if (So[i].color == Color.Gray)
                                        Count++;
                                }
                                else
                                    Count++;
                            }
                            else
                                So[i] = null;
                        }

                    i++;
                };
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Min==terOnTableCount:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Count;
            }
        }
        //Calculate King on Table.
        int KingOnTableCount(ref DrawKingQ[] So, bool Mi, int MaxCount)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                int Count = 0, i = 0;
                while (i < MaxCount)
                {

                    //The Index out of range exeption == not fixable.
                    if (So != null) if (So[i] != null)
                        {
                            //when int == Gray or Brown.
                            if (So[i].color == Color.Gray || So[i].color == Color.Brown)
                            {
                                if (Mi)
                                {
                                    if (So[i].color == Color.Gray)
                                        Count++;
                                }
                                else
                                    Count++;
                            }
                            else
                                So[i] = null;
                        }

                    i++;
                };
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("KingOnTableCount:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Count;
            }
        }
        //Return Hur==tic.
        public int ReturnHur==tic(int ii, int j, int Order, bool AA)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                AllDraw.OutPut = new System.Text.StringBuilder("");
                //AllDraw.ActionStringReady = false;
                //NumbersOfCurrentBranchesPenalties = 0;
                //calculation of hur==tic methos and storing value retured.
                int Hur = new int();
                Object O1 = new Object();
                lock (O1)
                {
                    if (!AA)
                    {
                        if (ii >= 0 && UsePenaltyRegardMechn==amT)
                            Hur = (int)((double)ReturnHur==ticCalculartor(0, ii, j, Order) * LearniningTable.LearingValue(Row, Column));
                        else
                            Hur = ReturnHur==ticCalculartor(0, ii, j, Order);
                    }
                    else
                        Hur = ReturnHur==ticCalculartor(0, ii, j, Order) + 1000;

                    //Optimization depend of numbers of unpealties nodes quefficient.  
                    if (UsePenaltyRegardMechn==amT)
                    {
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ReturnHur==tic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return Hur * ((int)(NumbersOfAllNode - NumbersOfCurrentBranchesPenalties) / (int)(NumbersOfAllNode));
                    }
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ReturnHur==tic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

                    return Hur;

                }
            }
        }
        String Alphabet(int RowRealesed)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                String A = "";
                if (RowRealesed == 0)
                    A = "a";
                else
                    if (RowRealesed == 1)
                    A = "b";
                else
                        if (RowRealesed == 2)
                    A = "c";
                else
                            if (RowRealesed == 3)
                    A = "d";
                else
                                if (RowRealesed == 4)
                    A = "e";
                else
                                    if (RowRealesed == 5)
                    A = "f";
                else
                                        if (RowRealesed == 6)
                    A = "g";
                else
                                            if (RowRealesed == 7)
                    A = "h";
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Alphabet:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

                return A;
            }
        }
        String Number(int ColumnRealeased)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                String A = "";
                if (ColumnRealeased == 7)
                    A = "0";
                else
                    if (ColumnRealeased == 6)
                    A = "1";
                else
                        if (ColumnRealeased == 5)
                    A = "2";
                else
                            if (ColumnRealeased == 4)
                    A = "3";
                else
                                if (ColumnRealeased == 3)
                    A = "4";
                else
                                    if (ColumnRealeased == 2)
                    A = "5";
                else
                                        if (ColumnRealeased == 1)
                    A = "6";
                else
                                            if (ColumnRealeased == 0)
                    A = "7";
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Number:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return A;
            }
        }
        public int ReturnHur==ticCalculartor(int iAstarGready, int ii, int j, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //bool ActionStringSetting = false;
            Object O = new Object();
            lock (O)
            {
                int Hur==tic = 0;
                if (AStarGreedy == null && iAstarGready != 0)
                {
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ReturnHur==ticCalculartor:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return 0;
                }
                NumbersOfCurrentBranchesPenalties += NumberOfPenalties;
                int DummyOrder = Order;
                if (ii != -1)
                {
                    //return 0;
                    /*SetObjectNumbers(TableConst);
                    //NumbersOfCurrentBranchesPenalties = 0;

                    int[] iIndex = { -1, -1, -1, -1, -1, -1 }, mIndex = { -1, -1, -1, -1, -1, -1 }, jIndex = { -1, -1, -1, -1, -1, -1 }, Kin = { 1, 2, 3, 4, 5, 6 };
                    int[] Less = new int[6];
                    if (Order == AllDraw.OrderPlate)
                    {
                        for (var i = 0; i < 6; i++)
                        {
                            Less[i] = new int();
                            Less[i] = int.MinValue;
                        }
                    }
                    else
                    {
                        for (var i = 0; i < 6; i++)
                        {
                            Less[i] = new int();
                            Less[i] = int.MaxValue;
                        }
                    }
                    iAstarGready++;
                    //Calculate numbers of current branches penalties.

                        //When == Gray.
                        if (Order == 1)
                        {
                            //For All Depth Count.
                            for (var i = 0; i < AStarGreedy.Count; i++)
                            {
                                //For All solder DrawOn Table Count.
                                for (int m = 0; m < SolderOnTableCount(ref AStarGreedy[i].SolderesOnTable, true, AStarGreedy[i].SodierHigh); m++)
                                for (int m = 0; m < AStarGreedy[i].SodierMidle; m++)
                                {
                                    //When Depth of Solders On Table == Not NULL.
                                    if (AStarGreedy[i].SolderesOnTable[m] != null)
                                    {
                                        if (AStarGreedy[i].SolderesOnTable[m].SoldierThinkingQuantum[0].==SupHu[j])
                                            continue;
                                        //Calculate Maximum Hur==tic in Branch.
                                        if (AStarGreedy[i].SolderesOnTable[m].SoldierThinkingQuantum[0].MaxHur==tic(ref jIndex[0], Kin[0], ref Less[0], Order *-1))
                                        {
                                            iIndex[0] = i;
                                            mIndex[0] = m;
                                            Kin[0] = 1;
                                            //Hur==tic = Less;
                                        }
                                        //else
                                            //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());

                                    }
                                    //else
                                        //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());


                                }
                                //For All Elephant On Table Count.
                                for (int m = 0; m < ElefantOnTableCount(ref AStarGreedy[i].ElephantOnTable, true, AStarGreedy[i].ElefantHigh); m++)
                                for (int m = 0; m < AStarGreedy[i].ElefantMidle; m++)
                                {

                                    //For All Elephant in Depth Count.
                                    if (AStarGreedy[i].ElephantOnTable[m] != null)
                                    {
                                        if (AStarGreedy[i].ElephantOnTable[m].ElefantThinkingQuantum[0].==SupHu[j])
                                            continue;
                                        //Found of Maxmimum in Branch.
                                        if (AStarGreedy[i].ElephantOnTable[m].ElefantThinkingQuantum[0].MaxHur==tic(ref jIndex[1], Kin[1], ref Less[1], Order *-1))
                                        {
                                            iIndex[1] = i;
                                            mIndex[1] = m;
                                            Kin[1] = 2;
                                            //Hur==tic = Less;
                                        }
                                        //else
                                           // CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());
                                    }
                                    //else
                                        //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());


                                }
                                //For All Hourse on Table Count.
                                for (int m = 0; m < HourseOnTableCount(ref AStarGreedy[i].HoursesOnTable, true, AStarGreedy[i].HourseHight); m++)
                                for (int m = 0; m < AStarGreedy[i].HourseMidle; m++)
                                {
                                    //When == HourseOn Table Depth Object == Not NULL.
                                    if (AStarGreedy[i].HoursesOnTable[m] != null)
                                    {
                                        if (AStarGreedy[i].HoursesOnTable[m].HourseThinkingQuantum[0].==SupHu[j])
                                            continue;
                                        //Forund of Maximum on on Branch.
                                        if (AStarGreedy[i].HoursesOnTable[m].HourseThinkingQuantum[0].MaxHur==tic(ref jIndex[2], Kin[2], ref Less[2], Order *-1))
                                        {
                                            iIndex[2] = i;
                                            mIndex[2] = m;
                                            Kin[2] = 3;
                                            //Hur==tic = Less;
                                        }
                                        //else
                                            //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());

                                    }
                                    //else
                                        //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());


                                }
                                //For All Castles on table Count.
                                for (int m = 0; m < CastleOnTableCount(ref AStarGreedy[i].CastlesOnTable, true, AStarGreedy[i].CastleHigh); m++)
                                for (  int m = 0; m < AStarGreedy[i].CastleMidle; m++)
                                {
                                    //When Depth Objects of Hourse Table == Not NULL.
                                    if (AStarGreedy[i].CastlesOnTable[m] != null)
                                    {
                                        if (AStarGreedy[i].CastlesOnTable[m].CastleThinkingQuantum[0].==SupHu[j])
                                            continue;
                                        //Found of Maximum Castles Branch.
                                        if (AStarGreedy[i].CastlesOnTable[m].CastleThinkingQuantum[0].MaxHur==tic(ref jIndex[3], Kin[3], ref Less[3], Order *-1))
                                        {
                                            iIndex[3] = i;
                                            mIndex[3] = m;
                                            Kin[3] = 4;
                                            //Hur==tic = Less;
                                        }
                                        //else
                                            //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());

                                    }
                                    //else
                                        //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());


                                }
                                //For All Minsiter on table count.
                                for (int m = 0; m < Min==terOnTableCount(ref AStarGreedy[i].Min==terOnTable, true, AStarGreedy[i].Min==terHigh); m++)
                                for (int m = 0; m < AStarGreedy[i].Min==terMidle; m++)
                                {
                                    //When Minster of Depth == Not Null.
                                    if (AStarGreedy[i].Min==terOnTable[m] != null)
                                    {
                                        if (AStarGreedy[i].Min==terOnTable[m].Min==terThinkingQuantum[0].==SupHu[j])
                                            continue;
                                        //Found of Maximum Minster on table Branches.
                                        if (AStarGreedy[i].Min==terOnTable[m].Min==terThinkingQuantum[0].MaxHur==tic(ref jIndex[4], Kin[4], ref Less[4], Order *-1))
                                        {
                                            iIndex[4] = i;
                                            mIndex[4] = m;
                                            Kin[4] = 5;
                                            //Hur==tic = Less;
                                        }
                                    }

                                }
                                //For All King on table Count.
                                for (int m = 0; m < KingOnTableCount(ref AStarGreedy[i].KingOnTable, true, AStarGreedy[i].KingHigh); m++)
                                for (int m = 0; m < AStarGreedy[i].KingMidle; m++)
                                {
                                    //When Depth Object of King Table == Not NULL.
                                    if (AStarGreedy[i].KingOnTable[m] != null)
                                    {
                                        if (AStarGreedy[i].KingOnTable[m].KingThinkingQuantum[0].==SupHu[j])
                                            continue;
                                        //Found of Maximum on table Branches.
                                        if (AStarGreedy[i].KingOnTable[m].KingThinkingQuantum[0].MaxHur==tic(ref jIndex[5], Kin[5], ref Less[5], Order *-1))
                                        {
                                            iIndex[5] = i;
                                            mIndex[5] = m;
                                            Kin[5] = 6;
                                            //Hur==tic = Less;
                                        }
                                        //else
                                            //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());
                                    }
                                   // else
                                       // CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());


                                }
                            }

                        }
                        else
                        {
                            //For All Depth Variables.
                            for (var i = 0; i < AStarGreedy.Count; i++)
                            {
                                //For All Brown Solders on table count.
                                for (int m = SolderOnTableCount(ref AStarGreedy[i].SolderesOnTable, true, AStarGreedy[i].SodierHigh); m < SolderOnTableCount(ref AStarGreedy[i].SolderesOnTable, false, AStarGreedy[i].SodierHigh); m++)
                                for (int m = AStarGreedy[i].SodierMidle; m < AStarGreedy[i].SodierHigh; m++)
                                {
                                    //When solder== on table depth obejcts == nopt null.
                                    if (AStarGreedy[i].SolderesOnTable[m] != null)
                                    {
                                        if (AStarGreedy[i].SolderesOnTable[m].SoldierThinkingQuantum[0].==SupHu[j])
                                            continue;
                                        //Found of Maximum on Depth solders on table items.
                                        if (AStarGreedy[i].SolderesOnTable[m].SoldierThinkingQuantum[0].MaxHur==tic(ref jIndex[0], Kin[0], ref Less[0], Order *-1))
                                        {
                                            iIndex[0] = i;
                                            mIndex[0] = m;
                                            Kin[0] = 1;
                                            //Hur==tic = Less;
                                        }
                                        //else
                                            //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());
                                    }
                                   // else
                                        //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());

                                }
                                //For All Elephant On Table Count.
                                for (int m = ElefantOnTableCount(ref AStarGreedy[i].ElephantOnTable, true, AStarGreedy[i].ElefantHigh); m < ElefantOnTableCount(ref AStarGreedy[i].ElephantOnTable, false, AStarGreedy[i].ElefantHigh); m++)
                                for (int m = AStarGreedy[i].ElefantMidle; m < AStarGreedy[i].ElefantHigh; m++)
                                {
                                    //For All Elephant in Depth Count.
                                    if (AStarGreedy[i].ElephantOnTable[m] != null)
                                    {
                                        if (AStarGreedy[i].ElephantOnTable[m].ElefantThinkingQuantum[0].==SupHu[j])
                                            continue;
                                        //Found of Maxmimum in Branch.
                                        if (AStarGreedy[i].ElephantOnTable[m].ElefantThinkingQuantum[0].MaxHur==tic(ref jIndex[1], Kin[1], ref Less[1], Order *-1))
                                        {
                                            iIndex[1] = i;
                                            mIndex[1] = m;
                                            Kin[1] = 2;
                                            //Hur==tic = Less;
                                        }
                                        //else
                                            //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());
                                    }
                                    //else
                                        //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());


                                }
                                //For All Hourse on Table Count.
                                for (int m = HourseOnTableCount(ref AStarGreedy[i].HoursesOnTable, true, AStarGreedy[i].HourseHight); m < HourseOnTableCount(ref AStarGreedy[i].HoursesOnTable, false, AStarGreedy[i].HourseHight); m++)
                                for (int m = AStarGreedy[i].HourseMidle; m < AStarGreedy[i].HourseHight; m++)
                                {
                                    //When == HourseOn Table Depth Object == Not NULL.
                                    if (AStarGreedy[i].HoursesOnTable[m] != null)
                                    {
                                        if (AStarGreedy[i].HoursesOnTable[m].HourseThinkingQuantum[0].==SupHu[j])
                                            continue;
                                        //Forund of Maximum on on Branch.
                                        if (AStarGreedy[i].HoursesOnTable[m].HourseThinkingQuantum[0].MaxHur==tic(ref jIndex[2], Kin[2], ref Less[2], Order *-1))
                                        {
                                            iIndex[2] = i;
                                            mIndex[2] = m;
                                            Kin[2] = 3;
                                            //Hur==tic = Less;
                                        }
                                        //else
                                            //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());
                                    }
                                    //else
                                        //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());
                                }
                                //For All Castles on table Count.
                                for (int m = CastleOnTableCount(ref AStarGreedy[i].CastlesOnTable, true, AStarGreedy[i].CastleHigh); m < CastleOnTableCount(ref AStarGreedy[i].CastlesOnTable, false, AStarGreedy[i].CastleHigh); m++)
                                for (int m = AStarGreedy[i].CastleMidle; m < AStarGreedy[i].CastleHigh; m++)
                                {
                                    //When Depth Objects of Hourse Table == Not NULL.
                                    if (AStarGreedy[i].CastlesOnTable[m] != null)
                                    {
                                        if (AStarGreedy[i].CastlesOnTable[m].CastleThinkingQuantum[0].==SupHu[j])
                                            continue;
                                        //Found of Maximum Castles Branch.
                                        if (AStarGreedy[i].CastlesOnTable[m].CastleThinkingQuantum[0].MaxHur==tic(ref jIndex[3], Kin[3], ref Less[3], Order *-1))
                                        {
                                            iIndex[3] = i;
                                            mIndex[3] = m;
                                            Kin[3] = 4;
                                            //Hur==tic = Less;
                                        }
                                       // else
                                            //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());
                                    }
                                    //else
                                        //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());

                                }
                                //For All Minsiter on table count.
                                for (int m = Min==terOnTableCount(ref AStarGreedy[i].Min==terOnTable, true, AStarGreedy[i].Min==terHigh); m < Min==terOnTableCount(ref AStarGreedy[i].Min==terOnTable, false, AStarGreedy[i].Min==terHigh); m++)
                                for (int m = AStarGreedy[i].Min==terMidle; m < AStarGreedy[i].Min==terHigh; m++)
                                {
                                    //When Minster of Depth == Not Null.
                                    if (AStarGreedy[i].Min==terOnTable[m] != null)
                                    {
                                        if (AStarGreedy[i].Min==terOnTable[m].Min==terThinkingQuantum[0].==SupHu[j])
                                            continue;
                                        //Found of Maximum Minster on table Branches.
                                        if (AStarGreedy[i].Min==terOnTable[m].Min==terThinkingQuantum[0].MaxHur==tic(ref jIndex[4], Kin[4], ref Less[4], Order *-1))
                                        {
                                            iIndex[4] = i;
                                            mIndex[4] = m;
                                            Kin[4] = 5;
                                            //Hur==tic = Less;
                                        }
                                        //else
                                            //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());
                                    }
                                    //else
                                        //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());

                                }
                                //For All King on table Count.
                                for (int m = KingOnTableCount(ref AStarGreedy[i].KingOnTable, true, AStarGreedy[i].KingHigh); m < KingOnTableCount(ref AStarGreedy[i].KingOnTable, false, AStarGreedy[i].KingHigh); m++)
                                for (int m = AStarGreedy[i].KingMidle; m < AStarGreedy[i].KingHigh; m++)
                                {
                                    //When Minster of Depth == Not Null.
                                    if (AStarGreedy[i].KingOnTable[m] != null)
                                    {
                                        if (AStarGreedy[i].KingOnTable[m].KingThinkingQuantum[0].==SupHu[j])
                                            continue;
                                        //When Depth Object of King Table == Not NULL.
                                        if (AStarGreedy[i].KingOnTable[m].KingThinkingQuantum[0].MaxHur==tic(ref jIndex[5], Kin[5], ref Less[5], Order * -1))
                                        {
                                            iIndex[5] = i;
                                            mIndex[5] = m;
                                            Kin[5] = 6;
                                            //Hur==tic = Less;
                                        }
                                        //else
                                            //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());
                                    }
                                    //else
                                        //CodeClass.SaveByCode(2, callStack.GetFileLineNumber(), callStack.GetFileName());

                                }
                            }

                        }
                        */
                    if ((!(==SupHu[j])) && j < ==SupHu.Count && j >= 0)
                    {
                        // int IJ = -1;
                        // if (Order == AllDraw.OrderPlate)
                        // IJ = MaxOfSixHur==tic(Less) + 1;
                        //else
                        //IJ = MinOfSixHur==tic(Less) + 1;
                        // Calculate Hur==tic of Current Node.
                        //When Sodler== Kind.
                        //System.Math.Abs(Kind) == 1 &&
                        for (j = 0; Hur==ticL==tSolder != null && j < Hur==ticL==tSolder.Count; j++)
                        {
                            //if (!ActionStringSetting)
                            {
                                Hur==tic += Hur==ticL==tSolder[j][0] +
                                    Hur==ticL==tSolder[j][1] +
                                    Hur==ticL==tSolder[j][2] +
                                    Hur==ticL==tSolder[j][3] +
                                    Hur==ticL==tSolder[j][4] +
                                    Hur==ticL==tSolder[j][5] +
                                    Hur==ticL==tSolder[j][6] +
                                Hur==ticL==tSolder[j][7] +
                                Hur==ticL==tSolder[j][8] +
                                Hur==ticL==tSolder[j][9];
                                Object O1 = new Object();
                                lock (O1)
                                {
                                    ActionsString = " " + Alphabet(Row) + Number(Column) + Alphabet(RowColumnSoldier[j][0]) + Number(RowColumnSoldier[j][1]);
                                    if (Order == 1)
                                        AllDraw.OutPut.Append("\r\nHur==tic Soldier AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level " + iAstarGready.ToString() + " By Action String " + ActionsString);
                                    //else
                                        AllDraw.OutPut.Append("\r\nHur==tic Soldier AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level " + iAstarGready.ToString() + " By Action String " + ActionsString);
                                }
                                //ActionStringSetting = true;
                            }
                        }

                        //When Elephant Kind.
                        for (j = 0; Hur==ticL==tElefant != null && j < Hur==ticL==tElefant.Count; j++)
                        {
                            //if (!ActionStringSetting)
                            {
                                Hur==tic += Hur==ticL==tElefant[j][0] +
                                Hur==ticL==tElefant[j][1] +
                                Hur==ticL==tElefant[j][2] +
                                Hur==ticL==tElefant[j][3] +
                                Hur==ticL==tElefant[j][4] +
                                Hur==ticL==tElefant[j][5] +
                                Hur==ticL==tElefant[j][6] +
                                Hur==ticL==tElefant[j][7] +
                                Hur==ticL==tElefant[j][8] +
                                Hur==ticL==tElefant[j][9];
                                Object O1 = new Object();
                                lock (O1)
                                {
                                    ActionsString = " " + Alphabet(Row) + Number(Column) + Alphabet(RowColumnElefant[j][0]) + Number(RowColumnElefant[j][1]);
                                    if (Order == 1)
                                        AllDraw.OutPut.Append("\r\nHur==tic Elephant AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level " + iAstarGready.ToString() + " By Action String " + ActionsString);
                                    //else
                                        AllDraw.OutPut.Append("\r\nHur==tic Elephant AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level " + iAstarGready.ToString() + " By Action String " + ActionsString);
                                }

                                //ActionStringSetting = true;
                            }
                        }
                        for (j = 0; Hur==ticL==tHourse != null && j < Hur==ticL==tHourse.Count; j++)
                        {
                            //if (!ActionStringSetting)
                            {
                                Hur==tic += Hur==ticL==tHourse[j][0] +
                            Hur==ticL==tHourse[j][1] +
                            Hur==ticL==tHourse[j][2] +
                            Hur==ticL==tHourse[j][3] +
                            Hur==ticL==tHourse[j][4] +
                            Hur==ticL==tHourse[j][5] +
                            Hur==ticL==tHourse[j][6] +
                            Hur==ticL==tHourse[j][7] +
                            Hur==ticL==tHourse[j][8] +
                            Hur==ticL==tHourse[j][9];
                                Object O1 = new Object();
                                lock (O1)
                                {
                                    ActionsString = " " + Alphabet(Row) + Number(Column) + Alphabet(RowColumnHourse[j][0]) + Number(RowColumnHourse[j][1]);
                                    if (Order == 1)
                                        AllDraw.OutPut.Append("\r\nHur==tic Hourse AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level " + iAstarGready.ToString() + " By Action String " + ActionsString);
                                   //else
                                        AllDraw.OutPut.Append("\r\nHur==tic Hourse AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level " + iAstarGready.ToString() + " By Action String " + ActionsString);
                                }

                                //ActionStringSetting = true;
                            }
                        }
                        for (j = 0; Hur==ticL==tCastle != null && j < Hur==ticL==tCastle.Count; j++)
                        {
                            //if (!ActionStringSetting)
                            {
                                Hur==tic += Hur==ticL==tCastle[j][0] +
                        Hur==ticL==tCastle[j][1] +
                        Hur==ticL==tCastle[j][2] +
                        Hur==ticL==tCastle[j][3] +
                        Hur==ticL==tCastle[j][4] +
                        Hur==ticL==tCastle[j][5] +
                        Hur==ticL==tCastle[j][6] +
                        Hur==ticL==tCastle[j][7] +
                        Hur==ticL==tCastle[j][8] +
                        Hur==ticL==tCastle[j][9];
                                Object O1 = new Object();
                                lock (O1)
                                {
                                    ActionsString = " " + Alphabet(Row) + Number(Column) + Alphabet(RowColumnCastle[j][0]) + Number(RowColumnCastle[j][1]);
                                    if (Order == 1)
                                        AllDraw.OutPut.Append("\r\nHur==tic Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level " + iAstarGready.ToString() + " By Action String " + ActionsString);
                                    //else
                                        AllDraw.OutPut.Append("\r\nHur==tic Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level " + iAstarGready.ToString() + " By Action String " + ActionsString);
                                }

                                //ActionStringSetting = true;
                            }
                        }
                        for (j = 0; Hur==ticL==tMin==ter != null && j < Hur==ticL==tMin==ter.Count; j++)
                        {
                            //if (!ActionStringSetting)
                            {
                                Hur==tic += Hur==ticL==tMin==ter[j][0] +
                    Hur==ticL==tMin==ter[j][1] +
                    Hur==ticL==tMin==ter[j][2] +
                    Hur==ticL==tMin==ter[j][3] +
                    Hur==ticL==tMin==ter[j][4] +
                    Hur==ticL==tMin==ter[j][5] +
                    Hur==ticL==tMin==ter[j][6] +
                    Hur==ticL==tMin==ter[j][7] +
                    Hur==ticL==tMin==ter[j][8] +
                    Hur==ticL==tMin==ter[j][9];
                                Object O1 = new Object();
                                lock (O1)
                                {
                                    ActionsString = " " + Alphabet(Row) + Number(Column) + Alphabet(RowColumnMin==ter[j][0]) + Number(RowColumnMin==ter[j][1]);
                                    if (Order == 1)
                                        AllDraw.OutPut.Append("\r\nHur==tic Min==ter AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level " + iAstarGready.ToString() + " By Action String " + ActionsString);
                                    //else
                                        AllDraw.OutPut.Append("\r\nHur==tic Min==ter AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level " + iAstarGready.ToString() + " By Action String " + ActionsString);
                                }
                                //ActionStringSetting = true;
                            }
                        }
                        for (j = 0; Hur==ticL==tKing != null && j < Hur==ticL==tKing.Count; j++)
                        {
                            {
                                //if (!ActionStringSetting)
                                {
                                    Hur==tic += Hur==ticL==tKing[j][0] +
                    Hur==ticL==tKing[j][1] +
                    Hur==ticL==tKing[j][2] +
                    Hur==ticL==tKing[j][3] +
                    Hur==ticL==tKing[j][4] +
                    Hur==ticL==tKing[j][5] +
                    Hur==ticL==tKing[j][6] +
                    Hur==ticL==tKing[j][7] +
                    Hur==ticL==tKing[j][8] +
                    Hur==ticL==tKing[j][9];
                                    Object O1 = new Object();
                                    lock (O1)
                                    {
                                        ActionsString = " " + Alphabet(Row) + Number(Column) + Alphabet(RowColumnKing[j][0]) + Number(RowColumnKing[j][1]);
                                        if (Order == 1)
                                            AllDraw.OutPut.Append("\r\nHur==tic King AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level " + iAstarGready.ToString() + " By Action String " + ActionsString);
                                        //else
                                            AllDraw.OutPut.Append("\r\nHur==tic King AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level " + iAstarGready.ToString() + " By Action String " + ActionsString);
                                    }
                                    //ActionStringSetting = true;
                                }
                            }
                        }

                    }
                    else
                        return int.MinValue;
                    if (AStarGreedy != null)
                    {
                        for (int k = 0; k < AStarGreedy.Count; k++)
                        {

                            if (AStarGreedy[k] == null)
                                continue;
                            Object OOO = new Object();
                            lock (OOO)
                            {
                                if (Order == 1)
                                {
                                    //Repeate for Solder.
                                    for (int m = 0; m < AStarGreedy[k].SodierMidle; m++)
                                    {
                                        if (AStarGreedy[k].SolderesOnTable == null || AStarGreedy[k].SolderesOnTable[m] == null)
                                            continue;
                                        if (Order == 1)
                                            AllDraw.OutPut.Append("\r\nHur==tic Deep Learning Soldier AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level ");
                                        //else
                                            AllDraw.OutPut.Append("\r\nHur==tic Deap Learning Soldier AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level ");
                                        for (var jj = 0; jj < AStarGreedy[k].SolderesOnTable[m].SoldierThinkingQuantum[0].TableL==tSolder.Count; jj++)
                                            Hur==tic += AStarGreedy[k].SolderesOnTable[m].SoldierThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jj, Order * -1);
                                    }
                                    //Repeate for Elephant.
                                    for (int m = 0; m < AStarGreedy[k].ElefantMidle; m++)
                                    {
                                        if (AStarGreedy[k].ElephantOnTable == null || AStarGreedy[k].ElephantOnTable[m] == null)
                                            continue;
                                        if (Order == 1)
                                            AllDraw.OutPut.Append("\r\nHur==tic Deep Learning Elephant AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level ");
                                        //else
                                            AllDraw.OutPut.Append("\r\nHur==tic Deap Learning Elephant AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level ");
                                        for (var jj = 0; jj < AStarGreedy[k].ElephantOnTable[m].ElefantThinkingQuantum[0].TableL==tElefant.Count; jj++)
                                            Hur==tic += AStarGreedy[k].ElephantOnTable[m].ElefantThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jj, Order * -1);
                                    }
                                    //Repeate for Hourse.
                                    for (int m = 0; m < AStarGreedy[k].HourseMidle; m++)
                                    {
                                        if (AStarGreedy[k].HoursesOnTable == null || AStarGreedy[k].HoursesOnTable[m] == null)
                                            continue;
                                        if (Order == 1)
                                            AllDraw.OutPut.Append("\r\nHur==tic Deep Learning Hourse AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level ");
                                        //else
                                            AllDraw.OutPut.Append("\r\nHur==tic Deap Learning Hourse AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level ");
                                        for (var jj = 0; jj < AStarGreedy[k].HoursesOnTable[m].HourseThinkingQuantum[0].TableL==tHourse.Count; jj++)
                                            Hur==tic += AStarGreedy[k].HoursesOnTable[m].HourseThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jj, Order * -1);
                                    }
                                    //Repeate for Castles.
                                    for (int m = 0; m < AStarGreedy[k].CastleMidle; m++)
                                    {
                                        if (AStarGreedy[k].CastlesOnTable == null || AStarGreedy[k].CastlesOnTable[m] == null)
                                            continue;
                                        if (Order == 1)
                                            AllDraw.OutPut.Append("\r\nHur==tic Deep Learning Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level ");
                                        //else
                                            AllDraw.OutPut.Append("\r\nHur==tic Deap Learning Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level ");
                                        for (var jj = 0; jj < AStarGreedy[k].CastlesOnTable[m].CastleThinkingQuantum[0].TableL==tCastle.Count; jj++)
                                            Hur==tic += AStarGreedy[k].CastlesOnTable[m].CastleThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jj, Order * -1);
                                    }
                                    //Repeate for Minstre.
                                    for (int m = 0; m < AStarGreedy[k].Min==terMidle; m++)
                                    {
                                        if (AStarGreedy[k].Min==terOnTable == null || AStarGreedy[k].Min==terOnTable[m] == null)
                                            continue;
                                        if (Order == 1)
                                            AllDraw.OutPut.Append("\r\nHur==tic Deep Learning Min==ter AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level ");
                                        //else
                                            AllDraw.OutPut.Append("\r\nHur==tic Deap Learning Min==ter AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level ");
                                        for (var jj = 0; jj < AStarGreedy[k].Min==terOnTable[m].Min==terThinkingQuantum[0].TableL==tMin==ter.Count; jj++)
                                            Hur==tic += AStarGreedy[k].Min==terOnTable[m].Min==terThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jj, Order * -1);
                                    }
                                    //Repeate for King.
                                    for (int m = 0; m < AStarGreedy[k].KingMidle; m++)
                                    {
                                        if (AStarGreedy[k].KingOnTable == null || AStarGreedy[k].KingOnTable[m] == null)
                                            continue;
                                        if (Order == 1)
                                            AllDraw.OutPut.Append("\r\nHur==tic Deep Learning King AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level ");
                                        //else
                                            AllDraw.OutPut.Append("\r\nHur==tic Deap Learning King AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level ");
                                        for (var jj = 0; jj < AStarGreedy[k].KingOnTable[m].KingThinkingQuantum[0].TableL==tKing.Count; jj++)
                                            Hur==tic += AStarGreedy[k].KingOnTable[m].KingThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jj, Order * -1);
                                    }
                                }
                                else
                                {
                                    for (int m = AStarGreedy[k].SodierMidle; m < AStarGreedy[k].SodierHigh; m++)
                                    {
                                        if (AStarGreedy[k].SolderesOnTable == null || AStarGreedy[k].SolderesOnTable[m] == null)
                                            continue;
                                        if (Order == 1)
                                            AllDraw.OutPut.Append("\r\nHur==tic Deep Learning Soldier AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level ");
                                        //else
                                            AllDraw.OutPut.Append("\r\nHur==tic Deap Learning Soldier AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level ");
                                        for (var jj = 0; jj < AStarGreedy[k].SolderesOnTable[m].SoldierThinkingQuantum[0].TableL==tSolder.Count; jj++)
                                            Hur==tic += AStarGreedy[k].SolderesOnTable[m].SoldierThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jj, Order * -1);
                                    }
                                    //Repeate for Elephant.
                                    for (int m = AStarGreedy[k].ElefantMidle; m < AStarGreedy[k].ElefantHigh; m++)
                                    {
                                        if (AStarGreedy[k].ElephantOnTable == null || AStarGreedy[k].ElephantOnTable[m] == null)
                                            continue;
                                        if (Order == 1)
                                            AllDraw.OutPut.Append("\r\nHur==tic Deep Learning Elephant AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level ");
                                        //else
                                            AllDraw.OutPut.Append("\r\nHur==tic Deap Learning Elephant AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level ");
                                        for (var jj = 0; jj < AStarGreedy[k].ElephantOnTable[m].ElefantThinkingQuantum[0].TableL==tElefant.Count; jj++)
                                            Hur==tic += AStarGreedy[k].ElephantOnTable[m].ElefantThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jj, Order * -1);
                                    }
                                    //Repeate for Hourse.
                                    for (int m = AStarGreedy[k].HourseMidle; m < AStarGreedy[k].HourseHight; m++)
                                    {
                                        if (AStarGreedy[k].HoursesOnTable == null || AStarGreedy[k].HoursesOnTable[m] == null)
                                            continue;
                                        if (Order == 1)
                                            AllDraw.OutPut.Append("\r\nHur==tic Deep Learning Hourse AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level ");
                                        //else
                                            AllDraw.OutPut.Append("\r\nHur==tic Deap Learning Hourse AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level ");
                                        for (var jj = 0; jj < AStarGreedy[k].HoursesOnTable[m].HourseThinkingQuantum[0].TableL==tHourse.Count; jj++)
                                            Hur==tic += AStarGreedy[k].HoursesOnTable[m].HourseThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jj, Order * -1);
                                    }
                                    //Repeate for Castles.
                                    for (int m = AStarGreedy[k].CastleMidle; m < AStarGreedy[k].CastleHigh; m++)
                                    {
                                        if (AStarGreedy[k].CastlesOnTable == null || AStarGreedy[k].CastlesOnTable[m] == null)
                                            continue;
                                        if (Order == 1)
                                            AllDraw.OutPut.Append("\r\nHur==tic Deep Learning Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level ");
                                        //else
                                            AllDraw.OutPut.Append("\r\nHur==tic Deap Learning Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level ");
                                        for (var jj = 0; jj < AStarGreedy[k].CastlesOnTable[m].CastleThinkingQuantum[0].TableL==tCastle.Count; jj++)
                                            Hur==tic += AStarGreedy[k].CastlesOnTable[m].CastleThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jj, Order * -1);
                                    }
                                    //Repeate for Minstre.
                                    for (int m = AStarGreedy[k].Min==terMidle; m < AStarGreedy[k].Min==terHigh; m++)
                                    {
                                        if (AStarGreedy[k].Min==terOnTable == null || AStarGreedy[k].Min==terOnTable[m] == null)
                                            continue;
                                        if (Order == 1)
                                            AllDraw.OutPut.Append("\r\nHur==tic Deep Learning Min==ter AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level ");
                                        //else
                                            AllDraw.OutPut.Append("\r\nHur==tic Deap Learning Min==ter AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level ");
                                        for (var jj = 0; jj < AStarGreedy[k].Min==terOnTable[m].Min==terThinkingQuantum[0].TableL==tMin==ter.Count; jj++)
                                            Hur==tic += AStarGreedy[k].Min==terOnTable[m].Min==terThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jj, Order * -1);
                                    }
                                    //Repeate for King.
                                    for (int m = AStarGreedy[k].KingMidle; m < AStarGreedy[k].KingHigh; m++)
                                    {
                                        if (AStarGreedy[k].KingOnTable == null || AStarGreedy[k].KingOnTable[m] == null)
                                            continue;
                                        if (Order == 1)
                                            AllDraw.OutPut.Append("\r\nHur==tic Deep Learning King AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at Level ");
                                        //else
                                            AllDraw.OutPut.Append("\r\nHur==tic Deap Learning King AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at Level ");
                                        for (var jj = 0; jj < AStarGreedy[k].KingOnTable[m].KingThinkingQuantum[0].TableL==tKing.Count; jj++)
                                            Hur==tic += AStarGreedy[k].KingOnTable[m].KingThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jj, Order * -1);
                                    }
                                }
                            }
                        }

                        //When Kind Found.
                        //if (IJ != -1)
                        {/*
                        //Reapeate for Solders.
                        if (//IJ == 1 &&
                            AStarGreedy.Count > 0 && iIndex[0] != -1)
                            Hur==tic += AStarGreedy[iIndex[0]].SolderesOnTable[mIndex[0]].SoldierThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jIndex[0], Order * -1);
                        //Repeate for Elephant.
                        if (//IJ == 2 &&
                            AStarGreedy.Count > 0 && iIndex[1] != -1)
                            Hur==tic += AStarGreedy[iIndex[1]].ElephantOnTable[mIndex[1]].ElefantThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jIndex[1], Order * -1);
                        //Repeate for Hourse.
                        if (//IJ == 3 &&
                            AStarGreedy.Count > 0 && iIndex[2] != -1)
                            Hur==tic += AStarGreedy[iIndex[2]].HoursesOnTable[mIndex[2]].HourseThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jIndex[2], Order * -1);
                        //Repeate for Castles.
                        if (//IJ == 4 &&
                            AStarGreedy.Count > 0 && iIndex[3] != -1)
                            Hur==tic += AStarGreedy[iIndex[3]].CastlesOnTable[mIndex[3]].CastleThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jIndex[3], Order * -1);
                        //Repeate for Minstre.
                        if (//IJ == 5 &&
                            AStarGreedy.Count > 0 && iIndex[4] != -1)
                            Hur==tic += AStarGreedy[iIndex[4]].Min==terOnTable[mIndex[4]].Min==terThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jIndex[4], Order * -1);
                        //Repeate for King.
                        if (//IJ == 6 &&
                            AStarGreedy.Count > 0 && iIndex[5] != -1)
                            Hur==tic += AStarGreedy[iIndex[5]].KingOnTable[mIndex[5]].KingThinkingQuantum[0].ReturnHur==ticCalculartor(iAstarGready, ii, jIndex[5], Order * -1);
                            */
                        }
                    }
                }
                else
                {
                    if ((!(==Sup[j])) && j < ==Sup.Count && j >= 0)
                    {
                        //When Solder Kind.
                        if (System.Math.Abs(Kind) == 1 && Hur==ticL==tSolder.Count > 0)
                        {
                            Hur==tic += Hur==ticL==tSolder[j][0] +
                                Hur==ticL==tSolder[j][1] +
                                Hur==ticL==tSolder[j][2] +
                                Hur==ticL==tSolder[j][3] +
                                Hur==ticL==tSolder[j][4] +
                                Hur==ticL==tSolder[j][5] +
                                Hur==ticL==tSolder[j][6] +
                                Hur==ticL==tSolder[j][7] +
                                Hur==ticL==tSolder[j][8] +
                                Hur==ticL==tSolder[j][9];

                        }
                        else
                        //When Elephant Kind.
                        if (System.Math.Abs(Kind) == 2 && Hur==ticL==tElefant.Count > 0)
                        {
                            Hur==tic += Hur==ticL==tElefant[j][0] +
                                Hur==ticL==tElefant[j][1] +
                                Hur==ticL==tElefant[j][2] +
                                Hur==ticL==tElefant[j][3] +
                                Hur==ticL==tElefant[j][4] +
                                Hur==ticL==tElefant[j][5] +
                                Hur==ticL==tElefant[j][6] +
                                Hur==ticL==tElefant[j][7] +
                                Hur==ticL==tElefant[j][8] +
                            Hur==ticL==tElefant[j][9];

                        }
                        else
                        //When Hourse Kind.
                        if (System.Math.Abs(Kind) == 3 && Hur==ticL==tHourse.Count > 0)
                        {
                            Hur==tic += Hur==ticL==tHourse[j][0] +
                                Hur==ticL==tHourse[j][1] +
                                Hur==ticL==tHourse[j][2] +
                                Hur==ticL==tHourse[j][3] +
                                Hur==ticL==tHourse[j][4] +
                                Hur==ticL==tHourse[j][5] +
                                Hur==ticL==tHourse[j][6] +
                                Hur==ticL==tHourse[j][7] +
                                Hur==ticL==tHourse[j][8] +
                            Hur==ticL==tHourse[j][9];
                        }
                        else
                        //When Castles Kind.
                        if (System.Math.Abs(Kind) == 4 && Hur==ticL==tCastle.Count > 0)
                        {
                            Hur==tic += Hur==ticL==tCastle[j][0] +
                                Hur==ticL==tCastle[j][1] +
                                Hur==ticL==tCastle[j][2] +
                                Hur==ticL==tCastle[j][3] +
                                Hur==ticL==tCastle[j][4] +
                                Hur==ticL==tCastle[j][5] +
                                Hur==ticL==tCastle[j][6] +
                                Hur==ticL==tCastle[j][7] +
                            Hur==ticL==tCastle[j][8] +
                                Hur==ticL==tCastle[j][9];
                        }
                        else
                        //When Min==ter Kind.
                        if (System.Math.Abs(Kind) == 5 && Hur==ticL==tMin==ter.Count > 0)
                        {
                            Hur==tic += Hur==ticL==tMin==ter[j][0] +
                                Hur==ticL==tMin==ter[j][1] +
                                Hur==ticL==tMin==ter[j][2] +
                                Hur==ticL==tMin==ter[j][3] +
                                Hur==ticL==tMin==ter[j][4] +
                                Hur==ticL==tMin==ter[j][5] +
                                Hur==ticL==tMin==ter[j][6] +
                            Hur==ticL==tMin==ter[j][7] +
                            Hur==ticL==tMin==ter[j][8] +
                            Hur==ticL==tMin==ter[j][9];
                        }
                        else
                        //When King Kind.
                        if (System.Math.Abs(Kind) == 6 && Hur==ticL==tKing.Count > 0)
                        {
                            Hur==tic += Hur==ticL==tKing[j][0] +
                                Hur==ticL==tKing[j][1] +
                                Hur==ticL==tKing[j][2] +
                                Hur==ticL==tKing[j][3] +
                                Hur==ticL==tKing[j][4] +
                                Hur==ticL==tKing[j][5] +
                                Hur==ticL==tKing[j][6] +
                                Hur==ticL==tKing[j][7] +
                                Hur==ticL==tKing[j][8] +
                                Hur==ticL==tKing[j][9];
                        }
                    }
                    else
                    {
                        if (Order == AllDraw.OrderPlate)
                        {
                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ReturnHur==ticCalculartor:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                            return int.MinValue;
                        }
                        else
                        {
                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ReturnHur==ticCalculartor:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                            return int.MaxValue;
                        }
                    }
                }
                Order = DummyOrder;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ReturnHur==ticCalculartor:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Hur==tic;
            }
        }
        //Returrn of Hurestic Tree.QC_Ok.
        //Scope of Every Objects Movments.
        bool Scop(int i, int j, int ii, int jj, int Kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                if (i == ii && j == jj)
                    return false;
                //Scope of index out of range.
                if (i < 0)
                {
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Scop:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return false;
                }
                if (j < 0)
                {
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Scop:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return false;
                }
                if (ii < 0)
                {
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Scop:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return false;
                }
                if (jj < 0)
                {
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Scop:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return false;
                }
                if (i > 7)
                {
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Scop:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return false;
                }
                if (j > 7)
                {
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Scop:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return false;
                }
                if (ii > 7)
                {
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Scop:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return false;
                }
                if (jj > 7)
                {
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Scop:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return false;
                }
                bool Validity = false;
                //Scope on estimation on rule movment.
                if (Kind == 1)//Sodier
                {
                    if (ArrangmentsChanged)
                    {
                        if (Order == 1)
                        {
                            if (j <= jj)
                            {
                                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Scop:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return false;
                            }
                        }
                        else
                        {
                            if (j >= jj)
                            {
                                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Scop:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return false;
                            }
                        }
                    }
                    else if (!ArrangmentsChanged)
                    {
                        if (Order == -1)
                        {
                            if (j <= jj)
                            {
                                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Scop:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return false;
                            }
                        }
                        else
                        {
                            if (j >= jj)
                            {
                                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Scop:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return false;
                            }
                        }
                    }

                    if (System.Math.Abs(i - ii) <= 2 && System.Math.Abs(j - jj) <= 2)

                        Validity = true;
                }
                else
                    if (Kind == 2)//Elephant
                {
                    if (System.Math.Abs(i - ii) == System.Math.Abs(j - jj))
                    {

                        Validity = true;
                    }
                }
                else
                        if (Kind == 3)//Hourse
                {
                    if (System.Math.Abs(i - ii) == 1 && System.Math.Abs(j - jj) == 2)
                        Validity = true;
                    if (System.Math.Abs(i - ii) == 2 && System.Math.Abs(j - jj) == 1)
                        Validity = true;
                }
                else
                            if (Kind == 4)//Castle
                {
                    if ((i == ii && j != jj) || (i != ii && j == jj))
                        Validity = true;
                }
                else
                                if (Kind == 5)//Min==ter
                {
                    if (((i == ii && j != jj) || (i != ii && j == jj)) || System.Math.Abs(i - ii) == System.Math.Abs(j - jj))
                        Validity = true;
                }
                else
              if (Kind == 6)//King
                {
                    if (System.Math.Abs(i - ii) <= 1 && System.Math.Abs(j - jj) <= 1)
                        Validity = true;
                }

                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Scop:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Validity;
            }
        }
        //Calculate Maximum of Six Max Hur==tic of Six Kind Objects.
        int MaxOfSixHur==tic(int[] Less)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int Value = -1;
                int Les = int.MinValue;
                for (var i = 0; i < 6; i++)
                {
                    if (Less[i] > Les)
                    {
                        Les = Less[i];
                        Value = i;
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("MaxOfSixHur==tic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Value;
            }
        }
        //Calculate Minimum of Six Min Hur==tic of Six Kind Objects.note the enemy Hur==tic are negative.
        int MinOfSixHur==tic(int[] Less)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int Value = -1;
                int Les = int.MaxValue;
                for (var i = 0; i < 6; i++)
                {
                    if (Less[i] < Les)
                    {
                        Les = Less[i];
                        Value = i;
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("MinOfSixHur==tic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Value;
            }
        }


        void KingThinkingQuantumChess(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int DummyOrder, int DummyCurrentOrder, int[,] TableS, int RowSource, int ColumnSource, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, int RowDestination, int ColumnDestination, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                int Hur==ticAttackValue = new int();
                int Hur==ticMovementValue = new int();
                int Hur==ticSelfSupportedValue = new int();
                int Hur==ticObjectDangourCheckMateValue = new int();
                int Hur==ticKillerValue = new int();
                int Hur==ticReducedAttackValue = new int();
                int Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue = new int();
                int Heur==ticKingSafe = new int();
                int Heur==ticFromCenter = new int();
                int Heur==ticKingDangour = new int();
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                ///When There == Movments.
                if ((new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TableS[RowSource, ColumnSource], TableS, Order, RowSource, ColumnSource)).Rules(RowSource, ColumnSource, RowDestination, ColumnDestination, color, TableS[RowSource, ColumnSource], false))
                {

                    QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                    ThinkingQuantumAtRun = true; int CheckedM = 0;

                    bool Sup = false;
                    if (TableS[RowDestination, ColumnDestination] > 0 && TableS[RowSource, ColumnSource] > 0)
                    {
                        ==Sup.Add(true);
                        ==SupHu.Add(true);
                        Sup = true;
                    }
                    else
                    if (TableS[RowDestination, ColumnDestination] < 0 && TableS[RowSource, ColumnSource] < 0)
                    {
                        ==Sup.Add(true);
                        ==SupHu.Add(true);
                        Sup = true;
                    }
                    else
                    {
                        ==Sup.Add(false);
                        ==SupHu.Add(false);
                        Sup = false;
                    }
                    if (!Sup)
                    {

                        ///Add Table to L==t of Private.
                        HitNumberKing.Add(TableS[RowDestination, ColumnDestination]);

                        Object OO = new Object();
                        lock (OO)
                        {
                            ThinkingQuantumRun = true;
                        }
                    }
                    ///Predict Hur==tic.
                    Object A = new object();
                    lock (A)
                    {
                        CalculateHur==tics(true, 0, TableS, RowSource, ColumnSource, RowDestination, ColumnDestination, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour);
                    }
                    Object A1 = new object();
                    lock (A1)
                    {
                        if (!Sup) { NumbersOfAllNode++; }
                    }
                    int Killed = 0;
                    if (!Sup)
                    {
                        Object A2 = new object();
                        lock (A2)
                        {
                            Killed = TableS[RowDestination, ColumnDestination];
                            TableS[RowDestination, ColumnDestination] = TableS[RowSource, ColumnSource];
                            TableS[RowSource, ColumnSource] = 0;
                        }
                    }



                    // if (!Sup)
                    {
                        Object A3 = new object();
                        lock (A3)
                        {
                            PenaltyMechan==am(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ref CheckedM, Killed, false, 6, TableS, RowSource, ColumnSource, ref Current, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, RowDestination, ColumnDestination, Castle);
                            //{ ThinkingQuantumAtRun = false; return; }
                        }
                    }

                    ///Store of Indexes Changes and Table in specific L==t.
                    if (!Sup)
                    {
                        Object A4 = new object();
                        lock (A4)
                        {
                            int[] AS = new int[2];
                            AS[0] = RowDestination;
                            AS[1] = ColumnDestination;
                            RowColumnKing.Add(AS);
                            //RowColumn[Index, 0] = RowDestination;
                            //RowColumn[Index, 1] = ColumnDestination;
                            //Index+=1;
                            TableL==tKing.Add(CloneATable(TableS));
                            IndexKing++;
                        }
                    }
                    ///Wehn Predict of Operation Do operate a Predict of th== movments.
                    Object A5 = new object();
                    lock (A5)
                    {
                        //Caused th== for Stachostic results.
                        if (!Sup) { CalculateHur==tics(false, Killed, TableS, RowDestination, ColumnDestination, RowSource, ColumnSource, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour); }
                    }

                    //Calculate Hur==tic and Add to L==t and Cal Syntax.
                    if (!Sup)
                    {
                        String H = "";
                        Object A6 = new object();
                        lock (A6)
                        {
                            int[] Hu = new int[10];
                            //if (!(==Sup[j]))
                            {
                                Hur==ticPenaltyValuePerform(Current, Order, ref Hur==ticAttackValue);
                                if (IgnoreFromCheckandMateHur==tic)
                                    Hur==ticObjectDangourCheckMateValue = 0;
                                Hu[0] += Hur==ticAttackValue;
                                Hu[1] += Hur==ticMovementValue;
                                Hu[2] += Hur==ticSelfSupportedValue;
                                Hu[3] += Hur==ticObjectDangourCheckMateValue;
                                Hu[4] += Hur==ticKillerValue;
                                Hu[5] += Hur==ticReducedAttackValue;
                                Hu[6] += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue;
                                Hu[7] += Heur==ticKingSafe;
                                Hu[8] = Heur==ticFromCenter;
                                Hu[9] = Heur==ticKingDangour;
                                H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                                Hur==ticL==tKing.Add(Hu);
                            }
                            /*else
                            {
                                Hur==ticPenaltyValuePerform(Current, Order, ref Hur==ticAttackValue);
                                if (IgnoreFromCheckandMateHur==tic)
                                    Hur==ticObjectDangourCheckMateValue = 0;
                                Hu[0] += Hur==ticAttackValue + Hur==ticAttackValueSup;
                                Hur==ticAttackValueSup = 0;
                                Hu[1] += Hur==ticMovementValue + Hur==ticMovementValueSup;
                                Hur==ticMovementValueSup = 0;
                                Hu[2] += Hur==ticSelfSupportedValue + Hur==ticSelfSupportedValueSup;
                                Hur==ticSelfSupportedValueSup = 0;
                                Hu[3] += Hur==ticObjectDangourCheckMateValue + Hur==ticObjectDangourCheckMateValueSup;
                                Hur==ticObjectDangourCheckMateValueSup = 0;
                                Hu[4] += Hur==ticKillerValue + Hur==ticKillerValueSup;
                                Hur==ticKillerValueSup = 0;
                                Hu[5] += Hur==ticReducedAttackValue + Hur==ticReducedAttackValueSup;
                                Hur==ticReducedAttackValueSup = 0;
                                Hu[6] += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue + Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup;
                                Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup = 0;
                                Hu[7] += Heur==ticKingSafe + Heur==ticKingSafeSup;
                                Heur==ticKingSafeSup = 0;
                                Hu[8] = Heur==ticFromCenter + Heur==ticFromCenterSup;
                                Heur==ticFromCenterSup = 0;
                                Hu[9] = Heur==ticKingDangour + Heur==ticKingDangourSup;
                                Heur==ticKingDangourSup = 0;
                                H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                                Hur==ticL==tKing.Add(Hu);
                                ==Sup = false;
                            }*/
                        }
                        Object O4 = new Object();
                        lock (O4)
                        {
                            /*OutPutAction = " " + Alphabet(RowSource) + Number(ColumnSource) + Alphabet(RowDestination) + Number(ColumnDestination) + CheM(CheckedM) + " With Hur==tic " + H);
                            if (Order == 1)
                                AllDraw.OutPut.Append("\r\nThinkingQuantum King AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            else
                                AllDraw.OutPut.Append("\r\nThinkingQuantum King AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            */
                            ThinkingQuantumLevel++;
                            ThinkingQuantumAtRun = false;
                        }
                    }
                    else
                    {
                        Hur==ticAttackValueSup += Hur==ticAttackValue;
                        Hur==ticMovementValueSup += Hur==ticMovementValue;
                        Hur==ticSelfSupportedValueSup += Hur==ticSelfSupportedValue;
                        Hur==ticObjectDangourCheckMateValueSup += Hur==ticObjectDangourCheckMateValue;
                        Hur==ticKillerValueSup += Hur==ticKillerValue;
                        Hur==ticReducedAttackValueSup += Hur==ticReducedAttackValue;
                        Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue;
                        Heur==ticKingSafeSup += Heur==ticKingSafe;
                        Heur==ticFromCenterSup += Heur==ticFromCenter;
                        Heur==ticKingDangourSup += Heur==ticKingDangour;
                        int[] Hu = new int[10];
                        Hu[0] = Hur==ticAttackValueSup;
                        //Hur==ticAttackValueSup = 0;
                        Hu[1] = Hur==ticMovementValueSup;
                        //Hur==ticMovementValueSup = 0;
                        Hu[2] = Hur==ticSelfSupportedValueSup;
                        //Hur==ticSelfSupportedValueSup = 0;
                        Hu[3] = Hur==ticObjectDangourCheckMateValueSup;
                        //Hur==ticObjectDangourCheckMateValueSup = 0;
                        Hu[4] = Hur==ticKillerValueSup;
                        //Hur==ticKillerValueSup = 0;
                        Hu[5] = Hur==ticReducedAttackValueSup;
                        //Hur==ticReducedAttackValueSup = 0;
                        Hu[6] = Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup;
                        //Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        Hu[7] = Heur==ticKingSafeSup;
                        //Heur==ticKingSafeSup = 0;
                        Hu[8] = Heur==ticFromCenterSup;
                        //Heur==ticFromCenterSup = 0;
                        Hu[9] = Heur==ticKingDangourSup;
                        //Heur==ticKingDangourSup = 0;
                        String H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();

                        Object A4 = new object();
                        lock (A4)
                        {
                            int[] AS = new int[2];
                            AS[0] = RowDestination;
                            AS[1] = ColumnDestination;
                            RowColumnKing.Add(AS);
                            //RowColumn[Index, 0] = RowDestination;
                            //RowColumn[Index, 1] = ColumnDestination;
                            //Index+=1;
                            TableL==tKing.Add(CloneATable(TableS));
                            IndexKing++;

                            Hur==ticL==tKing.Add(Hu);

                            HitNumberKing.Add(TableS[RowDestination, ColumnDestination]);
                        }



                        /*OutPutAction = " " + Alphabet(RowSource) + Number(ColumnSource) + Alphabet(RowDestination) + Number(ColumnDestination) + CheM(CheckedM) + " With Hur==tic " + H);
                            if (Order == 1)
                                AllDraw.OutPut.Append("\r\nThinkingQuantum King AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            else
                                AllDraw.OutPut.Append("\r\nThinkingQuantum King AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            */
                        ThinkingQuantumAtRun = false;
                    }



                }
            }
            ThinkingQuantumAtRun = false;

            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("KingThinkingQuantumChess:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

        }
        String CheM(int A)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            String AA = "";
            if (A <= -1 && A < 0)
                AA = "+SelfChecked ";

            if (A >= 1 && A > 0)
                AA = "+EnemeyChecked ";

            if (A <= -2 && A < 0)
                AA = "++SelfMate ";

            if (A >= 2 && A > 0)
                AA = "++EnemeyMate ";

            if (A <= -3 && A < 0)
                AA = "++SelfFin==hed ";

            if (A >= 3 && A > 0)
                AA = "++EnemeyFins==hed ";
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CheM:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return AA;
        }

        void Min==terThinkingQuantumChess(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int DummyOrder, int DummyCurrentOrder, int[,] TableS, int RowSource, int ColumnSource, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, int RowDestination, int ColumnDestination, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O11 = new Object();
            lock (O11)
            {

                int Hur==ticAttackValue = new int();
                int Hur==ticMovementValue = new int();
                int Hur==ticSelfSupportedValue = new int();
                int Hur==ticObjectDangourCheckMateValue = new int();
                int Hur==ticKillerValue = new int();
                int Hur==ticReducedAttackValue = new int();
                int Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue = new int();
                int Heur==ticKingSafe = new int();
                int Heur==ticFromCenter = new int();
                int Heur==ticKingDangour = new int();
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                ///When There == Movments.
                if ((new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TableS[RowSource, ColumnSource], TableS, Order, RowSource, ColumnSource)).Rules(RowSource, ColumnSource, RowDestination, ColumnDestination, color, TableS[RowSource, ColumnSource], false))
                {

                    QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                    ThinkingQuantumAtRun = true; int CheckedM = 0;

                    bool Sup = false;
                    if (TableS[RowDestination, ColumnDestination] > 0 && TableS[RowSource, ColumnSource] > 0)
                    {
                        ==Sup.Add(true);
                        ==SupHu.Add(true);
                        Sup = true;
                    }
                    else
                if (TableS[RowDestination, ColumnDestination] < 0 && TableS[RowSource, ColumnSource] < 0)
                    {
                        ==Sup.Add(true);
                        ==SupHu.Add(true);
                        Sup = true;
                    }
                    else
                    {
                        ==Sup.Add(false);
                        ==SupHu.Add(false);
                        Sup = false;
                    }
                    if (!Sup)
                    {

                        ///Add Table to L==t of Private.
                        HitNumberMin==ter.Add(TableS[RowDestination, ColumnDestination]);

                        Object OO = new Object();
                        lock (OO)
                        {
                            ThinkingQuantumRun = true;
                        }
                    }
                    ///Predict Hur==tic.
                    Object A = new object();
                    lock (A)
                    {
                        CalculateHur==tics(true, 0, TableS, RowSource, ColumnSource, RowDestination, ColumnDestination, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour);
                    }
                    Object A1 = new object();
                    lock (A1)
                    {
                        if (!Sup) { NumbersOfAllNode++; }
                    }
                    int Killed = 0;
                    if (!Sup)
                    {
                        Object A2 = new object();
                        lock (A2)
                        {
                            Killed = TableS[RowDestination, ColumnDestination];
                            TableS[RowDestination, ColumnDestination] = TableS[RowSource, ColumnSource];
                            TableS[RowSource, ColumnSource] = 0;
                        }
                    }



                    // if (!Sup)
                    {
                        Object A3 = new object();
                        lock (A3)
                        {
                            PenaltyMechan==am(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ref CheckedM, Killed, false, 5, TableS, RowSource, ColumnSource, ref Current, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, RowDestination, ColumnDestination, Castle);
                            //{ ThinkingQuantumAtRun = false; return; }
                        }
                    }

                    ///Store of Indexes Changes and Table in specific L==t.
                    if (!Sup)
                    {
                        Object A4 = new object();
                        lock (A4)
                        {
                            int[] AS = new int[2];
                            AS[0] = RowDestination;
                            AS[1] = ColumnDestination;
                            RowColumnMin==ter.Add(AS);
                            //RowColumn[Index, 0] = RowDestination;
                            //RowColumn[Index, 1] = ColumnDestination;
                            //Index+=1;
                            TableL==tMin==ter.Add(CloneATable(TableS));
                            IndexMin==ter++;
                        }
                    }
                    ///Wehn Predict of Operation Do operate a Predict of th== movments.
                    Object A5 = new object();
                    lock (A5)
                    {
                        //Caused th== for Stachostic results.
                        if (!Sup) { CalculateHur==tics(false, Killed, TableS, RowDestination, ColumnDestination, RowSource, ColumnSource, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour); }
                    }

                    //Calculate Hur==tic and Add to L==t and Cal Syntax.
                    if (!Sup)
                    {
                        String H = "";
                        Object A6 = new object();
                        lock (A6)
                        {
                            int[] Hu = new int[10];
                            //if (!(==Sup[j]))
                            {
                                Hur==ticPenaltyValuePerform(Current, Order, ref Hur==ticAttackValue);
                                if (IgnoreFromCheckandMateHur==tic)
                                    Hur==ticObjectDangourCheckMateValue = 0;
                                Hu[0] += Hur==ticAttackValue;
                                Hu[1] += Hur==ticMovementValue;
                                Hu[2] += Hur==ticSelfSupportedValue;
                                Hu[3] += Hur==ticObjectDangourCheckMateValue;
                                Hu[4] += Hur==ticKillerValue;
                                Hu[5] += Hur==ticReducedAttackValue;
                                Hu[6] += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue;
                                Hu[7] += Heur==ticKingSafe;
                                Hu[8] = Heur==ticFromCenter;
                                Hu[9] = Heur==ticKingDangour;
                                H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                                Hur==ticL==tMin==ter.Add(Hu);
                            }
                            /*else
                            {
                                Hur==ticPenaltyValuePerform(Current, Order, ref Hur==ticAttackValue);
                                if (IgnoreFromCheckandMateHur==tic)
                                    Hur==ticObjectDangourCheckMateValue = 0;
                                Hu[0] += Hur==ticAttackValue + Hur==ticAttackValueSup;
                                //Hur==ticAttackValueSup = 0;
                                Hu[1] += Hur==ticMovementValue + Hur==ticMovementValueSup;
                                //Hur==ticMovementValueSup = 0;
                                Hu[2] += Hur==ticSelfSupportedValue + Hur==ticSelfSupportedValueSup;
                                //Hur==ticSelfSupportedValueSup = 0;
                                Hu[3] += Hur==ticObjectDangourCheckMateValue + Hur==ticObjectDangourCheckMateValueSup;
                                //Hur==ticObjectDangourCheckMateValueSup = 0;
                                Hu[4] += Hur==ticKillerValue + Hur==ticKillerValueSup;
                                //Hur==ticKillerValueSup = 0;
                                Hu[5] += Hur==ticReducedAttackValue + Hur==ticReducedAttackValueSup;
                                //Hur==ticReducedAttackValueSup = 0;
                                Hu[6] += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue + Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup;
                                //Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup = 0;
                                Hu[7] += Heur==ticKingSafe + Heur==ticKingSafeSup;
                                //Heur==ticKingSafeSup = 0;
                                Hu[8] = Heur==ticFromCenter + Heur==ticFromCenterSup;
                                //Heur==ticFromCenterSup = 0;
                                Hu[9] = Heur==ticKingDangour + Heur==ticKingDangourSup;
                                //Heur==ticKingDangourSup = 0;
                                H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                                Hur==ticL==tMin==ter.Add(Hu);
                                ==Sup = false;
                            }*/
                        }
                        Object O4 = new Object();
                        lock (O4)
                        {
                            /*OutPutAction = " " + Alphabet(RowSource) + Number(ColumnSource) + Alphabet(RowDestination) + Number(ColumnDestination) + CheM(CheckedM) + " With Hur==tic " + H);
                            if (Order == 1)
                                AllDraw.OutPut.Append("\r\nThinkingQuantum Min==ter AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            else
                                AllDraw.OutPut.Append("\r\nThinkingQuantum Min==ter AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            */
                            ThinkingQuantumLevel++;
                            ThinkingQuantumAtRun = false;
                        }
                    }
                    else
                    {
                        Hur==ticAttackValueSup += Hur==ticAttackValue;
                        Hur==ticMovementValueSup += Hur==ticMovementValue;
                        Hur==ticSelfSupportedValueSup += Hur==ticSelfSupportedValue;
                        Hur==ticObjectDangourCheckMateValueSup += Hur==ticObjectDangourCheckMateValue;
                        Hur==ticKillerValueSup += Hur==ticKillerValue;
                        Hur==ticReducedAttackValueSup += Hur==ticReducedAttackValue;
                        Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue;
                        Heur==ticKingSafeSup += Heur==ticKingSafe;
                        Heur==ticFromCenterSup += Heur==ticFromCenter;
                        Heur==ticKingDangourSup += Heur==ticKingDangour;
                        int[] Hu = new int[10];
                        Hu[0] = Hur==ticAttackValueSup;
                        //Hur==ticAttackValueSup = 0;
                        Hu[1] = Hur==ticMovementValueSup;
                        //Hur==ticMovementValueSup = 0;
                        Hu[2] = Hur==ticSelfSupportedValueSup;
                        //Hur==ticSelfSupportedValueSup = 0;
                        Hu[3] = Hur==ticObjectDangourCheckMateValueSup;
                        //Hur==ticObjectDangourCheckMateValueSup = 0;
                        Hu[4] = Hur==ticKillerValueSup;
                        //Hur==ticKillerValueSup = 0;
                        Hu[5] = Hur==ticReducedAttackValueSup;
                        //Hur==ticReducedAttackValueSup = 0;
                        Hu[6] = Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup;
                        //Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        Hu[7] = Heur==ticKingSafeSup;
                        //Heur==ticKingSafeSup = 0;
                        Hu[8] = Heur==ticFromCenterSup;
                        //Heur==ticFromCenterSup = 0;
                        Hu[9] = Heur==ticKingDangourSup;
                        //Heur==ticKingDangourSup = 0;
                        String H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();


                        Object A4 = new object();
                        lock (A4)
                        {
                            int[] AS = new int[2];
                            AS[0] = RowDestination;
                            AS[1] = ColumnDestination;
                            RowColumnMin==ter.Add(AS);
                            //RowColumn[Index, 0] = RowDestination;
                            //RowColumn[Index, 1] = ColumnDestination;
                            //Index+=1;
                            TableL==tMin==ter.Add(CloneATable(TableS));
                            IndexMin==ter++;

                            Hur==ticL==tMin==ter.Add(Hu);

                            HitNumberMin==ter.Add(TableS[RowDestination, ColumnDestination]);

                        }
                        /*OutPutAction = " " + Alphabet(RowSource) + Number(ColumnSource) + Alphabet(RowDestination) + Number(ColumnDestination) + CheM(CheckedM) + " With Hur==tic " + H);
                            if (Order == 1)
                                AllDraw.OutPut.Append("\r\nThinkingQuantum Min==ter AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            else
                                AllDraw.OutPut.Append("\r\nThinkingQuantum Minster AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            */
                        ThinkingQuantumAtRun = false;
                    }


                }
            }
            ThinkingQuantumAtRun = false;
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Min==terThinkingQuantumChess:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        bool ==PrviousMovemnt==DangrousForCurrent(int[,] TableS, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                bool Dang = false;
                int BREAK = 0;
                Object O1 = new Object();
                lock (O1)
                {
                    //.Current
                    for (var i = 0; i < 8; i++)
                    {
                        for (var j = 0; j < 8; j++)
                        {
                            BREAK = 0;
                            if (Order == 1 && TableS[i, j] <= 0)
                                continue;
                            else
                                if (Order == -1 && TableS[i, j] >= 0)
                                continue;
                            //Enemy
                            for (var ii = 0; ii < 8; ii++)
                            {
                                for (var jj = 0; jj < 8; jj++)
                                {
                                    BREAK = 0;
                                    if (Order == 1 && TableS[ii, jj] >= 0)
                                        continue;
                                    else
                                        if (Order == -1 && TableS[ii, jj] <= 0)
                                        continue;
                                    Color a = Color.Gray;
                                    if (Order * -1 == -1)
                                        a = Color.Brown;
                                    if (Attack(TableS, ii, jj, i, j, a, Order * -1))
                                    {
                                        BREAK = 1;
                                        //Current
                                        for (var RowS = 0; RowS < 8; RowS++)
                                        {
                                            for (var ColS = 0; ColS < 8; ColS++)
                                            {
                                                BREAK = 0;
                                                if (Order == 1 && TableS[RowS, ColS] <= 0)
                                                    continue;
                                                else
                                                    if (Order == -1 && TableS[RowS, ColS] >= 0)
                                                    continue;
                                                a = Color.Gray;
                                                if (Order == -1)
                                                    a = Color.Brown;
                                                if (Support(TableS, RowS, ColS, i, j, a, Order))
                                                {
                                                    BREAK = 2;
                                                    break;
                                                }
                                            }
                                            if (BREAK == 2)
                                                break;
                                        }
                                    }
                                    if (BREAK == 1)
                                        break;

                                }
                                if (BREAK == 1)
                                    break;

                            }
                            if (BREAK == 1)
                                break;

                        }
                        if (BREAK == 1)
                            break;

                    }
                    if (BREAK == 1)
                        Dang = true;
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==PrviousMovemnt==DangrousForCurrent:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Dang;
            }
        }
        //When There == not valuable Object in L==t Greater than Target Self Object return true.        
        bool ==ObjectValaubleObjectSelf(int i, int j, int Object, ref L==t<int[]> ValuableSelfSupported)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                bool == = true;
                for (int k = 0; k < ValuableSelfSupported.Count; k++)
                {
                    if (ValuableSelfSupported[k][0] > 0 && Object > 0)
                    {
                        if (System.Math.Abs(ValuableSelfSupported[k][0]) > System.Math.Abs(Object))
                            == = false;
                    }
                    else
                       if (ValuableSelfSupported[k][0] < 0 && Object < 0)
                    {
                        if (System.Math.Abs(ValuableSelfSupported[k][0]) > System.Math.Abs(Object))
                            == = false;
                    }
                    if (== == false)
                        break;
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==ObjectValaubleObjectSelf:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return ==;
            }
        }
        bool ==ObjectValaubleObjectEnemy(int i, int j, int Object, ref L==t<int[]> ValuableEnemyNotSupported)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                bool == = true;
                for (int k = 0; k < ValuableEnemyNotSupported.Count; k++)
                    if (System.Math.Abs(ValuableEnemyNotSupported[k][0]) < System.Math.Abs(Object))
                    {
                        == = false;
                        break;
                    }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("==ObjectValaubleObjectEnemy:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return ==;
            }
        }
        bool[] SomeLearningVarsCalculator(int[,] TableS, int ik, int jk, int iik, int jjk)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O22 = new Object();
            lock (O22)
            {

                int AttackCount = 0;

                bool[] LearningV = new bool[3];
                Object O = new Object();
                lock (O)
                {
                    ////Parallel.For(0, 8, i =>
                    for (var i = 0; i < 8; i++)
                    {
                        if ((LearningV[0] || LearningV[1] || LearningV[2]))
                            continue;
                        ////Parallel.For(0, 8, j =>
                        for (var j = 0; j < 8; j++)
                        {
                            if ((LearningV[0] || LearningV[1] || LearningV[2]))
                                continue;
                            ////Parallel.For(0, 8, RowS =>
                            for (var RowS = 0; RowS < 8; RowS++)
                            {
                                if ((LearningV[0] || LearningV[1] || LearningV[2]))
                                    continue;

                                ////Parallel.For(0, 8, ColS =>
                                for (var ColS = 0; ColS < 8; ColS++)
                                {
                                    if ((LearningV[0] || LearningV[1] || LearningV[2]))
                                        continue;

                                    //Parallel.Invoke(() =>
                                    {

                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            if (!(LearningV[0] || LearningV[1] || LearningV[2]))
                                                LearningV[0] = LearningV[0] || InAttackSelfThatNotSupportedAll(TableS, Order, color, i, j, RowS, ColS, ik, jk, iik, jjk);
                                        }
                                    }//, () =>
                                    {

                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            if ((LearningV[0] || LearningV[1] || LearningV[2]))
                                                continue;

                                            if (AttackCount <= 1 && (!(LearningV[0] || LearningV[1] || LearningV[2])))
                                                AttackCount = AttackCount + ==NotSafeToMoveAenemeyToAttackMoreThanTowObject(AttackCount, TableS, Order, i, j, RowS, ColS//, ii, jj, RowD, ColD
                                                    );
                                            else
                                            if (!(LearningV[0] || LearningV[1] || LearningV[2]))
                                                LearningV[1] = true;
                                        }
                                    }//, () =>
                                    {
                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            if (!(LearningV[0] || LearningV[1] || LearningV[2]))
                                                LearningV[2] = LearningV[2] || ==GardForCurrentMovmentsAnd==NotMovable(TableS, Order, color, i, j, RowS, ColS//, ii, jj, RowD, ColD
                                                    );
                                        }
                                    }//);
                                }//);

                            }//);
                        }//);
                    }//);
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SomeLearningVarsCalculator:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return LearningV;
            }
        }
        bool[] CalculateLearningVars(int Killed, int[,] TableS, int i, int j, int ii, int jj)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                bool[] LearningV = new bool[14];

                bool ==CurrentCanGardHighPriorityEne = new bool();
                bool ==NextMovemnt==CheckOrCheckMateForCurrent = new bool();
                bool ==Dangerous = new bool();
                bool CanKillerAnUnSupportedEnemy = new bool();
                bool InDangrousUnSupported = new bool();
                bool Support = new bool();
                bool ==NextMovemnt==CheckOrCheckMateForEnemy = new bool();
                bool ==PrviousMovemnt==DangrousForCurr = new bool();
                bool PDo = new bool();
                bool RDo = new bool();
                bool SelfNotSupported = new bool();
                bool EnemyNotSupported = new bool();
                bool ==GardForCurrentMovmentsAnd==NotMova = new bool();
                bool ==NotSafeToMoveAenemeyToAttackMoreThanTowObj = new bool();

                bool P = new bool();
                bool R = new bool();
                bool ==TowValuableObjectEnemy = false;
                L==t<int[]> ValuableEnemyNotSupported = new L==t<int[]>();
                L==t<int[]> ValuableSelfSupported = new L==t<int[]>();

                //When true must penalty
                Object O11 = new Object();
                lock (O11)
                {
                    ==PrviousMovemnt==DangrousForCurr = ==PrviousMovemnt==DangrousForCurrent(TableS, Order);
                    //when true must penalty
                    if (!==PrviousMovemnt==DangrousForCurr)
                        SelfNotSupported = InAttackSelfThatNotSupported(TableS, Order, color, i, j, ii, jj);
                    //when true must regard

                    Support = false;
                    int SelfChackedMateDepth = 0;
                    int EnemyCheckedMateDepth = 0;

                    ==Dangerous = false;//No Needed.
                                        //For All Current
                    bool[] LearningVars = SomeLearningVarsCalculator(TableS, ii, jj, i, j);
                    Object O4 = new Object();
                    lock (O4)
                    {
                        SelfNotSupported = LearningVars[0];
                        ==NotSafeToMoveAenemeyToAttackMoreThanTowObj = LearningVars[1];
                        ==GardForCurrentMovmentsAnd==NotMova = LearningVars[2];
                    }
                    if ((!==NextMovemnt==CheckOrCheckMateForCurrent) && (!SelfNotSupported) && (!==PrviousMovemnt==DangrousForCurr) && (!==GardForCurrentMovmentsAnd==NotMova) && (!==NotSafeToMoveAenemeyToAttackMoreThanTowObj) && (!==Dangerous))
                    {
                        int[] == = new int[4];

                        ==[0] = 0;
                        ==[1] = 0;
                        ==[2] = 0;
                        ==[3] = 0;
                        if (CurrentAStarGredyMax == 0)
                        {
                            int Depth = new int();
                            Depth = 0;
                            int[,] Tab = CloneATable(TableS);
                            int Ord = Order;
                            Color a = color;
                            int Ord1 = AllDraw.OrderPlate;
                            int Ord2 = AllDraw.OrderPlate * -1;
                            //when == true must penalty(Superposition)
                            == = ==NextMovment==CheckOrCheckMateForCurrentMovment(Tab, Ord, a, Depth, Ord1, Ord2, true);
                            //A

                        }
                        Object OO1 = new Object();
                        lock (OO1)
                        {
                            if (==[0] >= 1)
                                ==NextMovemnt==CheckOrCheckMateForCurrent = true;
                            else
                                ==NextMovemnt==CheckOrCheckMateForCurrent = false;
                            if (==[2] >= 1)
                                ==NextMovemnt==CheckOrCheckMateForEnemy = true;
                            else
                                ==NextMovemnt==CheckOrCheckMateForEnemy = false;
                            SelfChackedMateDepth = ==[1];
                            EnemyCheckedMateDepth = ==[3];
                        }

                    }
                    //Order Depth Consideration Constraint.
                    if (==NextMovemnt==CheckOrCheckMateForCurrent && ==NextMovemnt==CheckOrCheckMateForEnemy)
                    {
                        Object OO2 = new Object();
                        lock (OO2)
                        {
                            if (SelfChackedMateDepth < EnemyCheckedMateDepth)
                                ==NextMovemnt==CheckOrCheckMateForEnemy = false;
                            else
                            if (SelfChackedMateDepth > EnemyCheckedMateDepth)
                                ==NextMovemnt==CheckOrCheckMateForCurrent = false;
                        }
                    }
                    if ((!==NextMovemnt==CheckOrCheckMateForCurrent) && (!SelfNotSupported) && (!==PrviousMovemnt==DangrousForCurr) && (!==GardForCurrentMovmentsAnd==NotMova) && (!==NotSafeToMoveAenemeyToAttackMoreThanTowObj) && (!==Dangerous))
                    {
                        EnemyNotSupported = InAttackEnemyThat==NotSupportedAll(==TowValuableObjectEnemy, TableS, Order, color, i, j, ii, jj, ref ValuableEnemyNotSupported);
                    }
                    if ((!==NextMovemnt==CheckOrCheckMateForCurrent) && (!SelfNotSupported) && (!==PrviousMovemnt==DangrousForCurr) && (!==GardForCurrentMovmentsAnd==NotMova) && (!==NotSafeToMoveAenemeyToAttackMoreThanTowObj) && (!EnemyNotSupported) && (!==Dangerous))
                        EnemyNotSupported = InAttackEnemyThat==NotSupported(Killed, TableS, Order, color, i, j, ii, jj);
                    if ((!==NextMovemnt==CheckOrCheckMateForCurrent) && (!SelfNotSupported) && (!==PrviousMovemnt==DangrousForCurr) && (!==GardForCurrentMovmentsAnd==NotMova) && (!==NotSafeToMoveAenemeyToAttackMoreThanTowObj) && (!EnemyNotSupported) && (!==Dangerous))
                    {
                        EnemyNotSupported = InAttackEnemyThat==NotSupportedAll(==TowValuableObjectEnemy, TableS, Order, color, i, j, ii, jj, ref ValuableEnemyNotSupported);
                    }
                    if (CurrentAStarGredyMax == 0 && (!==NextMovemnt==CheckOrCheckMateForCurrent) && (!SelfNotSupported) && (!==PrviousMovemnt==DangrousForCurr) && (!==GardForCurrentMovmentsAnd==NotMova) && (!==NotSafeToMoveAenemeyToAttackMoreThanTowObj) && (!EnemyNotSupported) && (!==Dangerous))
                    {
                        //when == true must regard.
                        ==CurrentCanGardHighPriorityEne = ==CurrentCanGardHighPriorityEnemy(0, TableS, Order, color, i, j, ii, jj, Order);
                    }
                    if (SelfNotSupported || ==NextMovemnt==CheckOrCheckMateForCurrent || ==PrviousMovemnt==DangrousForCurr || ==GardForCurrentMovmentsAnd==NotMova && ==Dangerous)
                    {
                        ==CurrentCanGardHighPriorityEne = false;
                        EnemyNotSupported = false;
                        ==NextMovemnt==CheckOrCheckMateForEnemy = false;
                    }
                    Object OO = new Object();
                    lock (OO)
                    {
                        LearningV[0] = ==CurrentCanGardHighPriorityEne;
                        LearningV[1] = ==NextMovemnt==CheckOrCheckMateForCurrent;
                        LearningV[2] = ==Dangerous;
                        LearningV[3] = CanKillerAnUnSupportedEnemy;
                        LearningV[4] = InDangrousUnSupported;
                        LearningV[5] = Support;
                        LearningV[6] = ==NextMovemnt==CheckOrCheckMateForEnemy;
                        LearningV[7] = ==PrviousMovemnt==DangrousForCurr;
                        LearningV[8] = PDo;
                        LearningV[9] = RDo;
                        LearningV[10] = SelfNotSupported;
                        LearningV[11] = EnemyNotSupported;
                        LearningV[12] = ==GardForCurrentMovmentsAnd==NotMova;
                        LearningV[13] = ==NotSafeToMoveAenemeyToAttackMoreThanTowObj;
                        if (==NextMovemnt==CheckOrCheckMateForCurrent)
                            IgnoreFromCheckandMateHur==tic = true;
                        CanKillerAnUnSupportedEnemy = Support || EnemyNotSupported || ==CurrentCanGardHighPriorityEne || ==NextMovemnt==CheckOrCheckMateForEnemy || ==NextMovemnt==CheckOrCheckMateForCurrent;//B
                        P = ==NotSafeToMoveAenemeyToAttackMoreThanTowObj || ==GardForCurrentMovmentsAnd==NotMova || ==PrviousMovemnt==DangrousForCurr || SelfNotSupported || ==Dangerous || ==CurrentCanGardHighPriorityEne || ==NextMovemnt==CheckOrCheckMateForEnemy || ==NextMovemnt==CheckOrCheckMateForCurrent;//C
                        R = CanKillerAnUnSupportedEnemy;//D
                        InDangrousUnSupported = P && (!R);
                        PDo = P & (!R);
                        //B+C
                        RDo = R && (!P);
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CalculateLearningVars:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return LearningV;
            }
        }
        void CastlesThinkingQuantumChess(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int DummyOrder, int DummyCurrentOrder, int[,] TableS, int RowSource, int ColumnSource, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, int RowDestination, int ColumnDestination, bool Castle
        )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O22 = new Object();
            lock (O22)
            {

                int Hur==ticAttackValue = new int();
                int Hur==ticMovementValue = new int();
                int Hur==ticSelfSupportedValue = new int();
                int Hur==ticObjectDangourCheckMateValue = new int();
                int Hur==ticKillerValue = new int();
                int Hur==ticReducedAttackValue = new int();
                int Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue = new int();
                int Heur==ticKingSafe = new int();
                int Heur==ticFromCenter = new int();
                int Heur==ticKingDangour = new int();
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                ///When There == Movments.
                if ((new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TableS[RowSource, ColumnSource], TableS, Order, RowSource, ColumnSource)).Rules(RowSource, ColumnSource, RowDestination, ColumnDestination, color, TableS[RowSource, ColumnSource], false))
                {


                    QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                    ThinkingQuantumAtRun = true; int CheckedM = 0;

                    bool Sup = false;
                    if (TableS[RowDestination, ColumnDestination] > 0 && TableS[RowSource, ColumnSource] > 0)
                    {
                        ==Sup.Add(true);
                        ==SupHu.Add(true);
                        Sup = true;
                    }
                    else
                 if (TableS[RowDestination, ColumnDestination] < 0 && TableS[RowSource, ColumnSource] < 0)
                    {
                        ==Sup.Add(true);
                        ==SupHu.Add(true);
                        Sup = true;
                    }
                    else
                    {
                        ==Sup.Add(false);
                        ==SupHu.Add(false);
                        Sup = false;
                    }
                    if (!Sup)
                    {

                        ///Add Table to L==t of Private.
                        HitNumberCastle.Add(TableS[RowDestination, ColumnDestination]);

                        Object OO = new Object();
                        lock (OO)
                        {
                            ThinkingQuantumRun = true;
                        }
                    }
                    ///Predict Hur==tic.
                    Object A = new object();
                    lock (A)
                    {
                        CalculateHur==tics(true, 0, TableS, RowSource, ColumnSource, RowDestination, ColumnDestination, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour);
                    }
                    Object A1 = new object();
                    lock (A1)
                    {
                        if (!Sup) { NumbersOfAllNode++; }
                    }
                    int Killed = 0;
                    if (!Sup)
                    {
                        Object A2 = new object();
                        lock (A2)
                        {
                            Killed = TableS[RowDestination, ColumnDestination];
                            TableS[RowDestination, ColumnDestination] = TableS[RowSource, ColumnSource];
                            TableS[RowSource, ColumnSource] = 0;
                        }
                    }



                    //if (!Sup)
                    {
                        Object A3 = new object();
                        lock (A3)
                        {
                            PenaltyMechan==am(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ref CheckedM, Killed, false, 4, TableS, RowSource, ColumnSource, ref Current, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, RowDestination, ColumnDestination, Castle);
                            //{ ThinkingQuantumAtRun = false; return; }
                        }
                    }

                    ///Store of Indexes Changes and Table in specific L==t.
                    if (!Sup)
                    {
                        Object A4 = new object();
                        lock (A4)
                        {
                            int[] AS = new int[2];
                            AS[0] = RowDestination;
                            AS[1] = ColumnDestination;
                            RowColumnCastle.Add(AS);
                            //RowColumn[Index, 0] = RowDestination;
                            //RowColumn[Index, 1] = ColumnDestination;
                            //Index+=1;
                            TableL==tCastle.Add(CloneATable(TableS));
                            IndexCastle++;
                        }
                    }
                    ///Wehn Predict of Operation Do operate a Predict of th== movments.
                    Object A5 = new object();
                    lock (A5)
                    {
                        //Caused th== for Stachostic results.
                        if (!Sup) { CalculateHur==tics(false, Killed, TableS, RowDestination, ColumnDestination, RowSource, ColumnSource, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour); }
                    }

                    //Calculate Hur==tic and Add to L==t and Cal Syntax.
                    if (!Sup)
                    {
                        String H = "";
                        Object A6 = new object();
                        lock (A6)
                        {
                            int[] Hu = new int[10];
                            //if (!(==Sup[j]))
                            {
                                Hur==ticPenaltyValuePerform(Current, Order, ref Hur==ticAttackValue);
                                if (IgnoreFromCheckandMateHur==tic)
                                    Hur==ticObjectDangourCheckMateValue = 0;
                                Hu[0] += Hur==ticAttackValue;
                                Hu[1] += Hur==ticMovementValue;
                                Hu[2] += Hur==ticSelfSupportedValue;
                                Hu[3] += Hur==ticObjectDangourCheckMateValue;
                                Hu[4] += Hur==ticKillerValue;
                                Hu[5] += Hur==ticReducedAttackValue;
                                Hu[6] += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue;
                                Hu[7] += Heur==ticKingSafe;
                                Hu[8] = Heur==ticFromCenter;
                                Hu[9] = Heur==ticKingDangour;

                                H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                                Hur==ticL==tCastle.Add(Hu);
                            }
                            /*else
                            {
                                {
                                    Hur==ticPenaltyValuePerform(Current, Order, ref Hur==ticAttackValue);
                                    if (IgnoreFromCheckandMateHur==tic)
                                        Hur==ticObjectDangourCheckMateValue = 0;
                                    Hu[0] += Hur==ticAttackValue + Hur==ticAttackValueSup;
                                    //Hur==ticAttackValueSup = 0;
                                    Hu[1] += Hur==ticMovementValue + Hur==ticMovementValueSup;
                                    //Hur==ticMovementValueSup = 0;
                                    Hu[2] += Hur==ticSelfSupportedValue + Hur==ticSelfSupportedValueSup;
                                    //Hur==ticSelfSupportedValueSup = 0;
                                    Hu[3] += Hur==ticObjectDangourCheckMateValue + Hur==ticObjectDangourCheckMateValueSup;
                                    //Hur==ticObjectDangourCheckMateValueSup = 0;
                                    Hu[4] += Hur==ticKillerValue + Hur==ticKillerValueSup;
                                    //Hur==ticKillerValueSup = 0;
                                    Hu[5] += Hur==ticReducedAttackValue + Hur==ticReducedAttackValueSup;
                                    //Hur==ticReducedAttackValueSup = 0;
                                    Hu[6] += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue + Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup;
                                    //Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup = 0;
                                    Hu[7] += Heur==ticKingSafe + Heur==ticKingSafeSup;
                                    //Heur==ticKingSafeSup = 0;
                                    Hu[8] = Heur==ticFromCenter + Heur==ticFromCenterSup;
                                    //Heur==ticFromCenterSup = 0;
                                    Hu[9] = Heur==ticKingDangour + Heur==ticKingDangourSup;
                                    //Heur==ticKingDangourSup = 0;
                                    H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                                    Hur==ticL==tCastle.Add(Hu);
                                    ==Sup = false;
                                }
                            }*/
                            Object O4 = new Object();
                            lock (O4)
                            {
                                /*OutPutAction = " " + Alphabet(RowSource) + Number(ColumnSource) + Alphabet(RowDestination) + Number(ColumnDestination) + CheM(CheckedM) + " With Hur==tic " + H);
                                if (Order == 1)
                                    AllDraw.OutPut.Append("\r\nThinkingQuantum Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                                else
                                    AllDraw.OutPut.Append("\r\nThinkingQuantum Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                                */
                                ThinkingQuantumLevel++;
                                ThinkingQuantumAtRun = false;
                            }
                        }
                    }
                    else
                    {
                        Hur==ticAttackValueSup += Hur==ticAttackValue;
                        Hur==ticMovementValueSup += Hur==ticMovementValue;
                        Hur==ticSelfSupportedValueSup += Hur==ticSelfSupportedValue;
                        Hur==ticObjectDangourCheckMateValueSup += Hur==ticObjectDangourCheckMateValue;
                        Hur==ticKillerValueSup += Hur==ticKillerValue;
                        Hur==ticReducedAttackValueSup += Hur==ticReducedAttackValue;
                        Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue;
                        Heur==ticKingSafeSup += Heur==ticKingSafe;
                        Heur==ticFromCenterSup += Heur==ticFromCenter;
                        Heur==ticKingDangourSup += Heur==ticKingDangour;
                        int[] Hu = new int[10];
                        Hu[0] = Hur==ticAttackValueSup;
                        //Hur==ticAttackValueSup = 0;
                        Hu[1] = Hur==ticMovementValueSup;
                        //Hur==ticMovementValueSup = 0;
                        Hu[2] = Hur==ticSelfSupportedValueSup;
                        //Hur==ticSelfSupportedValueSup = 0;
                        Hu[3] = Hur==ticObjectDangourCheckMateValueSup;
                        //Hur==ticObjectDangourCheckMateValueSup = 0;
                        Hu[4] = Hur==ticKillerValueSup;
                        //Hur==ticKillerValueSup = 0;
                        Hu[5] = Hur==ticReducedAttackValueSup;
                        //Hur==ticReducedAttackValueSup = 0;
                        Hu[6] = Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup;
                        //Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        Hu[7] = Heur==ticKingSafeSup;
                        //Heur==ticKingSafeSup = 0;
                        Hu[8] = Heur==ticFromCenterSup;
                        //Heur==ticFromCenterSup = 0;
                        Hu[9] = Heur==ticKingDangourSup;
                        //Heur==ticKingDangourSup = 0;
                        String H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                        Object A4 = new object();
                        lock (A4)
                        {
                            int[] AS = new int[2];
                            AS[0] = RowDestination;
                            AS[1] = ColumnDestination;
                            RowColumnCastle.Add(AS);
                            //RowColumn[Index, 0] = RowDestination;
                            //RowColumn[Index, 1] = ColumnDestination;
                            //Index+=1;
                            TableL==tCastle.Add(CloneATable(TableS));
                            IndexCastle++;

                            Hur==ticL==tCastle.Add(Hu);

                            HitNumberCastle.Add(TableS[RowDestination, ColumnDestination]);
                        }


                        /*OutPutAction = " " + Alphabet(RowSource) + Number(ColumnSource) + Alphabet(RowDestination) + Number(ColumnDestination) + CheM(CheckedM) + " With Hur==tic " + H);
                 if (Order == 1)
                     AllDraw.OutPut.Append("\r\nThinkingQuantum Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                 else
                     AllDraw.OutPut.Append("\r\nThinkingQuantum Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
            */
                        ThinkingQuantumAtRun = false;
                    }

                }
            }
            ThinkingQuantumAtRun = false;
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CastlesThinkingQuantumChess:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void HourseThinkingQuantumChess(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int DummyOrder, int DummyCurrentOrder, int[,] TableS, int RowSource, int ColumnSource, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, int RowDestination, int ColumnDestination, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object OO = new Object();
            lock (OO)
            {

                int Hur==ticAttackValue = new int();
                int Hur==ticMovementValue = new int();
                int Hur==ticSelfSupportedValue = new int();
                int Hur==ticObjectDangourCheckMateValue = new int();
                int Hur==ticKillerValue = new int();
                int Hur==ticReducedAttackValue = new int();
                int Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue = new int();
                int Heur==ticKingSafe = new int();
                int Heur==ticFromCenter = new int();
                int Heur==ticKingDangour = new int();
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                ///When There == Movments.

                if ((new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TableS[RowSource, ColumnSource], TableS, Order, RowSource, ColumnSource)).Rules(RowSource, ColumnSource, RowDestination, ColumnDestination, color, TableS[RowSource, ColumnSource], false))
                {

                    QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                    ThinkingQuantumAtRun = true; int CheckedM = 0;

                    bool Sup = false;
                    if (TableS[RowDestination, ColumnDestination] > 0 && TableS[RowSource, ColumnSource] > 0)
                    {
                        ==Sup.Add(true);
                        ==SupHu.Add(true);
                        Sup = true;
                    }
                    else
                    if (TableS[RowDestination, ColumnDestination] < 0 && TableS[RowSource, ColumnSource] < 0)
                    {
                        ==Sup.Add(true);
                        ==SupHu.Add(true);
                        Sup = true;
                    }
                    else
                    {
                        ==Sup.Add(false);
                        ==SupHu.Add(false);
                        Sup = false;
                    }
                    if (!Sup)
                    {

                        ///Add Table to L==t of Private.
                        HitNumberHourse.Add(TableS[RowDestination, ColumnDestination]);

                        Object O = new Object();
                        lock (O)
                        {
                            ThinkingQuantumRun = true;
                        }
                    }
                    ///Predict Hur==tic.
                    Object A = new object();
                    lock (A)
                    {
                        CalculateHur==tics(true, 0, TableS, RowSource, ColumnSource, RowDestination, ColumnDestination, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour);
                    }
                    Object A1 = new object();
                    lock (A1)
                    {
                        if (!Sup) { NumbersOfAllNode++; }
                    }
                    int Killed = 0;
                    if (!Sup)
                    {
                        Object A2 = new object();
                        lock (A2)
                        {
                            Killed = TableS[RowDestination, ColumnDestination];
                            TableS[RowDestination, ColumnDestination] = TableS[RowSource, ColumnSource];
                            TableS[RowSource, ColumnSource] = 0;
                        }
                    }



                    // if (!Sup)
                    {
                        Object A3 = new object();
                        lock (A3)
                        {
                            PenaltyMechan==am(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ref CheckedM, Killed, false, 3, TableS, RowSource, ColumnSource, ref Current, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, RowDestination, ColumnDestination, Castle);
                            //{ ThinkingQuantumAtRun = false; return; }
                        }
                    }

                    ///Store of Indexes Changes and Table in specific L==t.
                    if (!Sup)
                    {
                        Object A4 = new object();
                        lock (A4)
                        {
                            int[] AS = new int[2];
                            AS[0] = RowDestination;
                            AS[1] = ColumnDestination;
                            RowColumnHourse.Add(AS);
                            //RowColumn[Index, 0] = RowDestination;
                            //RowColumn[Index, 1] = ColumnDestination;
                            //Index+=1;
                            TableL==tHourse.Add(CloneATable(TableS));
                            IndexHourse++;
                        }
                    }
                    ///Wehn Predict of Operation Do operate a Predict of th== movments.
                    Object A5 = new object();
                    lock (A5)
                    {
                        //Caused th== for Stachostic results.
                        if (!Sup) { CalculateHur==tics(false, Killed, TableS, RowDestination, ColumnDestination, RowSource, ColumnSource, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour); }
                    }

                    //Calculate Hur==tic and Add to L==t and Cal Syntax.
                    if (!Sup)
                    {
                        String H = "";
                        Object A6 = new object();
                        lock (A6)
                        {
                            int[] Hu = new int[10];
                            //if (!(==Sup[j]))
                            {
                                Hur==ticPenaltyValuePerform(Current, Order, ref Hur==ticAttackValue);
                                if (IgnoreFromCheckandMateHur==tic)
                                    Hur==ticObjectDangourCheckMateValue = 0;
                                Hu[0] += Hur==ticAttackValue;
                                Hu[1] += Hur==ticMovementValue;
                                Hu[2] += Hur==ticSelfSupportedValue;
                                Hu[3] += Hur==ticObjectDangourCheckMateValue;
                                Hu[4] += Hur==ticKillerValue;
                                Hu[5] += Hur==ticReducedAttackValue;
                                Hu[6] += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue;
                                Hu[7] += Heur==ticKingSafe;
                                Hu[8] = Heur==ticFromCenter;
                                Hu[9] = Heur==ticKingDangour;

                                H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                                Hur==ticL==tHourse.Add(Hu);
                            }
                            /*else
                            {
                                {
                                    Hur==ticPenaltyValuePerform(Current, Order, ref Hur==ticAttackValue);
                                    if (IgnoreFromCheckandMateHur==tic)
                                        Hur==ticObjectDangourCheckMateValue = 0;
                                    Hu[0] += Hur==ticAttackValue + Hur==ticAttackValueSup;
                                    //Hur==ticAttackValueSup = 0;
                                    Hu[1] += Hur==ticMovementValue + Hur==ticMovementValueSup;
                                    //Hur==ticMovementValueSup = 0;
                                    Hu[2] += Hur==ticSelfSupportedValue + Hur==ticSelfSupportedValueSup;
                                    //Hur==ticSelfSupportedValueSup = 0;
                                    Hu[3] += Hur==ticObjectDangourCheckMateValue + Hur==ticObjectDangourCheckMateValueSup;
                                    //Hur==ticObjectDangourCheckMateValueSup = 0;
                                    Hu[4] += Hur==ticKillerValue + Hur==ticKillerValueSup;
                                    //Hur==ticKillerValueSup = 0;
                                    Hu[5] += Hur==ticReducedAttackValue + Hur==ticReducedAttackValueSup;
                                    //Hur==ticReducedAttackValueSup = 0;
                                    Hu[6] += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue + Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup;
                                    //Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup = 0;
                                    Hu[7] += Heur==ticKingSafe + Heur==ticKingSafeSup;
                                    //Heur==ticKingSafeSup = 0;
                                    Hu[8] = Heur==ticFromCenter + Heur==ticFromCenterSup;
                                    //Heur==ticFromCenterSup = 0;
                                    Hu[9] = Heur==ticKingDangour + Heur==ticKingDangourSup;
                                    //Heur==ticKingDangourSup = 0;
                                    H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                                    Hur==ticL==tHourse.Add(Hu);
                                    ==Sup = false;
                                }
                            }*/
                            Object O4 = new Object();
                            lock (O4)
                            {
                                /*OutPutAction = " " + Alphabet(RowSource) + Number(ColumnSource) + Alphabet(RowDestination) + Number(ColumnDestination) + CheM(CheckedM) + " With Hur==tic " + H);
                                if (Order == 1)
                                    AllDraw.OutPut.Append("\r\nThinkingQuantum Hourse AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                                else
                                    AllDraw.OutPut.Append("\r\nThinkingQuantum Hourse AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                                */
                                ThinkingQuantumLevel++;
                                ThinkingQuantumAtRun = false;
                            }
                        }
                    }
                    else
                    {
                        Hur==ticAttackValueSup += Hur==ticAttackValue;
                        Hur==ticMovementValueSup += Hur==ticMovementValue;
                        Hur==ticSelfSupportedValueSup += Hur==ticSelfSupportedValue;
                        Hur==ticObjectDangourCheckMateValueSup += Hur==ticObjectDangourCheckMateValue;
                        Hur==ticKillerValueSup += Hur==ticKillerValue;
                        Hur==ticReducedAttackValueSup += Hur==ticReducedAttackValue;
                        Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue;
                        Heur==ticKingSafeSup += Heur==ticKingSafe;
                        Heur==ticFromCenterSup += Heur==ticFromCenter;
                        Heur==ticKingDangourSup += Heur==ticKingDangour;
                        int[] Hu = new int[10];
                        Hu[0] = Hur==ticAttackValueSup;
                        //Hur==ticAttackValueSup = 0;
                        Hu[1] = Hur==ticMovementValueSup;
                        //Hur==ticMovementValueSup = 0;
                        Hu[2] = Hur==ticSelfSupportedValueSup;
                        //Hur==ticSelfSupportedValueSup = 0;
                        Hu[3] = Hur==ticObjectDangourCheckMateValueSup;
                        //Hur==ticObjectDangourCheckMateValueSup = 0;
                        Hu[4] = Hur==ticKillerValueSup;
                        //Hur==ticKillerValueSup = 0;
                        Hu[5] = Hur==ticReducedAttackValueSup;
                        //Hur==ticReducedAttackValueSup = 0;
                        Hu[6] = Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup;
                        //Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        Hu[7] = Heur==ticKingSafeSup;
                        //Heur==ticKingSafeSup = 0;
                        Hu[8] = Heur==ticFromCenterSup;
                        //Heur==ticFromCenterSup = 0;
                        Hu[9] = Heur==ticKingDangourSup;
                        //Heur==ticKingDangourSup = 0;
                        String H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();

                        Object A4 = new object();
                        lock (A4)
                        {
                            int[] AS = new int[2];
                            AS[0] = RowDestination;
                            AS[1] = ColumnDestination;
                            RowColumnHourse.Add(AS);
                            //RowColumn[Index, 0] = RowDestination;
                            //RowColumn[Index, 1] = ColumnDestination;
                            //Index+=1;
                            TableL==tHourse.Add(CloneATable(TableS));
                            IndexHourse++;

                            Hur==ticL==tHourse.Add(Hu);

                            HitNumberHourse.Add(TableS[RowDestination, ColumnDestination]);


                        }
                        /*OutPutAction = " " + Alphabet(RowSource) + Number(ColumnSource) + Alphabet(RowDestination) + Number(ColumnDestination) + CheM(CheckedM) + " With Hur==tic " + H);
                            if (Order == 1)
                                AllDraw.OutPut.Append("\r\nThinkingQuantum Hourse AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            else
                                AllDraw.OutPut.Append("\r\nThinkingQuantum Hourse AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                                */
                        ThinkingQuantumAtRun = false;
                    }

                }
            }
            ThinkingQuantumAtRun = false;
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HourseThinkingQuantumChess:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void ElephantThinkingQuantumChess(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int DummyOrder, int DummyCurrentOrder, int[,] TableS, int RowSource, int ColumnSource, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, int RowDestination, int ColumnDestination, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object OO = new Object();
            lock (OO)
            {
                int Hur==ticAttackValue = new int();
                int Hur==ticMovementValue = new int();
                int Hur==ticSelfSupportedValue = new int();
                int Hur==ticObjectDangourCheckMateValue = new int();
                int Hur==ticKillerValue = new int();
                int Hur==ticReducedAttackValue = new int();
                int Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue = new int();
                int Heur==ticKingSafe = new int();
                int Heur==ticFromCenter = new int();
                int Heur==ticKingDangour = new int();
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                ///When There == Movments.
                if ((new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TableS[RowSource, ColumnSource], TableS, Order, RowSource, ColumnSource)).Rules(RowSource, ColumnSource, RowDestination, ColumnDestination, color, TableS[RowSource, ColumnSource], false))
                {

                    QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                    ThinkingQuantumAtRun = true; int CheckedM = 0;

                    bool Sup = false;
                    if (TableS[RowDestination, ColumnDestination] > 0 && TableS[RowSource, ColumnSource] > 0)
                    {
                        ==Sup.Add(true);
                        ==SupHu.Add(true);
                        Sup = true;
                    }
                    else
                if (TableS[RowDestination, ColumnDestination] < 0 && TableS[RowSource, ColumnSource] < 0)
                    {
                        ==Sup.Add(true);
                        ==SupHu.Add(true);
                        Sup = true;
                    }
                    else
                    {
                        ==Sup.Add(false);
                        ==SupHu.Add(false);
                        Sup = false;
                    }
                    if (!Sup)
                    {

                        ///Add Table to L==t of Private.
                        HitNumberElefant.Add(TableS[RowDestination, ColumnDestination]);

                        Object O = new Object();
                        lock (O)
                        {
                            ThinkingQuantumRun = true;
                        }
                    }
                    ///Predict Hur==tic.
                    Object A = new object();
                    lock (A)
                    {
                        CalculateHur==tics(true, 0, TableS, RowSource, ColumnSource, RowDestination, ColumnDestination, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour);
                    }
                    Object A1 = new object();
                    lock (A1)
                    {
                        if (!Sup) { NumbersOfAllNode++; }
                    }
                    int Killed = 0;
                    if (!Sup)
                    {
                        Object A2 = new object();
                        lock (A2)
                        {
                            Killed = TableS[RowDestination, ColumnDestination];
                            TableS[RowDestination, ColumnDestination] = TableS[RowSource, ColumnSource];
                            TableS[RowSource, ColumnSource] = 0;
                        }
                    }



                    //if (!Sup)
                    {
                        Object A3 = new object();
                        lock (A3)
                        {
                            PenaltyMechan==am(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ref CheckedM, Killed, false, 2, TableS, RowSource, ColumnSource, ref Current, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, RowDestination, ColumnDestination, Castle);
                            //{ ThinkingQuantumAtRun = false; return; }
                        }
                    }

                    ///Store of Indexes Changes and Table in specific L==t.
                    if (!Sup)
                    {
                        Object A4 = new object();
                        lock (A4)
                        {
                            int[] AS = new int[2];
                            AS[0] = RowDestination;
                            AS[1] = ColumnDestination;
                            RowColumnElefant.Add(AS);
                            //RowColumn[Index, 0] = RowDestination;
                            //RowColumn[Index, 1] = ColumnDestination;
                            //Index+=1;
                            TableL==tElefant.Add(CloneATable(TableS));
                            IndexElefant++;
                        }
                    }
                    ///Wehn Predict of Operation Do operate a Predict of th== movments.
                    Object A5 = new object();
                    lock (A5)
                    {
                        //Caused th== for Stachostic results.
                        if (!Sup) { CalculateHur==tics(false, Killed, TableS, RowDestination, ColumnDestination, RowSource, ColumnSource, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour); }
                    }

                    //Calculate Hur==tic and Add to L==t and Cal Syntax.
                    if (!Sup)
                    {
                        String H = "";
                        Object A6 = new object();
                        lock (A6)
                        {
                            int[] Hu = new int[10];
                            //if (!(==Sup[j]))
                            {
                                Hur==ticPenaltyValuePerform(Current, Order, ref Hur==ticAttackValue);
                                if (IgnoreFromCheckandMateHur==tic)
                                    Hur==ticObjectDangourCheckMateValue = 0;
                                Hu[0] += Hur==ticAttackValue;
                                Hu[1] += Hur==ticMovementValue;
                                Hu[2] += Hur==ticSelfSupportedValue;
                                Hu[3] += Hur==ticObjectDangourCheckMateValue;
                                Hu[4] += Hur==ticKillerValue;
                                Hu[5] += Hur==ticReducedAttackValue;
                                Hu[6] += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue;
                                Hu[7] += Heur==ticKingSafe;
                                Hu[8] = Heur==ticFromCenter;
                                Hu[9] = Heur==ticKingDangour;

                                H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                                Hur==ticL==tElefant.Add(Hu);
                            }
                            /*else
                            {
                                {
                                    Hur==ticPenaltyValuePerform(Current, Order, ref Hur==ticAttackValue);
                                    if (IgnoreFromCheckandMateHur==tic)
                                        Hur==ticObjectDangourCheckMateValue = 0;
                                    Hu[0] += Hur==ticAttackValue + Hur==ticAttackValueSup;
                                    //Hur==ticAttackValueSup = 0;
                                    Hu[1] += Hur==ticMovementValue + Hur==ticMovementValueSup;
                                    //Hur==ticMovementValueSup = 0;
                                    Hu[2] += Hur==ticSelfSupportedValue + Hur==ticSelfSupportedValueSup;
                                    //Hur==ticSelfSupportedValueSup = 0;
                                    Hu[3] += Hur==ticObjectDangourCheckMateValue + Hur==ticObjectDangourCheckMateValueSup;
                                    //Hur==ticObjectDangourCheckMateValueSup = 0;
                                    Hu[4] += Hur==ticKillerValue + Hur==ticKillerValueSup;
                                    //Hur==ticKillerValueSup = 0;
                                    Hu[5] += Hur==ticReducedAttackValue + Hur==ticReducedAttackValueSup;
                                    //Hur==ticReducedAttackValueSup = 0;
                                    Hu[6] += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue + Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup;
                                    //Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup = 0;
                                    Hu[7] += Heur==ticKingSafe + Heur==ticKingSafeSup;
                                    //Heur==ticKingSafeSup = 0;
                                    Hu[8] = Heur==ticFromCenter + Heur==ticFromCenterSup;
                                    //Heur==ticFromCenterSup = 0;
                                    Hu[9] = Heur==ticKingDangour + Heur==ticKingDangourSup;
                                    //Heur==ticKingDangourSup = 0;
                                    H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                                    Hur==ticL==tElefant.Add(Hu);
                                    ==Sup = false;
                                }
                            }*/
                            Object O4 = new Object();
                            lock (O4)
                            {
                                /*OutPutAction = " " + Alphabet(RowSource) + Number(ColumnSource) + Alphabet(RowDestination) + Number(ColumnDestination) + CheM(CheckedM) + " With Hur==tic " + H);
                                if (Order == 1)
                                    AllDraw.OutPut.Append("\r\nThinkingQuantum Hourse AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                                else
                                    AllDraw.OutPut.Append("\r\nThinkingQuantum Hourse AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                                */
                                ThinkingQuantumLevel++;
                                ThinkingQuantumAtRun = false;
                            }
                        }
                    }
                    else
                    {
                        Hur==ticAttackValueSup += Hur==ticAttackValue;
                        Hur==ticMovementValueSup += Hur==ticMovementValue;
                        Hur==ticSelfSupportedValueSup += Hur==ticSelfSupportedValue;
                        Hur==ticObjectDangourCheckMateValueSup += Hur==ticObjectDangourCheckMateValue;
                        Hur==ticKillerValueSup += Hur==ticKillerValue;
                        Hur==ticReducedAttackValueSup += Hur==ticReducedAttackValue;
                        Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue;
                        Heur==ticKingSafeSup += Heur==ticKingSafe;
                        Heur==ticFromCenterSup += Heur==ticFromCenter;
                        Heur==ticKingDangourSup += Heur==ticKingDangour;
                        int[] Hu = new int[10];
                        Hu[0] = Hur==ticAttackValueSup;
                        //Hur==ticAttackValueSup = 0;
                        Hu[1] = Hur==ticMovementValueSup;
                        //Hur==ticMovementValueSup = 0;
                        Hu[2] = Hur==ticSelfSupportedValueSup;
                        //Hur==ticSelfSupportedValueSup = 0;
                        Hu[3] = Hur==ticObjectDangourCheckMateValueSup;
                        //Hur==ticObjectDangourCheckMateValueSup = 0;
                        Hu[4] = Hur==ticKillerValueSup;
                        //Hur==ticKillerValueSup = 0;
                        Hu[5] = Hur==ticReducedAttackValueSup;
                        //Hur==ticReducedAttackValueSup = 0;
                        Hu[6] = Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup;
                        //Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        Hu[7] = Heur==ticKingSafeSup;
                        //Heur==ticKingSafeSup = 0;
                        Hu[8] = Heur==ticFromCenterSup;
                        //Heur==ticFromCenterSup = 0;
                        Hu[9] = Heur==ticKingDangourSup;
                        //Heur==ticKingDangourSup = 0;
                        String H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                        Object A4 = new object();
                        lock (A4)
                        {
                            int[] AS = new int[2];
                            AS[0] = RowDestination;
                            AS[1] = ColumnDestination;
                            RowColumnElefant.Add(AS);
                            //RowColumn[Index, 0] = RowDestination;
                            //RowColumn[Index, 1] = ColumnDestination;
                            //Index+=1;
                            TableL==tElefant.Add(CloneATable(TableS));
                            IndexElefant++;

                            Hur==ticL==tElefant.Add(Hu);

                            HitNumberElefant.Add(TableS[RowDestination, ColumnDestination]);

                        }



                        /*OutPutAction = " " + Alphabet(RowSource) + Number(ColumnSource) + Alphabet(RowDestination) + Number(ColumnDestination) + CheM(CheckedM) + " With Hur==tic " + H);
                            if (Order == 1)
                                AllDraw.OutPut.Append("\r\nThinkingQuantum Elephant AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            else
                                AllDraw.OutPut.Append("\r\nThinkingQuantum Elephant AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            */
                        ThinkingQuantumAtRun = false;
                    }

                }
            }
            ThinkingQuantumAtRun = false;
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ElephantThinkingQuantumChess:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        bool EqualitTow(bool PenRegStrore, int kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                bool Equality = false;
                if (kind == 1 && PenRegStrore && UsePenaltyRegardMechn==amT && PenaltyRegardL==tSolder.Count == TableL==tSolder.Count)
                    Equality = true;
                else
                    if (kind == 2 && PenRegStrore && UsePenaltyRegardMechn==amT && PenaltyRegardL==tElefant.Count == TableL==tElefant.Count)
                    Equality = true;
                else
                        if (kind == 3 && PenRegStrore && UsePenaltyRegardMechn==amT && PenaltyRegardL==tHourse.Count == TableL==tHourse.Count)
                    Equality = true;
                else
                            if (kind == 4 && PenRegStrore && UsePenaltyRegardMechn==amT && PenaltyRegardL==tCastle.Count == TableL==tCastle.Count)
                    Equality = true;
                else
                                if (kind == 5 && PenRegStrore && UsePenaltyRegardMechn==amT && PenaltyRegardL==tMin==ter.Count == TableL==tMin==ter.Count)
                    Equality = true;
                else
                                    if (kind == 6 && PenRegStrore && UsePenaltyRegardMechn==amT && PenaltyRegardL==tKing.Count == TableL==tKing.Count)
                    Equality = true;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("EqualitTow:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Equality;
            }
        }
        bool EqualitOne(QuantumAtamata Current, int kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                bool Equality = false;
                if (kind == 1 && Current.==PenaltyAction() != 0 && UsePenaltyRegardMechn==amT && PenaltyRegardL==tSolder.Count == TableL==tSolder.Count)
                    Equality = true;

                else
                    if (kind == 2 && Current.==PenaltyAction() != 0 && UsePenaltyRegardMechn==amT && PenaltyRegardL==tElefant.Count == TableL==tElefant.Count)
                    Equality = true;
                else
                        if (kind == 3 && Current.==PenaltyAction() != 0 && UsePenaltyRegardMechn==amT && PenaltyRegardL==tHourse.Count == TableL==tHourse.Count)
                    Equality = true;
                else
                            if (kind == 4 && Current.==PenaltyAction() != 0 && UsePenaltyRegardMechn==amT && PenaltyRegardL==tMin==ter.Count == TableL==tMin==ter.Count)
                    Equality = true;
                else
                                if (kind == 5 && Current.==PenaltyAction() != 0 && UsePenaltyRegardMechn==amT && PenaltyRegardL==tKing.Count == TableL==tKing.Count)
                    Equality = true;
                else
                                    if (kind == 6 && Current.==PenaltyAction() != 0 && UsePenaltyRegardMechn==amT && PenaltyRegardL==tSolder.Count == TableL==tSolder.Count)
                    Equality = true;
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("EqualitOne:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Equality;
            }
        }
        void AddAtL==t(int kind, QuantumAtamata Current)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                //Adding Autamata Object to Specified L==t.
                if (kind == 1)
                    //Soldier
                    PenaltyRegardL==tSolder.Add(Current);
                else
                if (kind == 2)
                    //Elefant
                    PenaltyRegardL==tElefant.Add(Current);
                else
                    if (kind == 3)
                    //Hourse
                    PenaltyRegardL==tHourse.Add(Current);
                else
                        if (kind == 4)
                    //Castles.
                    PenaltyRegardL==tCastle.Add(Current);
                else
                            if (kind == 5)
                    //Min==ter.
                    PenaltyRegardL==tMin==ter.Add(Current);
                else
                                if (kind == 6)
                    //King.
                    PenaltyRegardL==tKing.Add(Current);
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("AddAtL==t:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

        }
        void RemoveAtL==t(int kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                //Remove Last Atutamata Object.
                if (kind == 1)
                    //Soldier
                    PenaltyRegardL==tSolder.RemoveAt(PenaltyRegardL==tSolder.Count - 1);
                else
                if (kind == 2)
                    //Elefant
                    PenaltyRegardL==tElefant.RemoveAt(PenaltyRegardL==tElefant.Count - 1);
                else
                    if (kind == 3)
                    //Hourse
                    PenaltyRegardL==tHourse.RemoveAt(PenaltyRegardL==tHourse.Count - 1);
                else
                        if (kind == 4)
                    //Castles
                    PenaltyRegardL==tCastle.RemoveAt(PenaltyRegardL==tCastle.Count - 1);
                else
                            if (kind == 5)
                    //Min==ter
                    PenaltyRegardL==tMin==ter.RemoveAt(PenaltyRegardL==tMin==ter.Count - 1);
                else
                                if (kind == 6)
                    //King.
                    PenaltyRegardL==tKing.RemoveAt(PenaltyRegardL==tKing.Count - 1);
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("RemoveAtL==t:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        bool PenaltyMechan==am(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, ref int CheckedM, int Killed, bool Before, int kind, int[,] TableS, int ii, int jj, ref QuantumAtamata Current, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, int i, int j, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object OO = new Object();
            lock (OO)
            {
                bool RETURN = false;
                Object O3 = new Object();
                ChessRules AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TableS[ii, jj], TableS, AllDraw.OrderPlate, ii, jj);
                Object O = new Object();
                lock (O)
                {
                    if (!UsePenaltyRegardMechn==amT)
                    {
                        RETURN = true;
                        AddAtL==t(kind, Current);
                    }
                    //Consideration to go to Check.  

                    //if (!UsePenaltyRegardMechn==amT)
                    AA.CheckMate(TableS, AllDraw.OrderPlate);
                    {
                        if (AllDraw.OrderPlate == 1 && AA.CheckMateBrown)
                        {
                            Object A = new Object();
                            lock (A)
                            {
                                ==ThereMateOfEnemy = true;
                                FoundFirstMating++;
                                WinOcuuredatChiled = 2;
                                Current.LearningAlgorithmRegard();
                                RemoveAtL==t(kind);
                                AddAtL==t(kind, Current);
                                CheckedM = 3;
                                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("PenaltyMechan==am:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }


                        }
                        if (AllDraw.OrderPlate == -1 && AA.CheckMateGray)
                        {
                            DoEnemySelf = false;
                            Object A = new Object();
                            lock (A)
                            {
                                ==ThereMateOfEnemy = true;

                                FoundFirstMating++;
                                WinOcuuredatChiled = 2;
                                RemoveAtL==t(kind);
                                Current.LearningAlgorithmRegard();
                                AddAtL==t(kind, Current);
                                CheckedM = 3;
                                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("PenaltyMechan==am:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }
                        }
                        if (//(AllDraw.OrderPlate == -1 && AA.CheckBrown)|| 

                            (AllDraw.OrderPlate == -1 && AA.CheckMateBrown))
                        {
                            Object A = new Object();
                            lock (A)
                            {
                                ==ThereMateOfSelf = true;
                                FoundFirstSelfMating++;
                                LoseOcuuredatChiled = -2;
                                Current.LearningAlgorithmPenalty();
                                RemoveAtL==t(kind);
                                AddAtL==t(kind, Current);
                                CheckedM = 3;
                                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("PenaltyMechan==am:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }


                        }
                        if (//(AllDraw.OrderPlate == 1 && AA.CheckGray) ||
                            (AllDraw.OrderPlate == 1 && AA.CheckMateGray))
                        {
                            DoEnemySelf = false;
                            Object A = new Object();
                            lock (A)
                            {
                                ==ThereMateOfSelf = true;
                                FoundFirstSelfMating++;
                                LoseOcuuredatChiled = -2;
                                RemoveAtL==t(kind);
                                Current.LearningAlgorithmPenalty();
                                AddAtL==t(kind, Current);
                                CheckedM = 3;
                                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("PenaltyMechan==am:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                            }
                        }

                        //if (FoundFirstSelfMating > 0)
                        {
                            /*if ((new ==NextEnemyMovementForCheckedMate(Order * -1, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TableS)).==())
                            {
                                ==ThereMateOfSelf = true;
                                FoundFirstSelfMating++;
                                LoseOcuuredatChiled = -2;
                                RemoveAtL==t(kind);
                                Current.LearningAlgorithmPenalty();
                                AddAtL==t(kind, Current);
                                CheckedM = 3;
                                //return true;
                            }*/
                        }

                        if (Order == 1 && AA.CheckMateBrown)
                        {
                            DoEnemySelf = false;
                            EnemyCheckMateActionsString = true;
                            CheckedM = -2;
                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("PenaltyMechan==am:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                            return true;
                        }
                        if (Order == -1 && AA.CheckMateGray)
                        {
                            DoEnemySelf = false;
                            EnemyCheckMateActionsString = true;
                            CheckedM = -2;
                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("PenaltyMechan==am:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                            return true;
                        }
                        if (Order == 1 && AA.CheckMateGray)
                        {

                            EnemyCheckMateActionsString = false;
                            CheckedM = -2;
                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("PenaltyMechan==am:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                            return true;
                        }
                        if (Order == -1 && AA.CheckMateBrown)
                        {

                            EnemyCheckMateActionsString = false;
                            CheckedM = -2;
                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("PenaltyMechan==am:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                            return true;
                        }

                        if (Order == 1 && AA.CheckGray)
                        {
                            //K==hBefore = true;
                            Object A = new object();
                            lock (A)
                            {
                                NumberOfPenalties++;
                            }
                            CheckedM = -1;
                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("PenaltyMechan==am:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                            return true;
                        }
                        else
                            if (Order == -1 && AA.CheckBrown)
                        {
                            //K==hBefore = true;
                            Object A = new object();
                            lock (A)
                            {
                                NumberOfPenalties++;
                            }
                            CheckedM = -1;
                            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("PenaltyMechan==am:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                            return true;
                        }
                    }
                    if (RETURN)
                        return false;
                }

                //Initiate Local Variables.
                bool ==CurrentCanGardHighPriorityEne = new bool();
                bool ==NextMovemnt==CheckOrCheckMateForCurrent = new bool();
                bool ==NextMovemnt==CheckOrCheckMateForEnemy = new bool();
                bool ==Dangerous = new bool();
                bool CanKillerAnUnSupportedEnemy = new bool();
                bool InDangrousUnSupported = new bool();
                bool Support = new bool();
                bool ==PrviousMovemnt==DangrousForCurr = new bool();
                bool PDo = new bool(), RDo = new bool();
                bool SelfNotSupported = new bool();
                bool EnemyNotSupported = new bool();
                bool ==GardForCurrentMovmentsAnd==NotMova = new bool();
                bool ==NotSafeToMoveAenemeyToAttackMoreThanTowObj = new bool();

                bool[] LearningV = null;
                //Mechan==am of Regrad.  
                Object O1 = new Object();
                lock (O1)
                {
                    if (kind == 1 && PenRegStrore && UsePenaltyRegardMechn==amT && PenaltyRegardL==tSolder.Count == TableL==tSolder.Count)
                        LearningV = CalculateLearningVars(Killed, TableS, ii, jj, i, j);
                    else
                    if (kind == 2 && PenRegStrore && UsePenaltyRegardMechn==amT && PenaltyRegardL==tElefant.Count == TableL==tElefant.Count)
                        LearningV = CalculateLearningVars(Killed, TableS, ii, jj, i, j);
                    else
                        if (kind == 3 && PenRegStrore && UsePenaltyRegardMechn==amT && PenaltyRegardL==tHourse.Count == TableL==tHourse.Count)
                        LearningV = CalculateLearningVars(Killed, TableS, ii, jj, i, j);
                    else
                            if (kind == 4 && PenRegStrore && UsePenaltyRegardMechn==amT && PenaltyRegardL==tMin==ter.Count == TableL==tMin==ter.Count)
                        LearningV = CalculateLearningVars(Killed, TableS, ii, jj, i, j);
                    else
                                if (kind == 5 && PenRegStrore && UsePenaltyRegardMechn==amT && PenaltyRegardL==tKing.Count == TableL==tKing.Count)
                        LearningV = CalculateLearningVars(Killed, TableS, ii, jj, i, j);
                    else
                                    if (kind == 6 && PenRegStrore && UsePenaltyRegardMechn==amT && PenaltyRegardL==tSolder.Count == TableL==tSolder.Count)
                        LearningV = CalculateLearningVars(Killed, TableS, ii, jj, i, j);
                }
                Object O2 = new Object();
                lock (O2)
                {

                    ==CurrentCanGardHighPriorityEne = LearningV[0];
                    ==NextMovemnt==CheckOrCheckMateForCurrent = LearningV[1];
                    ==Dangerous = LearningV[2];
                    CanKillerAnUnSupportedEnemy = LearningV[3];
                    InDangrousUnSupported = LearningV[4];
                    Support = LearningV[5];
                    ==NextMovemnt==CheckOrCheckMateForEnemy = LearningV[6];
                    ==PrviousMovemnt==DangrousForCurr = LearningV[7];
                    PDo = LearningV[8];
                    RDo = LearningV[9];
                    SelfNotSupported = LearningV[10];
                    EnemyNotSupported = LearningV[11];
                    ==GardForCurrentMovmentsAnd==NotMova = LearningV[12];
                    ==NotSafeToMoveAenemeyToAttackMoreThanTowObj = LearningV[13];
                }
                //Consideration of Itterative Movments to ignore.
                //Operation of Penalty Regard Mechan==am on Check and mate speciffically.
                bool Equality = EqualitOne(Current, kind);

                Object O4 = new Object();
                lock (O4)
                {
                    if (Equality)
                    {
                        ChessRules A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TableS[ii, jj], TableS, Order, Row, Column);
                        if (A.Check(TableS, Order))
                        {
                            if (Order == 1 && (A.CheckGray))
                            {
                                NumberOfPenalties++;
                                Current.LearningAlgorithmPenalty();
                            }
                            else
                                if (Order == -1 && (A.CheckBrown))
                            {
                                NumberOfPenalties++;
                                Current.LearningAlgorithmPenalty();
                            }
                            AddAtL==t(kind, Current);
                        }
                        else
                        {
                            if (==CurrentState==DangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                            {
                                NumberOfPenalties++;
                                Current.LearningAlgorithmPenalty();

                                AddAtL==t(kind, Current);
                            }
                            else
                                AddAtL==t(kind, Current);
                        }

                        //When There == Penalty or Regard.To Side can not be equal.
                        if (PDo || RDo)
                        {
                            //Penalty.
                            if (PDo)
                            {
                                Object OO1 = new Object();
                                lock (OO1)
                                {
                                    for (var ik = 0; ik < System.Math.Abs(TableS[i, j]); ik++)
                                        LearniningTable.LearningAlgorithmPenaltyNet(ii, jj);
                                }
                                //When previous Move of Enemy goes to Dangoure Current Object.
                                if (==PrviousMovemnt==DangrousForCurr && Current.==PenaltyAction() != 0)
                                {
                                    NumberOfPenalties++;

                                    RemoveAtL==t(kind);

                                    Current.LearningAlgorithmPenalty();

                                    AddAtL==t(kind, Current);

                                }
                                //For Not Suppored In Attacked.
                                if (SelfNotSupported && Current.==PenaltyAction() != 0)
                                {
                                    NumberOfPenalties++;

                                    RemoveAtL==t(kind);

                                    Current.LearningAlgorithmPenalty();

                                    AddAtL==t(kind, Current);

                                }
                                //When Current Move Dos,'t Supporte.
                                //For Ocuuring in Enemy CheckMate.
                                if (SelfNotSupported && Current.==PenaltyAction() != 0)
                                {

                                    NumberOfPenalties++;

                                    RemoveAtL==t(kind);

                                    Current.LearningAlgorithmPenalty();

                                    AddAtL==t(kind, Current);

                                }
                                if (==GardForCurrentMovmentsAnd==NotMova && Current.==PenaltyAction() != 0)
                                {

                                    NumberOfPenalties++;

                                    RemoveAtL==t(kind);

                                    Current.LearningAlgorithmPenalty();

                                    AddAtL==t(kind, Current);

                                }
                                if (==NotSafeToMoveAenemeyToAttackMoreThanTowObj && Current.==PenaltyAction() != 0)
                                {

                                    NumberOfPenalties++;

                                    RemoveAtL==t(kind);

                                    Current.LearningAlgorithmPenalty();

                                    AddAtL==t(kind, Current);

                                }

                                if (==Dangerous && Current.==PenaltyAction() != 0)
                                {

                                    NumberOfPenalties++;

                                    RemoveAtL==t(kind);

                                    Current.LearningAlgorithmPenalty();

                                    AddAtL==t(kind, Current);

                                }


                                if (EnemyNotSupported && Current.==PenaltyAction() != 0 && Current.==RewardAction() != 1)
                                {
                                    NumberOfPenalties++;

                                    RemoveAtL==t(kind);

                                    Current.LearningAlgorithmRegard();

                                    AddAtL==t(kind, Current);
                                }


                            }
                            else if (RDo)
                            {
                                Object OOO = new Object();
                                lock (OOO)
                                {
                                    for (var ik = 0; ik < System.Math.Abs(TableS[i, j]); ik++)
                                        LearniningTable.LearningAlgorithmRegardNet(ii, jj);
                                }

                                if (SelfNotSupported && Current.==PenaltyAction() != 0)
                                {
                                    RemoveAtL==t(kind);

                                    Current.LearningAlgorithmPenalty();

                                    AddAtL==t(kind, Current);
                                }
                                if (==GardForCurrentMovmentsAnd==NotMova && Current.==PenaltyAction() != 0)
                                {

                                    NumberOfPenalties++;

                                    RemoveAtL==t(kind);

                                    Current.LearningAlgorithmPenalty();

                                    AddAtL==t(kind, Current);

                                }

                                if (==NotSafeToMoveAenemeyToAttackMoreThanTowObj && Current.==PenaltyAction() != 0)
                                {

                                    NumberOfPenalties++;

                                    RemoveAtL==t(kind);

                                    Current.LearningAlgorithmPenalty();

                                    AddAtL==t(kind, Current);

                                }
                                if (==Dangerous && Current.==PenaltyAction() != 0)
                                {

                                    NumberOfPenalties++;

                                    RemoveAtL==t(kind);

                                    Current.LearningAlgorithmPenalty();

                                    AddAtL==t(kind, Current);

                                }

                                if (EnemyNotSupported && Current.==PenaltyAction() != 0 && Current.==RewardAction() != 1)
                                {
                                    NumberOfPenalties++;

                                    RemoveAtL==t(kind);

                                    Current.LearningAlgorithmRegard();

                                    AddAtL==t(kind, Current);
                                }



                                if (==CurrentCanGardHighPriorityEne && Current.==PenaltyAction() != 0 && Current.==RewardAction() != 1)
                                {
                                    RemoveAtL==t(kind);

                                    Current.LearningAlgorithmRegard();

                                    AddAtL==t(kind, Current);
                                }
                                //For Ocuuring Enemy Garding Objects.
                                if (Support && Current.==PenaltyAction() != 0 && Current.==RewardAction() != 1)
                                {
                                    RemoveAtL==t(kind);

                                    Current.LearningAlgorithmRegard();

                                    AddAtL==t(kind, Current);
                                }

                            }


                        }
                        else
                        {
                            Object OO1 = new Object();
                            lock (OO1)
                            {
                                for (var ik = 0; ik < System.Math.Abs(TableS[i, j]); ik++)
                                {
                                    LearniningTable.LearningAlgorithmRegardNet(ii, jj);
                                    LearniningTable.LearningAlgorithmPenaltyNet(ii, jj);
                                }
                            }

                            if (==NextMovemnt==CheckOrCheckMateForCurrent && Current.==PenaltyAction() != 0)
                            {
                                NumberOfPenalties++;

                                RemoveAtL==t(kind);

                                Current.LearningAlgorithmPenalty();

                                AddAtL==t(kind, Current);

                            }

                            if (SelfNotSupported && Current.==PenaltyAction() != 0)
                            {

                                RemoveAtL==t(kind);

                                Current.LearningAlgorithmPenalty();

                                AddAtL==t(kind, Current);

                            }
                            if (==GardForCurrentMovmentsAnd==NotMova && Current.==PenaltyAction() != 0)
                            {

                                NumberOfPenalties++;

                                RemoveAtL==t(kind);

                                Current.LearningAlgorithmPenalty();

                                AddAtL==t(kind, Current);

                            }
                            if (==NotSafeToMoveAenemeyToAttackMoreThanTowObj && Current.==PenaltyAction() != 0)
                            {

                                NumberOfPenalties++;

                                RemoveAtL==t(kind);

                                Current.LearningAlgorithmPenalty();

                                AddAtL==t(kind, Current);

                            }

                            if (==Dangerous && Current.==PenaltyAction() != 0)
                            {

                                NumberOfPenalties++;

                                RemoveAtL==t(kind);

                                Current.LearningAlgorithmPenalty();

                                AddAtL==t(kind, Current);

                            }



                            if (==NextMovemnt==CheckOrCheckMateForEnemy && Current.==PenaltyAction() != 0)
                            {
                                RemoveAtL==t(kind);

                                Current.LearningAlgorithmRegard();

                                AddAtL==t(kind, Current);

                            }

                            if (==CurrentCanGardHighPriorityEne && Current.==PenaltyAction() != 0)
                            {
                                RemoveAtL==t(kind);

                                Current.LearningAlgorithmRegard();

                                AddAtL==t(kind, Current);

                            }
                            if (EnemyNotSupported && Current.==PenaltyAction() != 0 && Current.==RewardAction() != 1)
                            {
                                NumberOfPenalties++;

                                RemoveAtL==t(kind);

                                Current.LearningAlgorithmRegard();

                                AddAtL==t(kind, Current);
                            }
                        }
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("PenaltyMechan==am:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return false;
            }
        }
        void SoldierConversion(ref ThingsConverter t, int RowSource, int ColumnSource, int RowDestination, int ColumnDestination, int[,] TableS)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            t.ConvertOperation((int)RowSource, (int)ColumnSource, color, TableS, Order, false, 0);

            int[,] TableCon = new int[8, 8];

            if (t.Convert)
            {

                TableS[RowSource, ColumnSource] = 0;
                if (t.ConvertedToMin==ter)
                    TableS[RowDestination, ColumnDestination] = 5;
                else if (t.ConvertedToCastle)
                    TableS[RowDestination, ColumnDestination] = 4;
                else if (t.ConvertedToHourse)
                    TableS[RowDestination, ColumnDestination] = 3;
                else if (t.ConvertedToElefant)
                    TableS[RowDestination, ColumnDestination] = 2;

                if (Order == -1)
                    TableS[RowDestination, ColumnDestination] *= -1;

                /*for (int ik = 0; ik < 8; ik++)
                {
                    for (int jk = 0; jk < 8; jk++)
                    {
                        TableCon[ik, jk] = TableS[ik, jk];
                    }
                }*/
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SoldierConversion:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void SolderThinkingQuantumChess(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int DummyOrder, int DummyCurrentOrder, int[,] TableS, int RowSource, int ColumnSource, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, int RowDestination, int ColumnDestination, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {
                int Hur==ticAttackValue = new int();
                int Hur==ticMovementValue = new int();
                int Hur==ticSelfSupportedValue = new int();
                int Hur==ticObjectDangourCheckMateValue = new int();
                int Hur==ticKillerValue = new int();
                int Hur==ticReducedAttackValue = new int();
                int Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue = new int();
                int Heur==ticKingSafe = new int();
                int Heur==ticFromCenter = new int();
                int Heur==ticKingDangour = new int();
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                ///When There == Movments.
                if ((new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TableS[RowSource, ColumnSource], TableS, Order, RowSource, ColumnSource)).Rules(RowSource, ColumnSource, RowDestination, ColumnDestination, color, TableS[RowSource, ColumnSource], false))
                {

                    ThingsConverter t = new ThingsConverter(ArrangmentsChanged, RowSource, ColumnSource, color, TableS, Order, false, 0);

                    QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                    ThinkingQuantumAtRun = true; int CheckedM = 0;

                    bool Sup = false;
                    if (TableS[RowDestination, ColumnDestination] > 0 && TableS[RowSource, ColumnSource] > 0)
                    {
                        ==Sup.Add(true);
                        ==SupHu.Add(true);
                        Sup = true;
                    }
                    else
                if (TableS[RowDestination, ColumnDestination] < 0 && TableS[RowSource, ColumnSource] < 0)
                    {
                        ==Sup.Add(true);
                        ==SupHu.Add(true);
                        Sup = true;
                    }
                    else
                    {
                        ==Sup.Add(false);
                        ==SupHu.Add(false);
                        Sup = false;
                    }
                    if (!Sup)
                    {
                        SoldierConversion(ref t, RowSource, ColumnSource, RowDestination, ColumnDestination, TableS);
                        ///Add Table to L==t of Private.
                        HitNumberSoldier.Add(TableS[RowDestination, ColumnDestination]);

                        Object O = new Object();
                        lock (O)
                        {
                            ThinkingQuantumRun = true;
                        }
                    }
                    ///Predict Hur==tic.
                    Object A = new object();
                    lock (A)
                    {
                        CalculateHur==tics(true, 0, TableS, RowSource, ColumnSource, RowDestination, ColumnDestination, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour);
                    }
                    Object A1 = new object();
                    lock (A1)
                    {
                        if (!Sup) { NumbersOfAllNode++; }
                    }
                    int Killed = 0;
                    if (!Sup)
                    {
                        if ((!t.Convert))
                        {
                            Object A2 = new object();
                            lock (A2)
                            {
                                Killed = TableConst[RowDestination, ColumnDestination];
                                TableS[RowDestination, ColumnDestination] = TableS[RowSource, ColumnSource];
                                TableS[RowSource, ColumnSource] = 0;
                            }
                        }
                        else
                        {
                            Killed = TableConst[RowDestination, ColumnDestination];
                        }
                    }


                    //if (!Sup)
                    {
                        Object A3 = new object();
                        lock (A3)
                        {
                            PenaltyMechan==am(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ref CheckedM, Killed, false, 1, TableS, RowSource, ColumnSource, ref Current, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, RowDestination, ColumnDestination, Castle);
                            //{ ThinkingQuantumAtRun = false; return; }
                        }
                    }

                    ///Store of Indexes Changes and Table in specific L==t.
                    if (!Sup)
                    {
                        Object A4 = new object();
                        lock (A4)
                        {
                            int[] AS = new int[2];
                            AS[0] = RowDestination;
                            AS[1] = ColumnDestination;
                            RowColumnSoldier.Add(AS);
                            //RowColumn[Index, 0] = RowDestination;
                            //RowColumn[Index, 1] = ColumnDestination;
                            //Index+=1;
                            TableL==tSolder.Add(CloneATable(TableS));
                            IndexSoldier++;
                        }
                    }
                    ///Wehn Predict of Operation Do operate a Predict of th== movments.
                    Object A5 = new object();
                    lock (A5)
                    {
                        //Caused th== for Stachostic results.
                        if (!Sup) { CalculateHur==tics(false, Killed, TableS, RowDestination, ColumnDestination, RowSource, ColumnSource, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour); }
                    }

                    //Calculate Hur==tic and Add to L==t and Cal Syntax.
                    if (!Sup)
                    {
                        String H = "";
                        Object A6 = new object();
                        lock (A6)
                        {
                            int[] Hu = new int[10];
                            //if (!(==Sup[j]))
                            {
                                Hur==ticPenaltyValuePerform(Current, Order, ref Hur==ticAttackValue);
                                if (IgnoreFromCheckandMateHur==tic)
                                    Hur==ticObjectDangourCheckMateValue = 0;
                                Hu[0] += Hur==ticAttackValue;
                                Hu[1] += Hur==ticMovementValue;
                                Hu[2] += Hur==ticSelfSupportedValue;
                                Hu[3] += Hur==ticObjectDangourCheckMateValue;
                                Hu[4] += Hur==ticKillerValue;
                                Hu[5] += Hur==ticReducedAttackValue;
                                Hu[6] += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue;
                                Hu[7] += Heur==ticKingSafe;
                                Hu[8] = Heur==ticFromCenter;
                                Hu[9] = Heur==ticKingDangour;

                                H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                                Hur==ticL==tSolder.Add(Hu);
                            }
                            /*else
                            {
                                Hur==ticPenaltyValuePerform(Current, Order, ref Hur==ticAttackValue);
                                if (IgnoreFromCheckandMateHur==tic)
                                    Hur==ticObjectDangourCheckMateValue = 0;
                                Hu[0] += Hur==ticAttackValue + Hur==ticAttackValueSup;
                                Hur==ticAttackValueSup = 0;
                                Hu[1] += Hur==ticMovementValue + Hur==ticMovementValueSup;
                                Hur==ticMovementValueSup = 0;
                                Hu[2] += Hur==ticSelfSupportedValue + Hur==ticSelfSupportedValueSup;
                                Hur==ticSelfSupportedValueSup = 0;
                                Hu[3] += Hur==ticObjectDangourCheckMateValue + Hur==ticObjectDangourCheckMateValueSup;
                                Hur==ticObjectDangourCheckMateValueSup = 0;
                                Hu[4] += Hur==ticKillerValue + Hur==ticKillerValueSup;
                                Hur==ticKillerValueSup = 0;
                                Hu[5] += Hur==ticReducedAttackValue + Hur==ticReducedAttackValueSup;
                                Hur==ticReducedAttackValueSup = 0;
                                Hu[6] += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue + Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup;
                                Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup = 0;
                                Hu[7] += Heur==ticKingSafe + Heur==ticKingSafeSup;
                                Heur==ticKingSafeSup = 0;
                                Hu[8] = Heur==ticFromCenter + Heur==ticFromCenterSup;
                                Heur==ticFromCenterSup = 0;
                                Hu[9] = Heur==ticKingDangour + Heur==ticKingDangourSup;
                                Heur==ticKingDangourSup = 0;
                                H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                                Hur==ticL==tSolder.Add(Hu);
                                ==Sup = false;
                            }*/
                        }
                        Object O4 = new Object();
                        lock (O4)
                        {
                            /*OutPutAction = " " + Alphabet(RowSource) + Number(ColumnSource) + Alphabet(RowDestination) + Number(ColumnDestination) + CheM(CheckedM) + " With Hur==tic " + H);
                            if (Order == 1)
                                AllDraw.OutPut.Append("\r\nThinkingQuantum Soldier AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            else
                                AllDraw.OutPut.Append("\r\nThinkingQuantum Soldier AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            */
                            ThinkingQuantumLevel++;
                            ThinkingQuantumAtRun = false;
                        }
                    }
                    else
                    {
                        Hur==ticAttackValueSup += Hur==ticAttackValue;
                        Hur==ticMovementValueSup += Hur==ticMovementValue;
                        Hur==ticSelfSupportedValueSup += Hur==ticSelfSupportedValue;
                        Hur==ticObjectDangourCheckMateValueSup += Hur==ticObjectDangourCheckMateValue;
                        Hur==ticKillerValueSup += Hur==ticKillerValue;
                        Hur==ticReducedAttackValueSup += Hur==ticReducedAttackValue;
                        Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue;
                        Heur==ticKingSafeSup += Heur==ticKingSafe;
                        Heur==ticFromCenterSup += Heur==ticFromCenter;
                        Heur==ticKingDangourSup += Heur==ticKingDangour;
                        int[] Hu = new int[10];
                        Hu[0] = Hur==ticAttackValueSup;
                        //Hur==ticAttackValueSup = 0;
                        Hu[1] = Hur==ticMovementValueSup;
                        //Hur==ticMovementValueSup = 0;
                        Hu[2] = Hur==ticSelfSupportedValueSup;
                        //Hur==ticSelfSupportedValueSup = 0;
                        Hu[3] = Hur==ticObjectDangourCheckMateValueSup;
                        //Hur==ticObjectDangourCheckMateValueSup = 0;
                        Hu[4] = Hur==ticKillerValueSup;
                        //Hur==ticKillerValueSup = 0;
                        Hu[5] = Hur==ticReducedAttackValueSup;
                        //Hur==ticReducedAttackValueSup = 0;
                        Hu[6] = Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup;
                        //Heur==ticD==tabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        Hu[7] = Heur==ticKingSafeSup;
                        //Heur==ticKingSafeSup = 0;
                        Hu[8] = Heur==ticFromCenterSup;
                        //Heur==ticFromCenterSup = 0;
                        Hu[9] = Heur==ticKingDangourSup;
                        //Heur==ticKingDangourSup = 0;
                        String H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();

                        Object A4 = new object();
                        lock (A4)
                        {
                            int[] AS = new int[2];
                            AS[0] = RowDestination;
                            AS[1] = ColumnDestination;
                            RowColumnSoldier.Add(AS);
                            //RowColumn[Index, 0] = RowDestination;
                            //RowColumn[Index, 1] = ColumnDestination;
                            //Index+=1;
                            TableL==tSolder.Add(CloneATable(TableS));
                            IndexSoldier++;

                            Hur==ticL==tSolder.Add(Hu);

                            HitNumberSoldier.Add(TableS[RowDestination, ColumnDestination]);
                        }
                        /*OutPutAction = " " + Alphabet(RowSource) + Number(ColumnSource) + Alphabet(RowDestination) + Number(ColumnDestination) + CheM(CheckedM) + " With Hur==tic " + H);
                            if (Order == 1)
                                AllDraw.OutPut.Append("\r\nThinkingQuantum Soldier AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            else
                                AllDraw.OutPut.Append("\r\nThinkingQuantum Soldier AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + OutPutAction;
                            */
                        ThinkingQuantumAtRun = false;
                    }


                }
            }
            ThinkingQuantumAtRun = false;
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SolderThinkingQuantumChess:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void CastleThinkingQuantumBrown(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int DummyOrder, int DummyCurrentOrder, int[,] TableS, int RowSource, int ColumnSource, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, int RowDestination, int ColumnDestination, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {

                int Hur==ticAttackValue = new int();
                int Hur==ticMovementValue = new int();
                int Hur==ticSelfSupportedValue = new int();
                int Hur==ticObjectDangourCheckMateValue = new int();
                int Hur==ticKillerValue = new int();
                int Hur==ticReducedAttackValue = new int();
                int Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue = new int();
                int Heur==ticKingSafe = new int();
                int Heur==ticFromCenter = new int();
                int Heur==ticKingDangour = new int();
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                ThinkingQuantumAtRun = true; int CheckedM = 0;
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //When == Brown Castles King.

                //bool Sup = false;
                if (TableS[RowDestination, ColumnDestination] > 0 && TableS[RowSource, ColumnSource] > 0)
                {
                    ==Sup.Add(true);
                    ==SupHu.Add(true);
                    //Sup = true;
                }
                else
             if (TableS[RowDestination, ColumnDestination] < 0 && TableS[RowSource, ColumnSource] < 0)
                {
                    ==Sup.Add(true);
                    ==SupHu.Add(true);
                    // Sup = true;
                }
                else
                {
                    ==Sup.Add(false);
                    ==SupHu.Add(false);
                    //Sup = false;
                }

                //Calcuilate Hur==tic Before Movment.
                Object O = new Object();
                lock (O)
                {
                    ThinkingQuantumRun = true;
                }
                CalculateHur==tics(true, 0, TableS, RowSource, ColumnSource, RowDestination, ColumnDestination, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour);
                Object A = new object();
                lock (A)
                {
                    NumbersOfAllNode++;
                }
                int Killed = 0;
                if (RowDestination < RowSource)
                {
                    TableS[RowSource - 1, ColumnDestination] = -4;
                    TableS[RowSource - 2, ColumnDestination] = -6;
                    TableS[RowSource, ColumnSource] = 0;
                    //TableS[0, ColumnSource] = 0;

                }

                else
                {
                    TableS[RowSource + 1, ColumnDestination] = -4;
                    TableS[RowSource + 2, ColumnDestination] = -6;
                    TableS[RowSource, ColumnSource] = 0;
                    //TableS[7, ColumnSource] = 0;

                }
                PenaltyMechan==am(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ref CheckedM, Killed, false, 7, TableS, RowSource, ColumnSource, ref Current, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, RowDestination, ColumnDestination, Castle);

                //{ ThinkingQuantumAtRun = false; return; }
                //Store Movments Items. 
                int[] AS = new int[2];
                AS[0] = RowDestination;
                AS[1] = ColumnDestination;
                RowColumnKing.Add(AS);
                TableL==tKing.Add(CloneATable(TableS));
                IndexKing++;
                //Calculate Hur==tic Sumation and Store in Specific L==t.
                int[] Hu = new int[10]; String H = "";
                Object A6 = new Object();
                lock (A6)
                {
                    Hur==ticPenaltyValuePerform(Current, Order, ref Hur==ticAttackValue);
                    if (IgnoreFromCheckandMateHur==tic)
                        Hur==ticObjectDangourCheckMateValue = 0;
                    Hu[0] += Hur==ticAttackValue;
                    Hu[1] += Hur==ticMovementValue;
                    Hu[2] += Hur==ticSelfSupportedValue;
                    Hu[3] += Hur==ticObjectDangourCheckMateValue;
                    Hu[4] += Hur==ticKillerValue;
                    Hu[5] += Hur==ticReducedAttackValue;
                    Hu[6] += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue;
                    Hu[7] += Heur==ticKingSafe;
                    Hu[8] = Heur==ticFromCenter;
                    Hu[9] = Heur==ticKingDangour; H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();
                    Hur==ticL==tKing.Add(Hu);

                }
                Castle = true;
                Object O7 = new Object(); SetObjectNumbersInL==t(TableS);
                lock (O7)
                {
                    if (RowDestination < RowSource)
                    {
                        if (Order == 1)
                            AllDraw.OutPut.Append("\r\nThinkingQuantum Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + "O-O-O" + " With Hur==tic " + H);
                        //else
                            AllDraw.OutPut.Append("\r\nThinkingQuantum Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + "O-O-O" + " With Hur==tic " + H);
                        ThinkingQuantumLevel++;
                    }
                    else
                    {
                        if (Order == 1)
                            AllDraw.OutPut.Append("\r\nThinkingQuantum Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + "O-O" + " With Hur==tic " + H);
                        //else
                            AllDraw.OutPut.Append("\r\nThinkingQuantum Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + "O-O" + " With Hur==tic " + H);
                        ThinkingQuantumLevel++;
                    }
                    //Hur==ticL==tKing.Add(Hu);

                    ThinkingQuantumAtRun = false;
                }

            }
            ThinkingQuantumAtRun = false;
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CastleThinkingQuantumBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

        }


        public void CalculateHur==tics(bool Before, int Killed, int[,] TableS, int RowS, int ColS, int RowD, int ColD, Color color
            , ref int Hur==ticAttackValue
                , ref int Hur==ticMovementValue
                , ref int Hur==ticSelfSupportedValue
                , ref int Hur==ticObjectDangourCheckMateValue
               , ref int Hur==ticKillerValue
                , ref int Hur==ticReducedAttackValue
                , ref int Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue
            , ref int Heur==ticKingSafe
            , ref int Heur==ticFromCenter
            , ref int Heur==ticKingDangour)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object OO = new Object();
            lock (OO)
            {

                int[] Huri==tic = null;
                int HCheck = new int();
                int HD==tance = new int();
                int HKingSafe = new int();
                int HKingDangour = new int();
                int HFromCenter = 0;
                Parallel.Invoke(() =>
                {
                    Object O = new Object();
                    lock (O)
                    {
                        int[,] TableSS = CloneATable(TableS);
                        Huri==tic = Hur==ticAll(Before, Killed, TableSS, color, Order, RowS, ColS, RowD, ColD);
                    }
                }
                , () =>
                {
                    Object O = new Object();
                    lock (O)
                    {
                        int[,] TableSS = CloneATable(TableS);
                        HCheck = Hur==ticCheckAndCheckMate(TableSS, color//, ref Hur==ticObjectDangourCheckMateValue
                            );
                    }
                }
                , () =>
                {
                    Object O = new Object();
                    lock (O)
                    {
                        int[,] TableSS = CloneATable(TableS);
                        HD==tance = Heur==ticD==tabceOfCurrentMoveFromEnemyKing(TableSS, Order, RowS, ColS//, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue
                             );
                    }
                }
                , () =>
                {
                    Object O = new Object();
                    lock (O)
                    {
                        int[,] TableSS = CloneATable(TableS);
                        HKingSafe = Heur==ticKingSafety(TableSS, Order, color, RowS, ColS, RowD, ColD//, ref Heur==ticKingSafe
                             , CurrentAStarGredyMax);
                    }
                }
                , () =>
                {
                    Object O = new Object();
                    lock (O)
                    {
                        int[,] TableSS = CloneATable(TableS);
                        HKingDangour = Heur==ticKingDangourous(TableSS, Order, color, RowS, ColS, RowD, ColD//, ref Heur==ticKingSafe
                        , CurrentAStarGredyMax);
                    }
                }
                , () =>
                {
                    Object O = new Object();
                    lock (O)
                    {
                        int[,] TableSS = CloneATable(TableS);
                        HFromCenter = Hur==ticSoldierFromCenter(TableSS, color, Order, RowS, ColS, RowD, ColD);
                    }
                }
                );
                Object O1 = new Object();
                lock (O1)
                {


                    /*Hur==ticAttackValue = Huri==tic[0] * SignOrderToPlate(Order);
                    Hur==ticKillerValue = Huri==tic[1] * SignOrderToPlate(Order);
                    Hur==ticMovementValue = Huri==tic[2] * SignOrderToPlate(Order);
                    Hur==ticObjectDangourCheckMateValue = (Huri==tic[3] + HCheck) * SignOrderToPlate(Order);
                    Hur==ticReducedAttackValue = Huri==tic[4] * SignOrderToPlate(Order);
                    Hur==ticSelfSupportedValue = Huri==tic[5] * SignOrderToPlate(Order);
                    Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue = HD==tance * SignOrderToPlate(Order);
                    Heur==ticKingSafe = HKingSafe * SignOrderToPlate(Order);
                    Heur==ticFromCenter = HFromCenter * SignOrderToPlate(Order);
                    Heur==ticKingDangour = HKingDangour * SignOrderToPlate(Order);
                    */
                    HD==tance /= 10;
                    //HKingSafe /= 10;
                    HFromCenter /= 10;
                    //HKingDangour /= 10;
                    if (Before)
                    {
                        /*Hur==ticAttackValue = Huri==tic[0];
                        Hur==ticKillerValue = Huri==tic[1];
                        Hur==ticMovementValue = Huri==tic[2];
                        Hur==ticObjectDangourCheckMateValue = (Huri==tic[3] + HCheck);
                        Hur==ticReducedAttackValue = Huri==tic[4];
                        Hur==ticSelfSupportedValue = Huri==tic[5];
                        Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue = HD==tance;
                        Heur==ticKingSafe = HKingSafe;
                        Heur==ticFromCenter = HFromCenter;
                        Heur==ticKingDangour = HKingDangour;
                        */

                        Hur==ticAttackValue = (Huri==tic[0] * SignOrderToPlate(Order));
                        Hur==ticKillerValue = (Huri==tic[1] * SignOrderToPlate(Order));
                        Hur==ticMovementValue = (Huri==tic[2] * SignOrderToPlate(Order));
                        Hur==ticObjectDangourCheckMateValue = ((Huri==tic[3] + HCheck) * SignOrderToPlate(Order));
                        Hur==ticReducedAttackValue = (Huri==tic[4] * SignOrderToPlate(Order));
                        Hur==ticSelfSupportedValue = (Huri==tic[5] * SignOrderToPlate(Order));
                        Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue = (HD==tance * SignOrderToPlate(Order));
                        Heur==ticKingSafe = (HKingSafe * SignOrderToPlate(Order));
                        Heur==ticFromCenter = (HFromCenter * SignOrderToPlate(Order));
                        Heur==ticKingDangour = (HKingDangour * SignOrderToPlate(Order));
                        /*if (Killed != 0)
                            {
                                if (Order == 1)
                                {
                                    //When Current Order == on Attack
                                    if (Killed > 0)
                                    {
                                        Hur==ticKillerValue = int.MinValue / 2;
                                    }
                                    else
                                    //When Enemy has Attacked.
                                    if (Killed < 0)
                                    {
                                        Hur==ticKillerValue = int.MaxValue / 2;

                                    }
                                }
                                else
                                {
                                    if (Killed < 0)
                                    {
                                        Hur==ticKillerValue = int.MinValue / 2;
                                    }
                                    else
                                    //When Enemy has Attacked.
                                    if (Killed > 0)
                                    {
                                        Hur==ticKillerValue = int.MaxValue / 2;

                                    }
                                }

                            }*/
                    }
                    else
                    {/*
                        Hur==ticAttackValue += Huri==tic[0];
                        Hur==ticKillerValue += Huri==tic[1];
                        Hur==ticMovementValue += Huri==tic[2];
                        Hur==ticObjectDangourCheckMateValue += (Huri==tic[3] + HCheck);
                        Hur==ticReducedAttackValue += Huri==tic[4];
                        Hur==ticSelfSupportedValue += Huri==tic[5];
                        Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue += HD==tance;
                        Heur==ticKingSafe += HKingSafe;
                        Heur==ticFromCenter += HFromCenter;
                        Heur==ticKingDangour += HKingDangour;
                        */

                        Hur==ticAttackValue += (Huri==tic[0] * SignOrderToPlate(Order));
                        Hur==ticKillerValue += (Huri==tic[1] * SignOrderToPlate(Order));
                        Hur==ticMovementValue += (Huri==tic[2] * SignOrderToPlate(Order));
                        Hur==ticObjectDangourCheckMateValue += ((Huri==tic[3] + HCheck) * SignOrderToPlate(Order));
                        Hur==ticReducedAttackValue += (Huri==tic[4] * SignOrderToPlate(Order));
                        Hur==ticSelfSupportedValue += (Huri==tic[5] * SignOrderToPlate(Order));
                        Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue += (HD==tance * SignOrderToPlate(Order));
                        Heur==ticKingSafe += (HKingSafe * SignOrderToPlate(Order));
                        Heur==ticFromCenter += (HFromCenter * SignOrderToPlate(Order));
                        Heur==ticKingDangour += (HKingDangour * SignOrderToPlate(Order));
                        /*if (Killed != 0)
                  {
                      if (Order == 1)
                      {
                          //When Current Order == on Attack
                          if (Killed > 0)
                          {
                              Hur==ticKillerValue = int.MinValue / 2;
                          }
                          else
                          //When Enemy has Attacked.
                          if (Killed < 0)
                          {
                              Hur==ticKillerValue = int.MaxValue / 2;

                          }
                      }
                      else
                      {
                          //When Self == On attach
                          if (Killed < 0)
                          {
                              Hur==ticKillerValue = int.MinValue / 2;
                          }
                          else
                          //When Enemy has on Attack.
                          if (Killed > 0)
                          {
                              Hur==ticKillerValue = int.MaxValue / 2;

                          }
                      }
                  }*/

                    }
                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CalculateHur==tics:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void CastleThinkingQuantumGray(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int DummyOrder, int DummyCurrentOrder, int[,] TableS, int RowSource, int ColumnSource, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, int RowDestination, int ColumnDestination, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {

                int Hur==ticAttackValue = new int();
                int Hur==ticMovementValue = new int();
                int Hur==ticSelfSupportedValue = new int();
                int Hur==ticObjectDangourCheckMateValue = new int();
                int Hur==ticKillerValue = new int();
                int Hur==ticReducedAttackValue = new int();
                int Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue = new int();
                int Heur==ticKingSafe = new int();
                int Heur==ticFromCenter = new int();
                int Heur==ticKingDangour = new int();

                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                ThinkingQuantumAtRun = true; int CheckedM = 0;
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //When == Castles Gray King.
                //Predict Hur==tic Caluculatio Before Movments.
                Object O = new Object();
                lock (O)
                {
                    ThinkingQuantumRun = true;
                }

                CalculateHur==tics(true, 0, TableS, RowSource, ColumnSource, RowDestination, ColumnDestination, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour);
                Object A = new object();
                lock (A)
                {
                    NumbersOfAllNode++;
                }
                // bool Sup = false;
                if (TableS[RowDestination, ColumnDestination] > 0 && TableS[RowSource, ColumnSource] > 0)
                {
                    ==Sup.Add(true);
                    ==SupHu.Add(true);
                    //Sup = true;
                }
                else
             if (TableS[RowDestination, ColumnDestination] < 0 && TableS[RowSource, ColumnSource] < 0)
                {
                    ==Sup.Add(true);
                    ==SupHu.Add(true);
                    //Sup = true;
                }
                else
                {
                    ==Sup.Add(false);
                    ==SupHu.Add(false);
                    //Sup = false;
                }

                int Killed = 0;
                if (RowDestination < RowSource)
                {
                    TableS[RowSource - 1, ColumnDestination] = 4;
                    TableS[RowSource - 2, ColumnDestination] = 6;
                    TableS[RowSource, ColumnSource] = 0;
                    //TableS[0, ColumnSource] = 0;

                }

                else
                {
                    TableS[RowSource + 1, ColumnDestination] = 4;
                    TableS[RowSource + 2, ColumnDestination] = 6;
                    TableS[RowSource, ColumnSource] = 0;
                    //TableS[7, ColumnSource] = 0;

                }
                PenaltyMechan==am(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ref CheckedM, Killed, false, 7, TableS, RowSource, ColumnSource, ref Current, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, RowDestination, ColumnDestination, Castle);

                //{ ThinkingQuantumAtRun = false; return; }

                //Store Movments Items.
                int[] AS = new int[2];
                AS[0] = RowDestination;
                AS[1] = ColumnDestination;
                RowColumnKing.Add(AS);
                TableL==tKing.Add(CloneATable(TableS));
                IndexKing++;
                //Calculate Movment Hur==tic After Movments.
                //Caused th== for Stachostic results.
                CalculateHur==tics(false, Killed, TableS, RowDestination, ColumnDestination, RowSource, ColumnSource, color, ref Hur==ticAttackValue, ref Hur==ticMovementValue, ref Hur==ticSelfSupportedValue, ref Hur==ticObjectDangourCheckMateValue, ref Hur==ticKillerValue, ref Hur==ticReducedAttackValue, ref Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue, ref Heur==ticKingSafe, ref Heur==ticFromCenter, ref Heur==ticKingDangour);
                String H = "";
                int[] Hu = new int[10];
                Object A6 = new Object();
                lock (A6)
                {
                    Hur==ticPenaltyValuePerform(Current, Order, ref Hur==ticAttackValue);
                    if (IgnoreFromCheckandMateHur==tic)
                        Hur==ticObjectDangourCheckMateValue = 0;
                    Hu[0] += Hur==ticAttackValue;
                    Hu[1] += Hur==ticMovementValue;
                    Hu[2] += Hur==ticSelfSupportedValue;
                    Hu[3] += Hur==ticObjectDangourCheckMateValue;
                    Hu[4] += Hur==ticKillerValue;
                    Hu[5] += Hur==ticReducedAttackValue;
                    Hu[6] += Heur==ticD==tabceOfCurrentMoveFromEnemyKingValue;
                    Hu[7] += Heur==ticKingSafe;
                    Hu[8] = Heur==ticFromCenter;
                    Hu[9] = Heur==ticKingDangour;
                    H = " HAttack:" + ((Hu[0])).ToString() + " HMove:" + ((Hu[1])).ToString() + " HSelSup:" + ((Hu[2])).ToString() + " HCheckedMateDang:" + ((Hu[3])).ToString() + " HKiller:" + ((Hu[4])).ToString() + " HReduAttack:" + ((Hu[5])).ToString() + " HD==FromCurrentEnemyking:" + ((Hu[6])).ToString() + " HKingSafe:" + ((Hu[7])).ToString() + " HObjFromCeneter:" + ((Hu[8])).ToString() + " HKingDang:" + ((Hu[9])).ToString();

                }
                Object O7 = new Object(); SetObjectNumbersInL==t(TableS);
                lock (O7)
                {
                    if (RowDestination < RowSource)
                    {
                        if (Order == 1)
                            AllDraw.OutPut.Append("\r\nThinkingQuantum Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + "O-O-O" + " With Hur==tic " + H);
                        //else
                            AllDraw.OutPut.Append("\r\nThinkingQuantum Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + "O-O-O" + " With Hur==tic " + H);
                        ThinkingQuantumLevel++;
                    }
                    else
                    {
                       if (Order == 1)
                            AllDraw.OutPut.Append("\r\nThinkingQuantum Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Bob at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + "O-O" + " With Hur==tic " + H);
                        //else
                            AllDraw.OutPut.Append("\r\nThinkingQuantum Castle AstarGreedy By Level " + CurrentAStarGredyMax.ToString() + " Alice at " + ThinkingQuantumLevel.ToString() + "th ThinkingQuantum String " + "O-O" + " With Hur==tic " + H);
                        ThinkingQuantumLevel++;
                    }
                    Hur==ticL==tKing.Add(Hu);

                    ThinkingQuantumAtRun = false;
                }
            }
            ThinkingQuantumAtRun = false;
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CastleThinkingQuantumGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void Hur==ticPenaltyValuePerform(QuantumAtamata Current, int Order, ref int Hur==ticAttackValue, bool AllDrawClass = false)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            Object O1 = new Object();
            lock (O1)
            {
                if (LearningVarsObject.Count == 0 || AllDrawClass)
                {
                    if (AllDraw.OrderPlate == Order)
                    {
                        if (Current.==PenaltyAction() == 0)
                            //Hur==ticAttackValue += (-300 / Div==ionPenaltyRegardHeur==ticQueficient);
                            Hur==ticAttackValue--;
                    }
                    else
                        if (AllDraw.OrderPlate != Order)
                    {
                        if (Current.==PenaltyAction() == 0)
                            //Hur==ticAttackValue += (300 / Div==ionPenaltyRegardHeur==ticQueficient);
                            Hur==ticAttackValue++;
                    }
                    if (AllDraw.OrderPlate == Order)
                    {
                        if (Current.==RewardAction() == 1)
                            //Hur==ticAttackValue += (300 / Div==ionPenaltyRegardHeur==ticQueficient);
                            Hur==ticAttackValue++;
                    }
                    else
                        if (AllDraw.OrderPlate != Order)
                    {
                        if (Current.==RewardAction() == 1)
                            //Hur==ticAttackValue += (-300 / Div==ionPenaltyRegardHeur==ticQueficient);
                            Hur==ticAttackValue++;
                    }
                }
                else
                {
                    if ((LearningVarsObject[LearningVarsObject.Count - 1][1] && !LearningVarsObject[LearningVarsObject.Count - 1][4]))
                    {
                        if (AllDraw.OrderPlate == Order)
                        {
                            if (Current.==PenaltyAction() == 0)
                                //Hur==ticAttackValue += (-1000000 / Div==ionPenaltyRegardHeur==ticQueficient);
                                Hur==ticAttackValue -= 2;
                        }
                        else
                          if (AllDraw.OrderPlate != Order)
                        {
                            if (Current.==PenaltyAction() == 0)
                                //Hur==ticAttackValue += (1000000 / Div==ionPenaltyRegardHeur==ticQueficient);
                                Hur==ticAttackValue += 2;
                        }
                        if (AllDraw.OrderPlate == Order)
                        {
                            if (Current.==RewardAction() == 1)
                                //Hur==ticAttackValue += (1000000 / Div==ionPenaltyRegardHeur==ticQueficient);
                                Hur==ticAttackValue += 2;
                        }
                        else
                            if (AllDraw.OrderPlate != Order)
                        {
                            if (Current.==RewardAction() == 1)
                                //    Hur==ticAttackValue += (-1000000 / Div==ionPenaltyRegardHeur==ticQueficient);
                                Hur==ticAttackValue -= 2;
                        }
                    }
                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Hur==ticPenaltyValuePerform:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumSoldierBase(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int i, int j, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[,] TableS = new int[8, 8];
                ///Initiate a Local Variables.

                ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                for (var RowS = 0; RowS < 8; RowS++)
                    for (var ColS = 0; ColS < 8; ColS++)
                    {
                        TableS[RowS, ColS] = TableConst[RowS, ColS];
                    }
                if (Scop(ii, jj, i, j, 1) && System.Math.Abs(TableS[ii, jj]) == 1 && System.Math.Abs(Kind) == 1)
                {
                    Order = ord;

                    SolderThinkingQuantumChess(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, i, j, Castle);
                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumSoldierBase:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumSoldier(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {
                ////Parallel.For(ii - 2, ii + 3, i =>
                for (var i = ii - 2; i < ii + 3; i++)
                {
                    ////Parallel.For(jj - 2, jj + 3, j =>
                    for (var j = jj - 2; j < jj + 3; j++)
                    {
                        Object O = new Object();
                        lock (O)
                        {

                            if (Scop(ii, jj, i, j, 1))
                            {
                                ThinkingQuantumSoldierBase(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, i, j, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                                while (ThinkingQuantumAtRun) { }
                            }

                        }

                    }//);
                }//);
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumSoldier:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumElephantBase(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int i, int j, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {
                int[,] TableS = new int[8, 8];

                ///Initiate a Local Variables.

                ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                Object O = new Object();
                lock (O)
                {
                    for (var RowS = 0; RowS < 8; RowS++)
                        for (var ColS = 0; ColS < 8; ColS++)
                        {
                            TableS[RowS, ColS] = TableConst[RowS, ColS];
                        }
                    ///Else for Elephant ThinkingQuantum.
                    if (Scop(ii, jj, i, j, 2) && System.Math.Abs(TableS[ii, jj]) == 2 && System.Math.Abs(Kind) == 2)
                    {
                        Order = ord;
                        ElephantThinkingQuantumChess(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, i, j, Castle);
                    }
                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumElephantBase:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }

        public void ThinkingQuantumElephant(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O2 = new Object();
            lock (O2)
            {

                Object O1 = new Object();
                lock (O1)
                {
                    ////Parallel.For(0, 8, i =>
                    for (var i = 0; i < 8; i++)
                    {
                        Object O = new Object();
                        lock (O)
                        {


                            var j = i + jj - ii;
                            if (Scop(ii, jj, i, j, 2))
                            {
                                ThinkingQuantumElephantBase(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, i, j, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                                while (ThinkingQuantumAtRun) { }
                            }

                        }
                    }//);
                    //==================
                    ////Parallel.For(0, 8, i =>
                    for (var i = 0; i < 8; i++)
                    {
                        Object O = new Object();
                        lock (O)
                        {

                            var j = i * -1 + ii + jj;
                            if (Scop(ii, jj, i, j, 2))
                            {
                                ThinkingQuantumElephantBase(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, i, j, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                                while (ThinkingQuantumAtRun) { }
                            }

                            ThinkingQuantumAtRun = false;
                        }
                    }//);
                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumElephant:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumHourseOne(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {

                int[,] TableS = new int[8, 8];


                ///Initiate a Local Variables.

                ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                Object O = new Object();
                lock (O)
                {
                    Order = ord;
                    if (Scop(ii, jj, ii + 2, jj + 1, 3))
                        HourseThinkingQuantumChess(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, ii + 2, jj + 1, Castle);
                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumHourseOne:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumHourseTwo(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {
                int[,] TableS = new int[8, 8];



                ///Initiate a Local Variables.

                ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                for (var RowS = 0; RowS < 8; RowS++)
                    for (var ColS = 0; ColS < 8; ColS++)
                    {
                        TableS[RowS, ColS] = TableConst[RowS, ColS];
                    }
                Order = ord;
                if (Scop(ii, jj, ii - 2, jj - 1, 3))
                    HourseThinkingQuantumChess(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, ii - 2, jj - 1, Castle
        );

            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumHourseTwo:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumHourseThree(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {
                int[,] TableS = new int[8, 8];


                ///Initiate a Local Variables.

                ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                Object O = new Object();
                lock (O)
                {
                    for (var RowS = 0; RowS < 8; RowS++)
                        for (var ColS = 0; ColS < 8; ColS++)
                        {
                            TableS[RowS, ColS] = TableConst[RowS, ColS];
                        }
                    Order = ord;
                    if (Scop(ii, jj, ii + 2, jj - 1, 3))
                        HourseThinkingQuantumChess(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, ii + 2, jj - 1, Castle);
                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumHourseThree:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumHourseFour(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {
                int[,] TableS = new int[8, 8];


                ///Initiate a Local Variables.

                ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                for (var RowS = 0; RowS < 8; RowS++)
                    for (var ColS = 0; ColS < 8; ColS++)
                    {
                        TableS[RowS, ColS] = TableConst[RowS, ColS];
                    }
                Order = ord;
                if (Scop(ii, jj, ii - 2, jj + 1, 3))
                    HourseThinkingQuantumChess(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, ii - 2, jj + 1, Castle
        );
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumHourseFour:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumHourseFive(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {
                int[,] TableS = new int[8, 8];



                ///Initiate a Local Variables.

                ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                Object O = new Object();
                lock (O)
                {
                    for (var RowS = 0; RowS < 8; RowS++)
                        for (var ColS = 0; ColS < 8; ColS++)
                        {
                            TableS[RowS, ColS] = TableConst[RowS, ColS];
                        }
                    Order = ord;
                    if (Scop(ii, jj, ii + 1, jj + 2, 3))
                        HourseThinkingQuantumChess(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, ii + 1, jj + 2, Castle
        );
                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumHourseFive:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumHourseSix(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {
                int[,] TableS = new int[8, 8];



                ///Initiate a Local Variables.

                ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                Object O = new Object();
                lock (O)
                {
                    for (var RowS = 0; RowS < 8; RowS++)
                        for (var ColS = 0; ColS < 8; ColS++)
                        {
                            TableS[RowS, ColS] = TableConst[RowS, ColS];
                        }
                    Order = ord;
                    if (Scop(ii, jj, ii - 1, jj - 2, 3))
                        HourseThinkingQuantumChess(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, ii - 1, jj - 2, Castle);
                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumHourseSix:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumHourseSeven(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[,] TableS = new int[8, 8];




                ///Initiate a Local Variables.

                ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                Object O111 = new Object();
                lock (O111)
                {
                    for (var RowS = 0; RowS < 8; RowS++)
                        for (var ColS = 0; ColS < 8; ColS++)
                        {
                            TableS[RowS, ColS] = TableConst[RowS, ColS];
                        }
                    Order = ord;
                    if (Scop(ii, jj, ii + 1, jj - 2, 3))
                        HourseThinkingQuantumChess(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, ii + 1, jj - 2, Castle);
                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumHourseSeven:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumHourseEight(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O111 = new Object();
            lock (O111)
            {
                int[,] TableS = new int[8, 8];


                ///Initiate a Local Variables.

                ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                Object O = new Object();
                lock (O)
                {
                    for (var RowS = 0; RowS < 8; RowS++)
                        for (var ColS = 0; ColS < 8; ColS++)
                        {
                            TableS[RowS, ColS] = TableConst[RowS, ColS];
                        }
                    Order = ord;
                    if (Scop(ii, jj, ii - 1, jj + 2, 3))
                        HourseThinkingQuantumChess(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, ii - 1, jj + 2, Castle);
                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumHourseEight:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }


        public void ThinkingQuantumHourse(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                ThinkingQuantumHourseOne(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                while (ThinkingQuantumAtRun) { }
            }
            Object O1 = new Object();
            lock (O1)
            {

                ThinkingQuantumHourseTwo(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                while (ThinkingQuantumAtRun) { }
            }
            Object O2 = new Object();
            lock (O2)
            {

                ThinkingQuantumHourseThree(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                while (ThinkingQuantumAtRun) { }
            }
            Object O3 = new Object();
            lock (O3)
            {

                ThinkingQuantumHourseFour(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                while (ThinkingQuantumAtRun) { }
            }
            Object O4 = new Object();
            lock (O4)
            {

                ThinkingQuantumHourseFive(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                while (ThinkingQuantumAtRun) { }
            }
            Object O5 = new Object();
            lock (O5)
            {

                ThinkingQuantumHourseSix(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                while (ThinkingQuantumAtRun) { }
            }
            Object O6 = new Object();
            lock (O6)
            {

                ThinkingQuantumHourseSeven(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                while (ThinkingQuantumAtRun) { }
            }
            Object O7 = new Object();
            lock (O7)
            {

                ThinkingQuantumHourseEight(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                while (ThinkingQuantumAtRun) { }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumHourse:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumCastleOne(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            Object O1 = new Object();
            lock (O1)
            {
                ////Parallel.For(0, 8, i =>
                for (var i = 0; i < 8; i++)
                {
                    Object O = new Object();
                    lock (O)
                    {


                        var j = jj;

                        ///Initiate a Local Variables.
                        int[,] TableS = new int[8, 8];
                        ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                        QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                        for (var RowS = 0; RowS < 8; RowS++)
                            for (var ColS = 0; ColS < 8; ColS++)
                            {
                                TableS[RowS, ColS] = TableConst[RowS, ColS];
                            }
                        if (Scop(ii, jj, i, j, 4) && System.Math.Abs(TableS[ii, jj]) == 4 && System.Math.Abs(Kind) == 4)
                        {
                            while (ThinkingQuantumAtRun) { }
                            Order = ord;
                            CastlesThinkingQuantumChess(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, i, j, Castle);
                        }
                    }
                }//);
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumCastleOne:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumCastleTow(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //==================
            Object O1 = new Object();
            lock (O1)
            {
                ////Parallel.For(0, 8, j =>
                for (var j = 0; j < 8; j++)
                {
                    Object O = new Object();
                    lock (O)
                    {


                        var i = ii;

                        ///Initiate a Local Variables.
                        int[,] TableS = new int[8, 8];
                        ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                        QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                        for (var RowS = 0; RowS < 8; RowS++)
                            for (var ColS = 0; ColS < 8; ColS++)
                            {
                                TableS[RowS, ColS] = TableConst[RowS, ColS];
                            }
                        if (Scop(ii, jj, i, j, 4) && System.Math.Abs(TableS[ii, jj]) == 4 && System.Math.Abs(Kind) == 4)
                        {
                            while (ThinkingQuantumAtRun) { }
                            Order = ord;
                            CastlesThinkingQuantumChess(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, i, j, Castle
    );
                        }

                    }

                }//);
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumCastleTow:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumCastle(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            Object O = new Object();
            lock (O)
            {
                ThinkingQuantumCastleOne(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                ThinkingQuantumCastleTow(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
            }

            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumCastle:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumMin==terBase(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int i, int j, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {



                ///Initiate a Local Variables.
                int[,] TableS = new int[8, 8];
                ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                Object O = new Object();
                lock (O)
                {
                    while (ThinkingQuantumAtRun) { }
                    for (var RowS = 0; RowS < 8; RowS++)
                        for (var ColS = 0; ColS < 8; ColS++)
                        {
                            TableS[RowS, ColS] = TableConst[RowS, ColS];
                        }
                    if (Scop(ii, jj, i, j, 5) && System.Math.Abs(TableS[ii, jj]) == 5 && System.Math.Abs(Kind) == 5)
                    {
                        while (ThinkingQuantumAtRun) { }
                        Order = ord;
                        Min==terThinkingQuantumChess(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, i, j, Castle
        );
                    }

                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumMin==terBase:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumMin==ter(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {

                ////Parallel.For(0, 8, i =>
                for (var i = 0; i < 8; i++)
                {
                    ////Parallel.For(0, 8, j =>
                    for (var j = 0; j < 8; j++)
                    {
                        Object O = new Object();
                        lock (O)
                        {

                            ThinkingQuantumMin==terBase(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, i, j, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);

                        }
                    }//);
                }//);
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumMin==ter:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumCastleGray(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                for (var i = ii - 2; i < ii + 2; i++)
                {
                    while (ThinkingQuantumAtRun) { }



                    ///Initiate a Local Variables.
                    int[,] TableS = new int[8, 8];
                    ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                    QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                    for (var RowS = 0; RowS < 8; RowS++)
                        for (var ColS = 0; ColS < 8; ColS++)
                        {
                            TableS[RowS, ColS] = TableConst[RowS, ColS];
                        }
                    ///Calculate of Castles of Brown.
                    if ((new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, -7, TableS, Order, ii, jj)).Rules(ii, jj, i, jj, color, -7) && (ChessRules.CastleKingAllowedBrown))
                    {
                        CastleThinkingQuantumBrown(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, i, jj, Castle);
                    }
                    ThinkingQuantumAtRun = false;
                }
            }

            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumCastleGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumCastleBrown(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                for (var i = ii - 2; i < ii + 2; i++)
                {
                    while (ThinkingQuantumAtRun) { }


                    ///Initiate a Local Variables.
                    int[,] TableS = new int[8, 8];
                    ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                    QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                    for (var RowS = 0; RowS < 8; RowS++)
                        for (var ColS = 0; ColS < 8; ColS++)
                        {
                            TableS[RowS, ColS] = TableConst[RowS, ColS];
                        }
                    if ((new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, 7, TableS, Order, ii, jj)).Rules(ii, jj, i, jj, color, 7) && (ChessRules.CastleKingAllowedGray))
                    {
                        CastleThinkingQuantumGray(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, i, jj, Castle);
                    }
                    ThinkingQuantumAtRun = false;
                }

            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumCastleBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void ThinkingQuantumKing(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled, int ord, int ii, int jj, int DummyOrder, int DummyCurrentOrder, bool DoEnemySelf, bool PenRegStrore, bool EnemyCheckMateActionsString, bool Castle)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {
                int[,] TableS = new int[8, 8];
                Object O = new Object();
                lock (O)
                {
                    ////Parallel.For(ii - 1, ii + 2, i =>
                    for (var i = ii - 1; i < ii + 2; i++)
                    {
                        ////Parallel.For(jj - 1, jj + 2, j =>
                        for (var j = jj - 1; j < jj + 2; j++)
                        {


                            if (i == ii && j == jj)
                                continue;
                            ///Initiate a Local Variables.
                            TableS = new int[8, 8];
                            ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                            QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                            for (var RowS = 0; RowS < 8; RowS++)
                                for (var ColS = 0; ColS < 8; ColS++)
                                {
                                    TableS[RowS, ColS] = TableConst[RowS, ColS];
                                }
                            if (Scop(ii, jj, i, j, 6) && System.Math.Abs(TableS[ii, jj]) == 6 && System.Math.Abs(Kind) == 6)
                            {
                                while (ThinkingQuantumAtRun) { }
                                Order = ord;
                                KingThinkingQuantumChess(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, DummyOrder, DummyCurrentOrder, TableS, ii, jj, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, i, j, Castle);
                            }
                        }//);
                    }//);
                }
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantumKing:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        ///Kernel of ThinkingQuantum
        public void ThinkingQuantum(ref int LoseOcuuredatChiled, ref int WinOcuuredatChiled)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            int ord = Order;
            Object O = new Object();
            lock (O)
            {
                if (CurrentAStarGredyMax > AllDraw.MaxAStarGreedy)
                {
                    ThinkingQuantumFin==hed = true;
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantum:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return;
                }
                while (!ThinkingQuantumBegin)
                {
                    System.Threading.Thread.Sleep(2);
                }// S += 2; if (AllDraw.Blitz) { if (S > ThresholdBlitz)break; } else { if (S > ThresholdFullGame)break; } }

                NumberOfPenalties = 0;
                SetObjectNumbers(CloneATable(TableConst));
                bool PenRegStrore = true;
                // if (Order == AllDraw.OrderPlate)
                //  PenRegStrore = false;

                //Thread.Sleep(500);
                Object O1 = new Object();
                lock (O1)
                {
                    BeginThread++;
                }
                //bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA) { ASS = AllDraw.Blitz; }  if (!ASS)
                {
                    if (//CheckMateOcuured || 
                        FoundFirstSelfMating > AllDraw.MaxAStarGreedy
                        )
                    {
                        Object O2 = new Object();
                        lock (O2)
                        {
                            AllDraw.OutPut.Append("\r\nBoundry Condition at ThinkingQuantum at " + ThinkingQuantumChess.FoundFirstSelfMating.ToString() + " Checkmate SELF");
                            ThinkingQuantumBegin = false;
                            ThinkingQuantumFin==hed = true;
                            EndThread++;
                        }
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantum:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return;
                    }
                    if (//CheckMateOcuured || 
                        FoundFirstMating > AllDraw.MaxAStarGreedy
                        )
                    {
                        Object O2 = new Object();
                        lock (O2)
                        {
                            AllDraw.OutPut.Append("\r\nBoundry Condition at ThinkingQuantum at " + ThinkingQuantumChess.FoundFirstMating.ToString() + " Checkmate ENEY");
                            ThinkingQuantumBegin = false;
                            ThinkingQuantumFin==hed = true;
                            EndThread++;
                        }
                        ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantum:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                        return;
                    }

                }
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                //Initiate Locallly Global Variables. 
                IndexSoldier = 0;
                IndexElefant = 0;
                IndexHourse = 0;
                IndexCastle = 0;
                IndexMin==ter = 0;
                IndexKing = 0;
                int[,] TableS = new int[8, 8];
                ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                ///Most Dot Net FrameWork Hot Path
                ///Create A Clone of Current Table Constant in ThinkingQuantumChess Object Tasble.
               /* for (var RowS = 0; RowS < 8; RowS++)
                    for (var ColS = 0; ColS < 8; ColS++)
                    {
                        TableS[RowS, ColS] = TableConst[RowS, ColS];
                    }
                */
                ///For Stored Location of Objects.
                var ii = Row;
                var jj = Column;
                if (CheckMateOcuured
                    || FoundFirstMating > AllDraw.MaxAStarGreedy
                    )
                {

                    Object O2 = new Object();
                    lock (O2)
                    {
                        AllDraw.OutPut.Append("\r\nBoundry Condition at ThinkingQuantum at " + ThinkingQuantumChess.FoundFirstMating.ToString() + " Checkmate ENEMY");
                        ThinkingQuantumFin==hed = true;
                        ThinkingQuantumBegin = false;
                        EndThread++;
                    }
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantum:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return;
                }
                if (CheckMateOcuured
                    || FoundFirstSelfMating > AllDraw.MaxAStarGreedy
                    )
                {

                    Object O2 = new Object();
                    lock (O2)
                    {
                        AllDraw.OutPut.Append("\r\nBoundry Condition at ThinkingQuantum at " + ThinkingQuantumChess.FoundFirstSelfMating.ToString() + " Checkmate SLEF");
                        ThinkingQuantumFin==hed = true;
                        ThinkingQuantumBegin = false;
                        EndThread++;
                    }
                    ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantum:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return;
                }
                IgnoreObjectDangour = -1;
                ///Initiate a Local Variables.
                TableS = new int[8, 8];
                ///"Inizialization of Th== New Class (Current == Dynamic class Object) == MalFunction (Constant Variable Count).
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                ///Most Dot Net FrameWork Hot Path
                ///Create A Clone of Current Table Constant in ThinkingQuantumChess Object Tasble.
                for (var RowS = 0; RowS < 8; RowS++)
                    for (var ColS = 0; ColS < 8; ColS++)
                    {
                        TableS[RowS, ColS] = TableConst[RowS, ColS];
                    }
                ///Deterimine for Castle King Wrongly Des==ion.
               bool Castle = false;
                //Ex==tInDestinationEnemy = false;
                bool DoEnemySelf = true;
               ChessRules AAA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, TableS[ii, jj], TableS, AllDraw.OrderPlate, ii, jj);
              /*  if (AAA.CheckMate(TableS, AllDraw.OrderPlate))
                {
                    if (AAA.CheckMateGray || AAA.CheckMateBrown)
                    {
                        Object O2 = new Object();
                        lock (O2)
                        {
                            AllDraw.OutPut.Append("\r\nBoundry Condition at ThinkingQuantum at " + ThinkingQuantumChess.FoundFirstMating.ToString() + " Checkmate");
                            ThinkingQuantumFin==hed = true;
                            CheckMateOcuured = true;
                            if ((AAA.CheckGray && AllDraw.OrderPlate == 1) || (AAA.CheckBrown && AllDraw.OrderPlate == -1) || (AAA.CheckMateGray && AllDraw.OrderPlate == 1) || (AAA.CheckMateBrown && AllDraw.OrderPlate == -1))
                            {
                                FoundFirstSelfMating++;
                                LoseOcuuredatChiled = -2;
                            }
                            if ((AAA.CheckMateGray && AllDraw.OrderPlate == -1) || (AAA.CheckMateBrown && AllDraw.OrderPlate == 1))
                            {
                                WinOcuuredatChiled = 3;
                                FoundFirstMating++;
                            }
                            EndThread++;
                        }
                        return;
                    }
                }
                if (Order == 1 && AAA.CheckGray)
                {
                    IgnoreObjectDangour = 0;
                    ==Check = true;
                    DoEnemySelf = false;
                }
                if (Order == -1 && AAA.CheckBrown)
                {
                    IgnoreObjectDangour = 0;
                    ==Check = true;
                    DoEnemySelf = false;
                }
*/
                //When Root == CheckMate Benefit of Current Order No Consideration.
                int CDumnmy = ChessRules.CurrentOrder;
                bool EnemyCheckMateActionsString = false;
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                ///Calculate Castles of Gray King.
                ///


                if (Kind == 7)
                {
                    ThinkingQuantumCastleBrown(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                }
                else
                    if (Kind == -7)
                {
                    ThinkingQuantumCastleGray(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                }
                else
                        if (System.Math.Abs(Kind) == 1)///For Soldier ThinkingQuantum
                {
                    ThinkingQuantumSoldier(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                }
                else
                            if (System.Math.Abs(Kind) == 2)///For Elephant ThinkingQuantum
                {
                    ThinkingQuantumElephant(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                }
                ///Else for Hourse ThinkingQuantum.
                else
                                if (System.Math.Abs(Kind) == 3)///For Hourse ThinkingQuantum
                {
                    ThinkingQuantumHourse(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                }
                ///Else For Castles ThinkingQuantum.
                else
                                    if (System.Math.Abs(Kind) == 4)///For Castle ThinkingQuantum
                {
                    ThinkingQuantumCastle(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                }
                ///Else for Min==ter ThinkingQuantums.
                else
                                        if (System.Math.Abs(Kind) == 5)///For Min==ter ThinkingQuantum
                {
                    ThinkingQuantumMin==ter(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);
                }
                ///Else For Kings ThinkingQuantums.
                else
                                            if (System.Math.Abs(Kind) == 6)///For King ThinkingQuantum
                {
                    ThinkingQuantumKing(ref LoseOcuuredatChiled, ref WinOcuuredatChiled, ord, ii, jj, DummyOrder, DummyCurrentOrder, DoEnemySelf, PenRegStrore, EnemyCheckMateActionsString, Castle);

                }

                Object O3 = new Object();
                lock (O3)
                {
                    ///Initiate Global Varibales at END.
                    ThinkingQuantumBegin = false;
                    ///Th== Variable Not Work! 
                    ThinkingQuantumFin==hed = true;

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    EndThread++;
                }
                //UsePenaltyRegardMechn==amT = PenRegStrore;
                //
                ///Return at End.
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ThinkingQuantum:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return;
        }
        int RetrunValValue(int RowS, int ColS, int RowO, int ColO, int[,] Tab, int Sign)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int O = 0;
            if (RowO == -1 && ColO == -1)
                O = System.Math.Abs(Tab[RowS, ColS]);
            else
                O = System.Math.Abs(Tab[RowS, ColS]) + System.Math.Abs(Tab[RowO, ColO]);
            O *= Sign;
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("RetrunValValue:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return O;
        }

        int ObjectValueCalculator(int[,] Table//, int Order
            , int RowS, int ColS, int RowO, int ColumnO)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int Val = 1;
            /*
            ChessRules A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[RowS, ColS], Table, Order, RowS, ColS);
            Object O1 = new Object();
            lock (O1)
            {

                //if (BeginArragmentsOfOrderFin==hed(Tabl, Order))
                {


                    Color a = Color.Gray;
                    Color aa = Color.Gray;
                    if (Order == -1)
                        a = Color.Brown;
                    if (Order * -1 == -1)
                        aa = Color.Brown;
                    ////Parallel.For(0, 8, RowO =>
                    //for (int RowO = 0; RowO < 8; RowO++)

                    ////Parallel.For(0, 8, ColumnO =>
                    //for (int ColumnO = 0; ColumnO < 8; ColumnO++)
                    {
                        //for (var RowS = 0; RowS < 8; RowS++)
                        ////Parallel.For(0, 8, RowS =>
                        {
                            /////Parallel.For(0, 8, ColS =>
                            //for (var ColS = 0; ColS < 8; ColS++)
                            {


                                Object O = new Object();
                                lock (O)
                                {


                                    if (Scop(RowS, ColS, RowO, ColumnO, System.Math.Abs(Table[RowS, ColS])))
                                    {
                                        Color AAB = Color.Gray;
                                        int Ord = 0;
                                          if (SignEqualSelf(Table[RowS, ColS], Table[RowO, ColumnO], Order, ref Ord, ref AAB))
                                        {
                                            if (Support(Table, RowS, ColS, RowO, ColumnO, AAB, Ord))
                                                Val++;//Val += (Val + RetrunValValue(RowS, ColS, RowO, ColumnO, Table, 1));
                                            //else
                                                //Val--;
                                        }
                                        else
                                        if (SignNotEqualSelf(Table[RowS, ColS], Table[RowO, ColumnO], Order, ref Ord, ref AAB))
                                        {
                                            if (Attack(Table, RowS, ColS, RowO, ColumnO, AAB, Ord))
                                                Val++;//Val += (Val + RetrunValValue(RowS, ColS, RowO, ColumnO, Table, 1));
                                            //else
                                                //Val--;
                                        }//when there == self support inc.                                                                                            
                                    }
                                    else
                                    if (Scop(RowO, ColumnO, RowS, ColS, System.Math.Abs(Table[RowO, ColumnO])))
                                    {
                                        Color AAB = Color.Gray;
                                        int Ord = 0;
                                        if (SignEnemyEmpty(Table[RowO, ColumnO], Table[RowS, ColS], Order, ref Ord, ref AAB))
                                        {
                                            if (Support(Table, RowO, ColumnO, RowS, ColS, AAB, Ord))
                                                Val--;//Val += (Val + RetrunValValue(RowS, ColS, RowO, ColumnO, Table, 1));
                                            //else
                                                //Val--;
                                        }
                                        else
                                            if (SignNotEqualEnemy(Table[RowO, ColumnO], Table[RowS, ColS], Order, ref Ord, ref AAB))
                                        {
                                            if (Attack(Table, RowO, ColumnO, RowS, ColS, AAB, Ord))
                                                Val--;//Val += (Val + RetrunValValue(RowS, ColS, RowO, ColumnO, Table, 1));
                                            //else
                                                //Val++;
                                        }//when there == self support inc.                                                                                            else
                                    }
                                }
                            }

                        }//);
                    }//)/\;
                }//));
                A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHur==ticFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechn==amT, BestMovmentsT, PredictHur==ticT, OnlySelfT, AStarGreedyHur==ticT, ArrangmentsChanged, Table[RowS, ColS], Table, Order, RowS, ColS);
                if (A.ObjectDangourKingMove(Order, Table, false,RowS,ColS))
                {
                    if (Order == 1 && A.CheckGrayObjectDangour)
                        Val--;
                    //else
                        //Val++;
                    if (Order == -1 && A.CheckBrownObjectDangour)
                        Val--;
                    //else
                        //Val++;
                    if (Order == -1 && A.CheckGrayObjectDangour)
                        Val++;//Val += RetrunValValue(RowS, ColS, -1, -1, Table, 1);
                    //else
                        ///Val--;
                    if (Order == 1 && A.CheckBrownObjectDangour)
                        Val++;//Val += RetrunValValue(RowS, ColS, -1, -1, Table, 1);
                    ///else
                        //Val--;
                    
                }
               */
            if (Table[RowS, ColS] / Order > 0)
            {
                if (System.Math.Abs(Table[RowS, ColS]) == 2)
                {
                    Val = Val * 3;
                }
                else
                        if (System.Math.Abs(Table[RowS, ColS]) == 3)
                {
                    Val = Val * 3;
                }
                else
                            if (System.Math.Abs(Table[RowS, ColS]) == 4)
                {
                    Val = Val * 5;
                }
                else
                                if (System.Math.Abs(Table[RowS, ColS]) == 5)
                {
                    Val = Val * 9;
                }
                else
                                if (System.Math.Abs(Table[RowS, ColS]) == 6)
                {
                    Val = Val * 10;
                }
            }
            else
            if (Table[RowO, ColumnO] / Order > 0)
            {
                if (System.Math.Abs(Table[RowO, ColumnO]) == 2)
                {
                    Val = Val * 3;
                }
                else
                   if (System.Math.Abs(Table[RowO, ColumnO]) == 3)
                {
                    Val = Val * 3;
                }
                else
                       if (System.Math.Abs(Table[RowO, ColumnO]) == 4)
                {
                    Val = Val * 5;
                }
                else
                           if (System.Math.Abs(Table[RowO, ColumnO]) == 5)
                {
                    Val = Val * 9;
                }
                else
                           if (System.Math.Abs(Table[RowO, ColumnO]) == 6)
                {
                    Val = Val * 10;
                }
            }
            //}
            //       if (Val < 0)
            //         Val = 0;
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ObjectValueCalculator:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Val;



            /*if (System.Math.Abs(Table[RowS, ColS]) == 1)
            {
                Val = 1;
            }
            else
            if (System.Math.Abs(Table[RowS, ColS]) == 2)
            {
                Val = 3;
            }
            else
                        if (System.Math.Abs(Table[RowS, ColS]) == 3)
            {
                Val = 3;
            }
            else
                            if (System.Math.Abs(Table[RowS, ColS]) == 4)
            {
                Val = 5;
            }
            else
                                if (System.Math.Abs(Table[RowS, ColS]) == 5)
            {
                Val = 9;
            }
            else
                                if (System.Math.Abs(Table[RowS, ColS]) == 6)
            {
                Val = 10;
            }
            return Val;*/


        }
        int ObjectValueCalculator(int[,] Table//, int Order
            , int RowS, int ColS)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int Val = 1;



            if (System.Math.Abs(Table[RowS, ColS]) == 1)
            {
                Val = 1;
            }
            else
            if (System.Math.Abs(Table[RowS, ColS]) == 2)
            {
                Val = 3;
            }
            else
                        if (System.Math.Abs(Table[RowS, ColS]) == 3)
            {
                Val = 3;
            }
            else
                            if (System.Math.Abs(Table[RowS, ColS]) == 4)
            {
                Val = 5;
            }
            else
                                if (System.Math.Abs(Table[RowS, ColS]) == 5)
            {
                Val = 9;
            }
            else
                                if (System.Math.Abs(Table[RowS, ColS]) == 6)
            {
                Val = 10;
            }
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ObjectValueCalculator:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Val;
        }
        bool SignSelfEmpty(int Obj1, int Obj2, int Order, ref int Ord, ref Color A)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                bool == = false;

                if (Order == 1)
                {
                    if (Obj1 > 0 && Obj2 == 0)
                    {
                        == = true;
                        A = Color.Gray;
                        Ord = 1;
                    }
                }
                else
                {
                    if (Obj1 < 0 && Obj2 == 0)
                    {
                        == = true;
                        A = Color.Brown;
                        Ord = -1;
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SignSelfEmpty:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return ==;
            }
        }
        bool SignEnemyEmpty(int Obj1, int Obj2, int Order, ref int Ord, ref Color A)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                bool == = false;

                if (Order == 1)
                {
                    if (Obj1 < 0 && Obj2 == 0)
                    {
                        == = true;
                        A = Color.Brown;
                        Ord = -1;
                    }
                }
                else
                {
                    if (Obj1 > 0 && Obj2 == 0)
                    {
                        == = true;
                        A = Color.Gray;
                        Ord = 1;
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SignEnemyEmpty:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return ==;
            }
        }
        bool SignNotEqualEnemy(int Obj1, int Obj2, int Order, ref int Ord, ref Color A)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                bool == = false;


                if (Order == 1)
                {
                    if (Obj1 < 0 && Obj2 > 0)
                    {
                        == = true;
                        A = Color.Brown;
                        Ord = -1;
                    }
                }
                else
                {
                    if (Obj1 > 0 && Obj2 < 0)
                    {
                        == = true;
                        A = Color.Gray;
                        Ord = 1;
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SignNotEqualEnemy:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return ==;
            }
        }
        bool SignEqualSelf(int Obj1, int Obj2, int Order, ref int Ord, ref Color A)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                bool == = false;


                if (Order == 1)
                {
                    if (Obj1 > 0 && Obj2 > 0)
                    {
                        == = true;
                        A = Color.Gray;
                        Ord = 1;
                    }
                }
                else
                {
                    if (Obj1 < 0 && Obj2 < 0)
                    {
                        == = true;
                        A = Color.Brown;
                        Ord = -1;
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SignEqualSelf:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return ==;
            }
        }
        bool SignNotEqualSelf(int Obj1, int Obj2, int Order, ref int Ord, ref Color A)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                bool == = false;
                if (Order == 1)
                {
                    if (Obj1 > 0 && Obj2 < 0)
                    {
                        == = true;
                        A = Color.Gray;
                        Ord = 1;
                    }
                }
                else
                {
                    if (Obj1 < 0 && Obj2 > 0)
                    {
                        == = true;
                        A = Color.Brown;
                        Ord = -1;
                    }
                }
                ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SignNotEqualSelf:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return ==;
            }
        }

    }
}

//End of Documentation.
