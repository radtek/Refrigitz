/*******************************************************************************************
 * Initiate and Decision making class.******************************************************
 * Ramin Edjlal*****************************************************************************
 * Call Of Constructor From Constructor***************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * The Storing AllDraw Object in Self Constructor Caused Stack Overflow*******************0.12**4**Managements and Cuation Programing**********************(+)
 * Link List Of Storing String Caused A Stack Over Flow***********************************0.12**4**Managements and Cuation Programing**********************(+)
 * Wait For Finished Current AStarGreedy Caused To Long Time*************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Need To Heuristic (Arvin) Function(s) to Manage Cell in Form1**************************0.12**4**Managements and Cuation Programing**********************(+)
 * First Scanning Movements of Things Anomaly*********************************************0.12**4**Managements and Cuation Programing**********************(+)
 * In Current Version of Heuristic Table Doesn’t Reached(Zero)****************************0.12**4**Managements and Cuation Programing**********************(+)
 * In Current Version InitiateForEveryThisngsHome Dosn't Work*****************************0.12**4**Managements and Cuation Programing**********************(+)
 * In This Version Thinking Taking A LotofTime(AStarGreedyt Array Tree)**********************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Work In AStarGreedys. But Scanning Dosen’t Works************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Adding Clone Caused To Stack Overflow**************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Clone Caused To StackOverFlow**********************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Row And Column Become Zero in Virtualization*******************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Initiate Error*************************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Seems To Be Logical Drawing ***********************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * int Suddenly Changing****************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * AllDraw Object Sub Objects List When Return from local Scope Become Zero.**************0.12**4**Managements and Cuation Programing**********************(+)
 * Huristic Dosn't Work*******************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * int Order Of Visualization Changed Suddenly******************************************0.12**4**Managements and Cuation Programing**********************(+)
 * int Changes with no movement*********************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Table Not Gate (Inversion of Table List) Doesn’t help to do Normally*******************0.12**4**Managements and Cuation Programing**********************(+)
 * Literally Errors Correction************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * From Arrangements of Things Reaches Suddenly Things Location OccuRS********************0.12**4**Managements and Cuation Programing**********************(+)
 * The Arrangements is Logical************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * The int changes and the arrangements changes are not clearly obvious*****************0.12**4**Managements and Cuation Programing**********************(+)
 * int Changes Solved. no movements*****************************************************0.12**4**Managements and Cuation Programing**********************(+)(-+)
 * Things movements Anomally**************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Chess Rules Anomally*******************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Function Not Work************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Work But the Table is Empty**************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Table is Not Empty But the Movement is Not Logical*************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Clear Dirty Part.**********************************************************************0.88**1**Risk Control********************************************(*)QC-OK.
 * Need to Restricted Approval. Taking a lot of time Thinking Computation*****************0.12**4**Managements and Cuation Programing**********************(+)
 * No movements In Virtualization*********************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Chess Rules Abnormal thinking movements. No movement greater than 2********************0.12**4**Managements and Cuation Programing**********************(+)
 * Problem For Drawing of Thinking Things*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Constant Result**************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * One movements Right .Heuristic Remaining Constant Results******************************0.12**4**Managements and Cuation Programing**********************(+)
 * Constant Heuristic Result**************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Need To Add A Heuristic Useful Another*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Function Does’ Work Allis suddenly Become Zero that Previously Working*******0.12**4**Managements and Cuation Programing**********************(+)
 * No Movement Greater than one order in Computer 'Alice'*********************************0.12**4**Managements and Cuation Programing**********************(+)
 * Tow movements in Computer 'Alice' Of two Different Order int*************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Not Work Greater than 3 Length Count of A************************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'They Don't Really Take care about us'. Misleading in Heuristic King Supported*********0.12**4**Managements and Cuation Programing**********************(+)
 * Non Order Movments*********************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Misleading at Stage three. no illegal movement greater than three**********************0.12**4**Managements and Cuation Programing**********************(+)
 * Thinking Order Misleading**************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Hit Mechanism Malfunctional************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Tow movements At One 'Alice' Order time************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Computer By Computer 'Alice' by 'Bob' Caused to Loop Heuristic.**************0.12**4**Managements and Cuation Programing**********************(+)
 * Learning Automata of  also leads to re loop heuristic***************************0.88**1**Risk Control********************************************(*)QC-OK.
 * Heuristic Learning Automata 'Alice' By 'Bob' Leads to Re loop**************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Things Loop 'Alice' By 'Bob'*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Self 'Check' Detection Failure By 'Alice'***********************************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'Penalty' Value Of All Become zero althouth the one should be non Penalty**************0.88**1**Risk Control********************************************(*)
 * Clone Dosn't Copy All Content of AllDraw Dummy*****************************************0.12**4**Managements and Cuation Programing**********************(+)
 * CheckRemovable By Self King Solved.Penalty Action Misleading****************************0.88**1**Risk Control********************************************(-*)QC-OK.
 * 'Check' Detection Failure***************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Mechanisam Of Order in Predict Failed.*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'Alice' King Virtualization or Table Content of King Misleading************************0.12**4**Managements and Cuation Programing**********************(+)
 * With The All Things Huristic Signing Mechnisam Some Movments become null Table.********0.12**4**Managements and Cuation Programing**********************(+)
 * AStarGreedy First Search Not Working. Misleading MalFunction Virtualization.******************0.12**4**Managements and Cuation Programing**********************(+)
 * AStarGreedy First Table is Null at Bob Order.*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * AStarGreedy First SetVirtualization and Table Misleading By Alice.****************************0.12**4**Managements and Cuation Programing**********************(+)
 * No Reason Logically For MalFunction  Refrigtz.Timer AStarGreedy First Dynamic Refrigtz.Timer.*******************0.12**4**Managements and Cuation Programing**********************(+)
 * AStarGreedyt Thinking Taking a lot of time.***********************************************0.12**4**Managements and Cuation Programing**********************([+]
 * AStarGreedy First Not Work.*******************************************************************0.12**4**Managements and Cuation Programing**********************[+]
 * AStarGreedy First Not Work.Refrigtz.Timer Stop At Greater than 2,3,4,5,6,7 Movments.*******************0.12**4**Managements and Cuation Programing**********************[+]
 * No Reason For MalFunction of AStarGreedytNotFoundHuristicAStarGreedyt.***********************0.12**4**Managements and Cuation Programing**********************[+]
 * Problem Solved.No Reason to NullExeption of AStarGreedytHuristic Algorithm.***************0.88**1**Risk Control********************************************[-*]QC-OK.
 * Function Evaluation Disabled .At Initiate AStarGreedytGenetic Found Sysntax.**************0.88**1**Risk Control********************************************[*]
 * Index Was Out Of Range Exeption Was Not Handled.Colud Not Be Handle.*******************0.12**4**Managements and Cuation Programing**********************{+}
 * No Logical Mechanism To Reconstructe Current AllDraw Objects.**************************0.12**4**Managements and Cuation Programing**********************{+}
 * AStarGreedy First Sysntax is legal and The table is constant table.***************************0.12**4**Managements and Cuation Programing**********************{+}
 * Table Content Empty. No Syntax Exist.**************************************************0.12**4**Managements and Cuation Programing**********************{+}
 * Game Begin From First When the Soldiers Move Ordinary Complete in AStarGreedy First***********0.88**1**Risk Control********************************************{*}QC-OK.
 * New Instatnt Of Program Cuase to Begin Fron First.*************************************0.12**4**Managements and Cuation Programing**********************<+>
 * No Logically Reason For New Game Of Program. New Instatnt Not Detected.****************0.12**4**Managements and Cuation Programing**********************<+>
 * Internal New Instatnt Of FormeRefregitz is MalFunction.********************************0.12**4**Managements and Cuation Programing**********************<+>
 * AStarGreedy First CC Changes to CC Normal Game.***********************************************0.12**4**Managements and Cuation Programing**********************<+>
 * Game CC UnContoroled.******************************************************************0.12**4**Managements and Cuation Programing**********************<+>
 * MalFunction of Syntax and Movments.By Alice and Bob.***********************************0.12**4**Managements and Cuation Programing**********************<+>
 * Threading Solved! The OutOfRangeIndex Not Work.****************************************0.12**4**Managements and Cuation Programing**********************[-+]
 * Vituallization error!No Best Matches between Truth of table content and irtualization**0.12**4**Managements and Cuation Programing**********************[+]
 * Dynamic Programming for Stroring ADraw THISDummy Adraw Value MalFunction.**************0.12**4**Managements and Cuation Programing**********************(+)
 * Order is Constant in Dynamic Programming.**********************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Table MalFunction at Dynamic Programming.At Step 3.************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Some Movments are MalFuncational at Dynamic Programming.*******************************0.12**4**Managements and Cuation Programing**********************(+)
 * Huristic Overlay Tow Part of ADraw and StoreADraw Sections at Different levels Tab Cal.0.12**4**Managements and Cuation Programing**********************(+)
 * Not to be needing again calculation. MalFunction is depend of tow part.****************0.12**4**Managements and Cuation Programing**********************(+)
 * BackWard Loos of Things AllDraw Mechnisam.*********************************************0.88**1**Risk Control********************************************(*)QC-OK.
 * Some Dynamic Programming MalFunction Movments.*****************************************0.88**1**Risk Control********************************************(*)QC-OK.
 * Syntax and Forward and Backward Movments Syntax is MalFunction.************************0.12**4**Managements and Cuation Programing**********************<+>
 * Database and Virtualization Forward and Backward MalFunction***************************0.12**4**Managements and Cuation Programing**********************<+>
 * Reproduction of Thinfs Missleading.****************************************************0.88**1**Risk Control********************************************<*>QC-OK.
 * Reproduction of Some Things are MalFunction Movments.**********************************0.12**4**Managements and Cuation Programing**********************{+}
 * AStarGreedy Count of Dynamic Programming Misleadig.AStarGreedy Operation Count Mal Function.*********0.88**1**Risk Control********************************************(*)QC-OK.
 * Huristic By Alice is MalFunction.******************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * ObjectDanger Identification By Alice is MalFunction.*****************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Check Identification By Alice is MalFunction.*******************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Check Recognized But CheckMate Not Recognized!***********************************************0.12**4**Managements and Cuation Programing**********************(_+)
 * Penalty Regard Mechanism Misleading.***************************************************0.12**4**Managements and Cuation Programing**********************{+}
 * Inhereted LearningAtamata Caused to Shared Parent Allocated Variable.******************0.12**4**Managements and Cuation Programing**********************{+}
 * 'Check' By 'Alice' Not Removed Unreasonably.********************************************0.88**1**Risk Control********************************************{*}QC-OK.
 * AStarGreedyt Huristic Found MalFunction at Check Alice.************************************0.12**4**Managements and Cuation Programing**********************{+}
 * Sortments of ADRAW and Construction is MalFunction at AStarGreedy Dynamic Programming.********0.12**4**Managements and Cuation Programing**********************{+}
 * Huristic AStarGreedy First were Worked Out Unreasonably such Situation(Golden Sword Magic).***0.88**1**Risk Control********************************************{*}QC-OK.
 * Converted 'King' of 'Alice' to 'Elephant' UnReasonably.********************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'Long Game' ; But MalFunction of Game.*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'Always' in Current game is 'Bob'.*****************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Current Table of ADRAW is Correct Table But the Game is MalFunction.*******************0.12**4**Managements and Cuation Programing**********************(+)
 * Move of Current Table AStarGreedy First Huristic found ;found an ovelay in 'Bob' and 'Alice'**0.12**4**Managements and Cuation Programing**********************(+)
 * Current Table in High Level Become Null and prevent of 'LongGame' Strategy.************0.12**4**Managements and Cuation Programing**********************(+)
 * 'LongGame' Become short Undetectably Unreasonably;Clear Store Non Detectably.**********0.88**1**Risk Control********************************************(*)QC-OK.
 * All Draw AStarGreedy First section some movments have not been accurred considerably.*********0.88**1**Risk Control********************************************(*)QC-OK.
 * 'Long Game' Breaks Suddendly without Monitor Caused.***********************************0.12**4**Managements and Cuation Programing**********************{+}
 * Overlay Some Movments of 'Long Game' Breaked.Caused Probability to break.**************0.12**4**Managements and Cuation Programing**********************{+}
 * SomeTimes All Situation of Current Games Become Cleared and No Table Founded.**********0.12**4**Managements and Cuation Programing**********************{+}
 * Gray Soldeir is Only Movmnets and Converts in Huristic and No Move are detectable.*****0.12**4**Managements and Cuation Programing**********************{+}
 * DEEPLY Recursive Tree of Second Version Become in Some Null At Hurristic Finsished.****0.12**4**Managements and Cuation Programing**********************{+}
 * AStarGreedy Huristic Content is Zero. No Calculation of AStarGreedy Huristic Calculation.************0.12**4**Managements and Cuation Programing**********************{+}
 * MalFunction of Dep Huristic Person and MalFunction Movments of CC AStarGreedy Huristic********0.88**1**Risk Control********************************************{*}QC-OK.
 * Mal Function of Reconstruction of AStarGreedy Objects In Initiate AStarGreedy First.*****************0.12**4**Managements and Cuation Programing**********************<+>
 * Hurisic Operantional Have Mal Function Behaviour.**************************************0.12**4**Managements and Cuation Programing**********************<+>
 * Table Zero of AStarGreedy First Huristic Mal Function.****************************************0.12**4**Managements and Cuation Programing**********************<+>
 * AStarGreedy First Initiate Method Result Object Content Mal Function.*************************0.12**4**Managements and Cuation Programing**********************<+>
 * Table Nopt Found Of AStarGreedy First Huristic.Mal Function of Initiate and Huristic.*********0.12**4**Managements and Cuation Programing**********************<+>
 * Table Foundation Successfule. Traversaling of All Tree Not Successfule.****************0.12**4**Managements and Cuation Programing**********************<+>
 * Table Some Movments Intiaiazation Mal Function.****************************************0.12**4**Managements and Cuation Programing**********************{+}
 * BackWard Max Check CheckMate Mechanism For Best Huristic is Unknown**************************0.12**4**Managements and Cuation Programing**********************{+}
 * Minister After Calculation AStarGreedyHuristic At AStarGreedyHuristic becomes Null.******************0.88**1**Risk Control********************************************(*)QC-OK
 * All Objects Possible Movments Not calculating During AStarGreedytSerach Method.***********0.88**1**Risk Control********************************************{*}QC_OK
 * Mechanisam olf AStarGreedytHuristic and Hurisistic is QC-Ok. But Table foundation Illegal.0.88**1**Risk Control********************************************<*>QC-OK
 * Full Game Indexing Parameters Misleading UnLogically.*************************************0.88**1**Risk Control********************************************(*)QC_OK
 * Index out of Range Unlogically at Full Game Soldier Order Brown.**************************0.88**1**Risk Control********************************************<*>QC_OK
 * Execution make zero table but trace make valid table.*************************************0.88**1**Risk Control********************************************{*}Qc-OK.
 * Virtualization need to more hardware capabilities gone to malfunction virtualization.******0.88**1**Risk Control*******************************************{*}QC-BAD.
 * MalFunction on AllDraw Hadeling of Draw Midle Target Motion Graphics.**********************0.88**1**Risk Control*******************************************{*}QC-BAD.
 * ********************************************************************************************************************************************************(+:Sum(63)) 
 * 1394/12/19**********************************************************************************************************************************************(*:Sum(4))
 * ********************************************************************************************************************************************************(-:sum(2)) (_:Sum(0)):2:(+:Sum(3)) (-:Sum(1)) (*:Sum(2)) 3: (+:Sum(4)) (*:Sum(1)) 4:(+:Sum(6))  5:(+:Sum(2)) (-:Sum(1)) 6:(+:Sum(6)) (*:Sum(2)) 7.(+:Sum(2)) (*:Sum(1)) 8.(+:Sum(1)) 9.(+:Sum(4)) (*:Sum(1)) (-:Sum(1)) 10.(+:Sum(4)) (*:Sum(2)) 11.(+:Sum(4)) 12.(+:Sum(2)) (*:Sum(2)) 13.(+:Sum(4)) 14.(+:Sum(2)) (*:Sum(1)) 15.(+:Sum(6)) 16.(+:Sum(2)) 17.(QC-OK.:Sum(13))
 */
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Threading;
using System.Threading.Tasks;
using System.IO;
using System.Diagnostics;
namespace RefrigtzDLL
{

    [Serializable]

    public class AllDraw
    {
        public bool IsCurrentDraw = false;
        public int HaveKilled = 0;
        StringBuilder Space = new StringBuilder("&nbsp;");
        int Spaces = 0;
        bool SetDeptIgnore = false;
        long Now = DateTime.Now.Hour * (36000000 * 24) + DateTime.Now.Minute * 36000000 + DateTime.Now.Second * 600000 + DateTime.Now.Millisecond;
        long Later = DateTime.Now.Hour * (36000000 * 24) + DateTime.Now.Minute * 36000000 + DateTime.Now.Second * 600000 + DateTime.Now.Millisecond;
        StackFrame callStack = new StackFrame(1, true);
        int[,] Tabl = new int[8, 8];
        public int OrderP = 0;
        public static int DepthIterative = 0;
        int PerceptionCount = 0;
        public String OutPutAction = "";
        public static StringBuilder OutPut =new StringBuilder("");
        public static StringBuilder ActionString =new StringBuilder("");
        public static bool ActionStringReady = false;
        //static variable to be Initiate
        List<int[]> ValuableSelfSupported = new List<int[]>();
        public static bool RegardOccurred = false;
        public static int SuppportCountStaticGray = 0;
        public static int SuppportCountStaticBrown = 0;
        int CurrentAStarGredyMax = 0;
        public static int TaskBegin = 0;
        public static int TaskEnd = 0;
        public static String Root = System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]);
        public static int OrderPlate = 1;
        public static bool Blitz = false;
        public static int ConvertedKind = -2;
        public static bool ConvertWait = true;
        public static bool Stockfish = false;
        public static bool Person = true;
        public static bool THISSecradioButtonGrayOrderChecked = false;
        public static bool THISSecradioButtonBrownOrderChecked = false;
        public static String THIScomboBoxMaxLevelText = "";
        public static AllDraw THISDummy = null;
        public static bool StateCP = false;
        public static bool StateCC = false;
        public static int LastRow = -1;
        public static int LastColumn = -1;
        public static int NextRow = -1;
        public static int NextColumn = -1;
        public static int MovmentsNumber = 0;
        public static int MaxAStarGreedyHuristicProgress = 0;
        public static bool EndOfGame = false;
        //Initiate Variables.        
        const int ThresholdBlitz = 10000;
        const int ThresholdFullGame = 20000;
        public bool SetRowColumnFinished = false;
        public static int MinThinkingTreeDepth = Int32.MaxValue;
        static int MaxDuringLevelThinkingCreation = 0;
        public int MaxHuristicxT = Int32.MinValue;
        public bool MovementsAStarGreedyHuristicFoundT = false;
        public bool IgnoreSelfObjectsT = false;
        public bool UsePenaltyRegardMechnisamT = true;
        public bool BestMovmentsT = false;
        public bool PredictHuristicT = true;
        public bool OnlySelfT = false;
        public bool AStarGreedyHuristicT = false;
        int[] Index = { -1, -1, -1, -1, -1, -1 }, jindex = { -1, -1, -1, -1, -1, -1 }, Kind = { -1, -1, -1, -1, -1, -1 };
        public bool ArrangmentsChanged = false;
        public static int AStarGreedytMaxCount = 0;
        public static bool FoundATable = false;
        public static int Less = Int32.MinValue;
        public bool CastlesKing = false;
        List<int[,]> MaxHuristicAStarGreedytBackWardTable = new List<int[,]>();
        public static int increasedProgress = 0;
        public static int CurrentHuristic = Int32.MinValue;
        public static int SignAttack = 1;
        public static int SignObjectDangour = 1;
        public static int SignReducedAttacked = -1;
        public static int SignSupport = 1;
        public static int SignKiller = 1;
        public static int SignMovments = 1;
        public static int SignDistance = -1;
        public static int SignKingSafe = -1;
        public static int SignKingDangour = -1;
        public static bool DrawTable = true;
        public static int[,] TableVeryfy = new int[8, 8];
        public static int MaxAStarGreedy = 1;
        public static int[,] TableVeryfyConst = new int[8, 8];
        public static List<int[,]> TableCurrent = new List<int[,]>();
        public static bool NoTableFound = false;
        public static bool DynamicAStarGreedytPrograming = false;
        public static List<AllDraw> StoreADraw = new List<AllDraw>();
        public static List<int> StoreADrawAStarGreedy = new List<int>();
        public static bool UseDoubleTime = false;
        public static int AStarGreedyiLevelMax;
        public static bool AStarGreadyFirstSearch = true;
        public static String ImageRoot = AllDraw.Root + "\\Images";
        public static String ImagesSubRoot = AllDraw.ImageRoot + "\\Fit\\Small\\";
        public static bool RedrawTable = true;
        public static String SyntaxToWrite = "";
        public static bool SodierConversionOcuured = false;
        public static int SodierMovments = 1;
        public static int ElefantMovments = 1;
        public static int HourseMovments = 1;
        public static int CastleMovments = 1;
        public static int MinisterMovments = 1;
        public static int KingMovments = 1;
        /*public int SodierMidle = 8;
        public int SodierHigh = 16;
        public int ElefantMidle = 2;
        public int ElefantHigh = 4;
        public int HourseMidle = 2;
        public int HourseHight = 4;
        public int CastleMidle = 2;
        public int CastleHigh = 4;
        public int MinisterMidle = 1;
        public int MinisterHigh = 2;
        public int KingMidle = 1;
        public int KingHigh = 2;
        */
        public int SodierMidle = 0;
        public int SodierHigh = 0;
        public int ElefantMidle = 0;
        public int ElefantHigh = 0;
        public int HourseMidle = 0;
        public int HourseHight = 0;
        public int CastleMidle = 0;
        public int CastleHigh = 0;
        public int MinisterMidle = 0;
        public int MinisterHigh = 0;
        public int KingMidle = 0;
        public int KingHigh = 0;
        //ChessPerdict APredict = null;
        int RW = 0;
        int CL = 0;
        int Ki = 0;
        int RW1 = 0;
        int CL1 = 0;
        int Ki1 = 0;
        int MaxLess1 = 0;
        int RW2 = 0;
        int CL2 = 0;
        int Ki2 = 0;
        int MaxLess2 = 0;
        int RW3 = 0;
        int CL3 = 0;
        int Ki3 = 0;
        int MaxLess3 = 0;
        int RW4 = 0;
        int CL4 = 0;
        int Ki4 = 0;
        int MaxLess4 = 0;
        int RW5 = 0;
        int CL5 = 0;
        int Ki5 = 0;
        int MaxLess5 = 0;
        int RW6 = 0;
        int CL6 = 0;
        int Ki6 = 0;
        int MaxLess6 = 0;
        public static int LoopHuristicIndex = 0;
        static List<int> RWList = new List<int>();
        static List<int> ClList = new List<int>();
        static List<int> KiList = new List<int>();
        static public List<int[,]> TableListAction = new List<int[,]>();
        public int Move = 0;
        static public int MouseClick = 0;
        int[] AStarGreedyIndex = new int[20];

        public List<int[,]> TableList = new List<int[,]>();
        public int AStarGreedy = 0;
        public DrawSoldier[] SolderesOnTable = new DrawSoldier[16];
        public DrawElefant[] ElephantOnTable = new DrawElefant[4];
        public DrawHourse[] HoursesOnTable = new DrawHourse[4];
        public DrawCastle[] CastlesOnTable = new DrawCastle[4];
        public DrawMinister[] MinisterOnTable = new DrawMinister[2];
        public DrawKing[] KingOnTable = new DrawKing[2];
        List<int[]> MaxHuristicAStarGreedytBackWard = new List<int[]>();
        const int MaxSoldeirFounded = 2;
        const int MaxElephntFounded = 6;
        const int MaxHourseFounded = 10;
        const int MaxCastlesFounded = 14;
        const int MaxMinisterFounded = 18;
        const int MaxKingFounded = 22;
        [NonSerialized()] public Task ob;
        //Making String datastructure to root variable
        public AllDraw AStarGreedyString = null;
        
        //Error Handling
        static void Log(Exception ex)
        {
            long Time = TimeElapced.TimeNow();
                Object a = new Object();
                lock (a)
                {
                    string stackTrace = ex.ToString();
                    File.AppendAllText(AllDraw.Root + "\\ErrorProgramRun.txt", stackTrace + ": On" + DateTime.Now.ToString()); // path of file where stack trace will be stored.
                }
           AllDraw.OutPut.Append("\r\nALLDrawLog:" + (TimeElapced.TimeNow() - Time).ToString());
        }
        //Determine when a MoveOccured.
        //Note for before move.At most one  moves.
        public static bool IsAeMoveOccured(bool IsMove)
        {
            long Time = TimeElapced.TimeNow();
            bool Is = false;
            if (!IsMove)
            {
                int IsInt = (new Random()).Next(0, 32);
                Is = System.Convert.ToBoolean(IsInt % 2);
            }
            AllDraw.OutPut.Append("\r\nIsAeMoveOccured:" + (TimeElapced.TimeNow() - Time).ToString());
            return Is;
        }
        void TimeEnd()
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            Now = DateTime.Now.Hour * (60000 * 24) + DateTime.Now.Minute * 60000 + DateTime.Now.Second * 1000 + DateTime.Now.Millisecond;
            long Later = Now;
            do
            {
                Later = DateTime.Now.Hour * (60000 * 24) + DateTime.Now.Minute * 60000 + DateTime.Now.Second * 1000 + DateTime.Now.Millisecond;

            } while (Later - Now < 3 * 60000);

            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("TimeEnd:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

        }
        public void SetObjectNumbers(int[,] TabS)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {

                SodierMidle = 0;
                SodierHigh = 0;
                ElefantMidle = 0;
                ElefantHigh = 0;
                HourseMidle = 0;
                HourseHight = 0;
                CastleMidle = 0;
                CastleHigh = 0;
                MinisterMidle = 0;
                MinisterHigh = 0;
                KingMidle = 0;
                KingHigh = 0;
                for (int h = 0; h < 8; h++)
                    for (int s = 0; s < 8; s++)
                    {
                        if (TabS[h, s] == 1)
                        {
                            SodierMidle++;
                            SodierHigh++;
                        }
                        else if (TabS[h, s] == 2)
                        {
                            ElefantMidle++;
                            ElefantHigh++;
                        }
                        else if (TabS[h, s] == 3)
                        {
                            HourseMidle++;
                            HourseHight++;
                        }
                        else if (TabS[h, s] == 4)
                        {
                            CastleMidle++;
                            CastleHigh++;
                        }
                        else if (TabS[h, s] == 5)
                        {
                            MinisterMidle++;
                            MinisterHigh++;
                        }
                        else if (TabS[h, s] == 6)
                        {
                            KingMidle++;
                            KingHigh++;
                        }
                        else
                            if (TabS[h, s] == -1)
                        {
                            SodierHigh++;
                        }
                        else if (TabS[h, s] == -2)
                        {
                            ElefantHigh++;
                        }
                        else if (TabS[h, s] == -3)
                        {
                            HourseHight++;
                        }
                        else if (TabS[h, s] == -4)
                        {
                            CastleHigh++;
                        }
                        else if (TabS[h, s] == -5)
                        {

                            MinisterHigh++;
                        }
                        else if (TabS[h, s] == -6)
                        {
                            KingHigh++;
                        }
                    }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SetObjectNumbers:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

        }
        float[] FoundLocationOfObject(ref int[,] Tabl, int Kind, bool IsGray)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                float[] Location = { -1, -1 };
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                    {
                        if (IsGray)
                        {
                            if (Tabl[i, j] == Kind)
                            {
                                Location[0] = i;
                                Location[1] = j;
                                Tabl[i, j] = 0;

                            }
                        }
                        else
                        {
                            if (Tabl[i, j] * -1 == Kind)
                            {
                                Location[0] = i;
                                Location[1] = j;
                                Tabl[i, j] = 0;

                            }
                        }

                    }
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundLocationOfObject:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Location;

            }
        }
        //Constructor
        public AllDraw(int Order, bool MovementsAStarGreedyHuristicTFou, bool IgnoreSelfObject, bool UsePenaltyRegardMechnisa, bool BestMovment, bool PredictHurist, bool OnlySel, bool AStarGreedyHuris, bool Arrangments)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {

                MaxHuristicxT = Int32.MinValue;
                MovementsAStarGreedyHuristicFoundT = MovementsAStarGreedyHuristicTFou;
                IgnoreSelfObjectsT = IgnoreSelfObject;
                UsePenaltyRegardMechnisamT = UsePenaltyRegardMechnisa;
                BestMovmentsT = BestMovment;
                PredictHuristicT = PredictHurist;
                OnlySelfT = OnlySel;
                AStarGreedyHuristicT = AStarGreedyHuris;
                ArrangmentsChanged = Arrangments;
                Object Om = new Object();
                lock (Om)
                {
                    FoundATable = false;
                }
                CastlesKing = false;
                increasedProgress = 0;
                Object ol = new Object();
                lock (ol)
                {
                    CurrentHuristic = Int32.MinValue;

                    DrawTable = false;

                    TableVeryfy = new int[8, 8];

                    TableVeryfyConst = new int[8, 8];

                    TableCurrent.Clear();

                    NoTableFound = false;

                    DynamicAStarGreedytPrograming = false;

                    UseDoubleTime = false;
                    AStarGreadyFirstSearch = true;
                    ImageRoot = AllDraw.Root + "\\Images";
                    ImagesSubRoot = AllDraw.ImageRoot + "\\Fit\\Small\\";
                }
                RedrawTable = true;
                SodierConversionOcuured = false;
                SodierMovments = 1;
                ElefantMovments = 1;
                HourseMovments = 1;
                CastleMovments = 1;
                MinisterMovments = 1;
                KingMovments = 1;
                /*SodierMidle = 8;
                SodierHigh = 16;
                ElefantMidle = 2;
                ElefantHigh = 4;
                HourseMidle = 2;
                HourseHight = 4;
                CastleMidle = 2;
                CastleHigh = 4;
                MinisterMidle = 1;
                MinisterHigh = 2;
                KingMidle = 1;
                KingHigh = 2;*/
                //APredict = null;
                RW = 0;
                CL = 0;
                Ki = 0;
                RW1 = 0;
                CL1 = 0;
                Ki1 = 0;
                MaxLess1 = 0;
                RW2 = 0;
                CL2 = 0;
                Ki2 = 0;
                MaxLess2 = 0;
                RW3 = 0;
                CL3 = 0;
                Ki3 = 0;
                MaxLess3 = 0;
                RW4 = 0;
                CL4 = 0;
                Ki4 = 0;
                MaxLess4 = 0;
                RW5 = 0;
                CL5 = 0;
                Ki5 = 0;
                MaxLess5 = 0;
                RW6 = 0;
                CL6 = 0;
                Ki6 = 0;
                MaxLess6 = 0;
                LoopHuristicIndex = 0;
                Move = 0;
                MouseClick = 0;
                AStarGreedyIndex = new int[20];
                AStarGreedy = 0;
                SolderesOnTable = null;
                ElephantOnTable = null;
                HoursesOnTable = null;
                CastlesOnTable = null;
                MinisterOnTable = null;

                KingOnTable = null;
                MaxHuristicAStarGreedytBackWard.Clear();

                //Initiayte Locally Variables.
                TableList = new List<int[,]>();
                //APredict = new ChessPerdict(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged//, ref th
                //    );
                OrderP = Order;
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("AllDraw_1:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

            }
        }
        //Clone Copy Method
        public void Clone(AllDraw AA)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {



                if (AA == null)
                {
                    AA = new AllDraw(OrderP, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);
                    AA.TableList.Add(TableList[0]);
                }
                AA.Tabl = new int[8, 8];
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                        AA.Tabl[i, j] = Tabl[i, j];
                AA.OrderP = OrderP;

                AA.PerceptionCount = PerceptionCount;
                AA.OutPutAction = OutPutAction;
                //static variable to be Initiate
                AA.ValuableSelfSupported = new List<int[]>();
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                        AA.ValuableSelfSupported.Add(ValuableSelfSupported[i]);
                AA.CurrentAStarGredyMax = CurrentAStarGredyMax;
                for (var i = 0; i < 6; i++)
                    AA.Index[i] = Index[i];
                for (var i = 0; i < 6; i++)
                    AA.jindex[i] = jindex[i];
                for (var i = 0; i < 6; i++)
                    AA.Kind[i] = Kind[i];
                if (AStarGreedyString != null)
                    AStarGreedyString.Clone(AA.AStarGreedyString);
                if (TableList.Count == 1)
                    SetObjectNumbers(TableList[0]);
                MaxHuristicxT = Int32.MinValue;
                AA.MovementsAStarGreedyHuristicFoundT = MovementsAStarGreedyHuristicFoundT;
                AA.IgnoreSelfObjectsT = IgnoreSelfObjectsT;
                AA.UsePenaltyRegardMechnisamT = UsePenaltyRegardMechnisamT;
                AA.BestMovmentsT = BestMovmentsT;
                AA.PredictHuristicT = PredictHuristicT;
                AA.OnlySelfT = OnlySelfT;
                AA.AStarGreedyHuristicT = AStarGreedyHuristicT;
                AA.ArrangmentsChanged = ArrangmentsChanged;
                AA.CastlesKing = CastlesKing;


                AA.SodierMidle = SodierMidle;
                AA.SodierHigh = SodierHigh;
                AA.ElefantMidle = ElefantMidle;
                AA.ElefantHigh = ElefantHigh;
                AA.HourseMidle = HourseMidle;
                AA.HourseHight = HourseHight;
                AA.CastleMidle = CastleMidle;
                AA.CastleHigh = CastleHigh;
                AA.MinisterMidle = MinisterMidle;
                AA.MinisterHigh = MinisterHigh;
                AA.KingMidle = KingMidle;
                AA.KingHigh = KingHigh;
                //Initiate a new class object and clone a copy.

                AA.SolderesOnTable = new DrawSoldier[SodierHigh];
                AA.ArrangmentsChanged = ArrangmentsChanged;
                for (var i = 0; i < SodierHigh; i++)
                {
                    
                        SolderesOnTable[i].Clone(ref AA.SolderesOnTable[i]);
                   
                }
                AA.ElephantOnTable = new DrawElefant[ElefantHigh];
                for (var i = 0; i < ElefantHigh; i++)
                {
                    
                        ElephantOnTable[i].Clone(ref AA.ElephantOnTable[i]);

                   
                }
                AA.HoursesOnTable = new DrawHourse[HourseHight];
                for (var i = 0; i < HourseHight; i++)
                {
                    
                        HoursesOnTable[i].Clone(ref AA.HoursesOnTable[i]);

                   
                }
                AA.CastlesOnTable = new DrawCastle[CastleHigh];
                for (var i = 0; i < CastleHigh; i++)
                {
                    
                        CastlesOnTable[i].Clone(ref AA.CastlesOnTable[i]);

                   
                }
                AA.MinisterOnTable = new DrawMinister[MinisterHigh];
                for (var i = 0; i < MinisterHigh; i++)
                {
                    
                        MinisterOnTable[i].Clone(ref AA.MinisterOnTable[i]);

                   
                }
                AA.KingOnTable = new DrawKing[KingHigh];
                for (var i = 0; i < KingHigh; i++)
                {
                    
                        KingOnTable[i].Clone(ref AA.KingOnTable[i]);

                   
                }
                AA.AStarGreedy = AStarGreedy;

                if (AA.TableList.Count > 0)
                    AA.TableList.Clear();
                for (var i = 0; i < TableList.Count; i++)
                    AA.TableList.Add(TableList[i]);
                if (AA.TableList.Count > 0)
                    AA.SetObjectNumbers(AA.TableList[0]);
                AA.AStarGreedy = AStarGreedy;
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Clone:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //aBlanck Constructor
        public AllDraw(int Order, bool MovementsAStarGreedyHuristicTFou, bool IgnoreSelfObject, bool UsePenaltyRegardMechnisa, bool BestMovment, bool PredictHurist, bool OnlySel, bool AStarGreedyHuris, bool Arrangments, AllDraw THi)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                OrderP = Order;
                MaxHuristicxT = Int32.MinValue;
                MovementsAStarGreedyHuristicFoundT = MovementsAStarGreedyHuristicTFou;
                IgnoreSelfObjectsT = IgnoreSelfObject;
                UsePenaltyRegardMechnisamT = UsePenaltyRegardMechnisa;
                BestMovmentsT = BestMovment;
                PredictHuristicT = PredictHurist;
                OnlySelfT = OnlySel;
                AStarGreedyHuristicT = AStarGreedyHuris;
                if (!Arrangments)
                    ArrangmentsChanged = Arrangments;
                else
                    ArrangmentsChanged = Arrangments;
                Object Om = new Object();
                lock (Om)
                {
                    AStarGreedytMaxCount = 0;
                }
                Object Omm = new Object();
                lock (Omm)
                {
                    FoundATable = false;
                }
                CastlesKing = false;
                increasedProgress = 0;
                Object ol = new Object();
                lock (ol)
                {
                    CurrentHuristic = Int32.MinValue;

                    DrawTable = false;

                    TableVeryfy = new int[8, 8];

                    TableVeryfyConst = new int[8, 8];

                    TableCurrent.Clear();

                    NoTableFound = false;

                    DynamicAStarGreedytPrograming = false;
                    UseDoubleTime = false;
                    AStarGreadyFirstSearch = true;
                    ImageRoot = AllDraw.Root + "\\Images";
                    ImagesSubRoot = AllDraw.ImageRoot + "\\Fit\\Small\\";
                }
                RedrawTable = true;
                SodierConversionOcuured = false;
                SodierMovments = 1;
                ElefantMovments = 1;
                HourseMovments = 1;
                CastleMovments = 1;
                MinisterMovments = 1;
                KingMovments = 1;
                SodierMidle = 8;
                SodierHigh = 16;
                ElefantMidle = 2;
                ElefantHigh = 4;
                HourseMidle = 2;
                HourseHight = 4;
                CastleMidle = 2;
                CastleHigh = 4;
                MinisterMidle = 1;
                MinisterHigh = 2;
                KingMidle = 1;
                KingHigh = 2;

                //APredict = null;
                RW = 0;
                CL = 0;
                Ki = 0;
                RW1 = 0;
                CL1 = 0;
                Ki1 = 0;
                MaxLess1 = 0;
                RW2 = 0;
                CL2 = 0;
                Ki2 = 0;
                MaxLess2 = 0;
                RW3 = 0;
                CL3 = 0;
                Ki3 = 0;
                MaxLess3 = 0;
                RW4 = 0;
                CL4 = 0;
                Ki4 = 0;
                MaxLess4 = 0;
                RW5 = 0;
                CL5 = 0;
                Ki5 = 0;
                MaxLess5 = 0;
                RW6 = 0;
                CL6 = 0;
                Ki6 = 0;
                MaxLess6 = 0;
                LoopHuristicIndex = 0;
                Move = 0;
                MouseClick = 0;
                AStarGreedyIndex = new int[20];
                AStarGreedy = 0;
                /*SolderesOnTable = null;
                ElephantOnTable = null;
                HoursesOnTable = null;
                CastlesOnTable = null;
                MinisterOnTable = null;
                KingOnTable = null;
                */
                Object OOOO = new Object();
                lock (OOOO)
                {
                    MaxDuringLevelThinkingCreation = System.Convert.ToInt32(AllDraw.THIScomboBoxMaxLevelText);
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("AllDraw_2:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //Check For Thinking Of Current Item Movments Finished.
        public bool AllCurrentAStarGreedyThinkingFinished(AllDraw Dum, int i, int j, int Kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //For All kind of Current Thinking depend of current type consider finshing state thinking.
                bool Finished = false;
                {
                    //For Soldier
                    if (Kind == 1)
                    {

                        if (Dum.SolderesOnTable[i].SoldierThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Elephant
                    else if (Kind == 2)
                    {
                        if (Dum.ElephantOnTable[i].ElefantThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Hourse.
                    else if (Kind == 3)
                    {
                        if (Dum.HoursesOnTable[i].HourseThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Castles.
                    else if (Kind == 4)
                    {
                        if (Dum.CastlesOnTable[i].CastleThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Minsters.
                    else if (Kind == 5)
                    {
                        if (Dum.MinisterOnTable[i].MinisterThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Kings.
                    else if (Kind == 6)
                    {
                        if (Dum.KingOnTable[i].KingThinking[0].ThinkingFinished)
                            return true;
                    }
                }
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("AllCurrentAStarGreedyThinkingFinished:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Finished;

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("AllDraw_2:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        /*void SetRowColumn(int Kind, int Section)
        {
            if (Kind == 1)
            {
                if (Section == 1)
                { }
                else
                { }

            }
            else


if (Kind == 2)
            {
                if (Section == 1)
                { }
                else
                { }

            }
            else
            if (Kind == 3)
            {
                if (Section == 1)
                { }
                else
                { }

            }
            else
            if (Kind == 4)
            {
                if (Section == 1)
                { }
                else
                { }

            }
            else
            if (Kind == 5)
            {
                if (Section == 1)
                { }
                else
                { }

            }
            else
            if (Kind == 6)
            {
                if (Section == 1)
                { }
                else
                { }

            }

        }*/
        //Rearrange AllDraw Object Content.
        public void SetRowColumn(int index)
        {
            int Dummy = OrderP;
            AllDraw thisAStarGreedyString = new AllDraw(OrderP, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged); thisAStarGreedyString = this.AStarGreedyString;
            //long Time = TimeElapced.TimeNow(); Spaces++;
            Object a1 = new Object();
            lock (a1)
            {

                SetObjectNumbers(TableList[0]);

                int So1 = 0;
                int So2 = SodierMidle;
                int El1 = 0;
                int El2 = ElefantMidle;
                int Ho1 = 0;
                int Ho2 = HourseMidle;
                int Br1 = 0;
                int Br2 = CastleMidle;
                int Mi1 = 0;
                int Mi2 = MinisterMidle;
                int Ki1 = 0;
                int Ki2 = KingMidle;


                SetRowColumnFinished = false;

                Move = 0;
                //Intiate Dummy Variables.
                //When Conversion Occured.
                SolderesOnTable = new DrawSoldier[SodierHigh];
                ElephantOnTable = new DrawElefant[ElefantHigh];
                HoursesOnTable = new DrawHourse[HourseHight];
                CastlesOnTable = new DrawCastle[CastleHigh];
                MinisterOnTable = new DrawMinister[MinisterHigh];
                KingOnTable = new DrawKing[KingHigh];
                AllDraw.SodierConversionOcuured = false;

                //When Table Exist.
                if (TableList.Count > 0)
                {
                    //For Every Table Things.
                    for (int Column = 0; Column < 8; Column++)
                        for (int Row = 0; Row < 8; Row++)
                        {
                            /* if (!TableZero(Tabl))
                             {

                                 if (TableEqual(CloneATable(TableList[index]), Tabl))
                                     return;
                             }*/
                            if (CloneATable(TableList[index])[Row, Column] == 0)
                                continue;
                            //When Things are Soldiers.
                            if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 1)
                            {
                                //Determine int
                                Color a;

                                if (CloneATable(TableList[index])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }     //When int is Gray. 
                                if (a == Color.Gray)
                                {

                                    //if (SolderesOnTable[So1] != null)
                                    //SolderesOnTable[So1].Dispose();
                                    //Construct Soder Gray.
                                    SolderesOnTable[So1] = new DrawSoldier(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, So1);

                                    BlitzNotValidFullGameThinkingTreePartThree(So1, OrderP, 1);

                                    //Increase So1.
                                    So1++;
                                    if (So1 > SodierMidle)
                                    {
                                        SodierMidle++;
                                        SodierHigh++;
                                    }



                                }
                                //When int is Brown
                                else
                                {

                                    //if (SolderesOnTable[So2] != null)
                                    // SolderesOnTable[So2].Dispose();
                                    //Construct Soldeir Brown.
                                    SolderesOnTable[So2] = new DrawSoldier(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, So2);

                                    BlitzNotValidFullGameThinkingTreePartThree(So2, OrderP, 1);
                                    //Increase So2.
                                    So2++;
                                    if (So2 > SodierHigh)
                                        SodierHigh++;


                                }
                            }
                            else //For Elephant Objects.
                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 2)
                            {
                                //Initiate Local Variables.
                                Color a;
                                if (CloneATable(TableList[index])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }    //If Gray Elepahnt
                                if (a == Color.Gray)
                                {

                                    //if (ElephantOnTable[El1] != null)
                                    // ElephantOnTable[El1].Dispose();

                                    //Construction of Draw Object.
                                    ElephantOnTable[El1] = new DrawElefant(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, El1);
                                    BlitzNotValidFullGameThinkingTreePartThree(El1, OrderP, 2);
                                    //Increament of Gray Index.
                                    El1++;
                                    //If New Object Increament Gray Objects.
                                    if (El1 > ElefantMidle)
                                    {
                                        ElefantMidle++;
                                        ElefantHigh++;
                                    }

                                }
                                else//For Brown Elephant .Objects
                                {

                                    //if (ElephantOnTable[El2] != null)
                                    // ElephantOnTable[El2].Dispose();

                                    //Construction of Draw Brown Elephant Object. 
                                    ElephantOnTable[El2] = new DrawElefant(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, El2);
                                    BlitzNotValidFullGameThinkingTreePartThree(El2, OrderP, 2);
                                    //Increament of Index.
                                    El2++;
                                    //When New Brown Elephant Object Increament of Index.
                                    if (El2 > ElefantHigh)
                                        ElefantHigh++;


                                }
                            }
                            else//For Hourse Objects.
                                    if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 3)
                            {
                                //Initiate Local Varibale and int.
                                Color a;
                                if (CloneATable(TableList[index])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }                //If Gray Hourse.
                                if (a == Color.Gray)
                                {


                                    // if (HoursesOnTable[Ho1] != null)
                                    // HoursesOnTable[Ho1].Dispose();

                                    //Construction of Draw Brown Hourse.
                                    HoursesOnTable[Ho1] = new DrawHourse(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Ho1);
                                    BlitzNotValidFullGameThinkingTreePartThree(Ho1, OrderP, 3);
                                    //Increament of Index.
                                    Ho1++;
                                    //when There is New Gray Hourse Increase.
                                    if (Ho1 > HourseMidle)
                                    {
                                        HourseMidle++;
                                        HourseHight++;
                                    }

                                }//For Brown Hourses.
                                else
                                {

                                    //if (HoursesOnTable[Ho2] != null)
                                    //  HoursesOnTable[Ho2].Dispose();

                                    //Construction of Draw Brown Hourse.
                                    HoursesOnTable[Ho2] = new DrawHourse(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Ho2);
                                    BlitzNotValidFullGameThinkingTreePartThree(Ho2, OrderP, 3);
                                    //Increament of Index.
                                    Ho2++;
                                    //When New Brown Hourse Exist Exist Index.
                                    if (Ho2 > HourseHight)
                                        HourseHight++;

                                }
                            }
                            else//For Castles Objects.
                                        if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 4)
                            {
                                //Initiate of Local Variables.
                                Color a;
                                if (CloneATable(TableList[index])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }         //For Gray int.
                                if (a == Color.Gray)
                                {


                                    //if (CastlesOnTable[Br1] != null)
                                    //CastlesOnTable[Br1].Dispose();

                                    //Construction of New Draw Gray Castles.
                                    CastlesOnTable[Br1] = new DrawCastle(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Br1);
                                    BlitzNotValidFullGameThinkingTreePartThree(Br1, OrderP, 4);
                                    //Increamnt of Index.
                                    Br1++;
                                    //When New Gray Briges Increamnt Max Index.
                                    if (Br1 > CastleMidle)
                                    {
                                        CastleMidle++;
                                        CastleHigh++;
                                    }

                                }//For Brown Castles.
                                else
                                {

                                    //if (CastlesOnTable[Br2] != null)
                                    //CastlesOnTable[Br2].Dispose();

                                    //Construction Draw of New Brown Castles.
                                    CastlesOnTable[Br2] = new DrawCastle(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Br2);
                                    BlitzNotValidFullGameThinkingTreePartThree(Br2,OrderP, 4);
                                    //Increament of Index.
                                    Br2++;
                                    //wehn Brown New Castles Detected Increament Max Index.
                                    if (Br2 > CastleHigh)
                                        CastleHigh++;

                                }
                            }
                            else//For Minister Objects.
                                            if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 5)
                            {
                                //Initiate Local int Varibales.
                                Color a;
                                if (CloneATable(TableList[index])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }     //For Gray ints.
                                if (a == Color.Gray)
                                {



                                    //if (MinisterOnTable[Mi1] != null)
                                    // MinisterOnTable[Mi1].Dispose();

                                    //construction of new draw Gray Minster.
                                    MinisterOnTable[Mi1] = new DrawMinister(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Mi1);
                                    BlitzNotValidFullGameThinkingTreePartThree(Mi1, OrderP, 5);
                                    //Increament of Index.
                                    Mi1++;
                                    //Wehn New Gray Minster Detected Increament Max Indexes.
                                    if (Mi1 > MinisterMidle)
                                    {
                                        MinisterMidle++;
                                        MinisterHigh++;
                                    }


                                }//For Brown  ints.
                                else
                                {

                                    //if (MinisterOnTable[Mi2] != null)
                                    // MinisterOnTable[Mi2].Dispose();

                                    //Construction of New Draw Brown Minster.
                                    MinisterOnTable[Mi2] = new DrawMinister(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Mi2);
                                    BlitzNotValidFullGameThinkingTreePartThree(Mi2, OrderP, 5);
                                    //Increament Index.
                                    Mi2++;
                                    //When New Brown Minister Detected Increament Max Index.
                                    if (Mi2 > MinisterHigh)
                                        MinisterHigh++;

                                }
                            }
                            else//for King Objects.        
                            if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 6)
                            {
                                //Initiate Of int.
                                Color a;
                                if (CloneATable(TableList[index])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }     //int consideration.
                                if (a == Color.Gray)
                                {


                                    //if (KingOnTable[Ki1] != null)
                                    //KingOnTable[Ki1].Dispose();

                                    //Construction of New Draw Gray King.
                                    KingOnTable[Ki1] = new DrawKing(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Ki1);
                                    BlitzNotValidFullGameThinkingTreePartThree(Ki1, OrderP, 6);
                                    //Increament of Index.
                                    Ki1++;
                                    //when New Draw  Object Detected Increament Max Index.
                                    if (Ki1 > KingMidle)
                                    {
                                        KingMidle++;
                                        KingHigh++;

                                    }

                                }//For Brown King int
                                else
                                {

                                    //if (KingOnTable[Ki2] != null)
                                    // KingOnTable[Ki2].Dispose();

                                    //Construction of New Draw King Brown Object.
                                    KingOnTable[Ki2] = new DrawKing(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Ki2);
                                    BlitzNotValidFullGameThinkingTreePartThree(Ki2, OrderP, 6);
                                    //Increament of Index.
                                    Ki2++;
                                    //When New Object Detected Increament Of Brown King Max Index.
                                    if (Ki2 > KingHigh)
                                        KingHigh++;

                                }

                            }
                        }

                    //Make Empty Remaining.


                }



                SetObjectNumbers(TableList[0]);
                for (var i = So1; i < SodierMidle; i++)
                    SolderesOnTable[i] = null;

                for (var i = So2; i < SodierHigh; i++)
                    SolderesOnTable[i] = null;

                for (var i = El1; i < ElefantMidle; i++)
                    ElephantOnTable[i] = null;

                for (var i = El2; i < ElefantHigh; i++)
                    ElephantOnTable[i] = null;

                for (var i = Ho1; i < HourseMidle; i++)
                    HoursesOnTable[i] = null;

                for (var i = Ho2; i < HourseHight; i++)
                    HoursesOnTable[i] = null;

                for (var i = Br1; i < CastleMidle; i++)
                    CastlesOnTable[i] = null;

                for (var i = Br2; i < CastleHigh; i++)
                    CastlesOnTable[i] = null;

                for (var i = Mi1; i < MinisterMidle; i++)
                    MinisterOnTable[i] = null;

                for (var i = Mi2; i < MinisterHigh; i++)
                    MinisterOnTable[i] = null;

                for (var i = Ki1; i < KingMidle; i++)
                    KingOnTable[i] = null;

                for (var i = Ki2; i < KingHigh; i++)
                    KingOnTable[i] = null;
                if (TableList.Count > 0)
                {
                    for (var i = 0; i < 8; i++)
                        for (var j = 0; j < 8; j++)
                            Tabl[i, j] = TableList[0][i, j];
                }
                SetRowColumnFinished = true;
            }
            //{ AllDraw.OutPut.Append("\r\n"); for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space); AllDraw.OutPut.Append("SetRowColumn:" + (TimeElapced.TimeNow() - Time).ToString()); }
            Spaces--;
            this.AStarGreedyString = thisAStarGreedyString;
            OrderP = Dummy;
        }
        void SetRowColumnFinishedWait()
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                do
                {

                    Thread.Sleep(2);
                } while (!SetRowColumnFinished);
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SetRowColumnFinishedWait:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //Max Index List Of Huristic AStarGreedy First Method.
        public void BeginIndexFoundingMaxLessofMaxList(int ListIndex, List<int> Founded, ref int LessB)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //When There is Maximum Huristsic AStar Gredy Back Ward in Blitz Games.
                if (MaxHuristicAStarGreedytBackWard.Count > 0)
                {
                    //When List Index is LessB than Founded.
                    if (ListIndex < MaxHuristicAStarGreedytBackWard.Count)
                        return;
                    //Initiate Variable.
                    bool Added = false;
                    //Recursive Method.
                    BeginIndexFoundingMaxLessofMaxList(ListIndex++, Founded, ref LessB);
                    //When Greater LessB of First index Object Found.
                    if (LessB < MaxHuristicAStarGreedytBackWard[ListIndex][1])
                    {
                        LessB = MaxHuristicAStarGreedytBackWard[ListIndex][1];
                        Added = true;

                        Founded.Add(2);
                    }
                    //When Greater LessB of Second index Object Found.
                    if (LessB < MaxHuristicAStarGreedytBackWard[ListIndex][5])
                    {
                        LessB = MaxHuristicAStarGreedytBackWard[ListIndex][5];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(6);
                    }
                    //When Greater LessB of Third index Object Found.
                    if (LessB < MaxHuristicAStarGreedytBackWard[ListIndex][9])
                    {
                        LessB = MaxHuristicAStarGreedytBackWard[ListIndex][9];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(10);
                    }
                    //When Greater LessB of Foutrh index Object Found.
                    if (LessB < MaxHuristicAStarGreedytBackWard[ListIndex][13])
                    {
                        LessB = MaxHuristicAStarGreedytBackWard[ListIndex][13];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(14);
                    }
                    //When Greater LessB of Fifth index Object Found.
                    if (LessB < MaxHuristicAStarGreedytBackWard[ListIndex][18])
                    {
                        LessB = MaxHuristicAStarGreedytBackWard[ListIndex][18];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(19);
                    }
                    //When Greater LessB of Sith index Object Found.
                    if (LessB < MaxHuristicAStarGreedytBackWard[ListIndex][22])
                    {
                        LessB = MaxHuristicAStarGreedytBackWard[ListIndex][22];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(23);
                    }
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BeginIndexFoundingMaxLessofMaxList:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //Method for Check of Existence of Checkmate less than for checked mate.
        bool IsToCheckMateHasLessDeeperThanForCheckMate(AllDraw A, int Order, ref int ToCheckMate, ref int ForCheckMate, int AStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {

                //Initiate variables.
                bool AA = false;
                int CDummy = Order;
                //For Gray One.
                if (Order== 1)
                {

                    //For Solderis.
                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            

                                //When there is Brown checked mate.
                                if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == -1)
                                {
                                    //Set.
                                    ForCheckMate = AStarGreedy;
                                    if (ToCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                                else
                                {
                                    //When there is Gray Checked mate.
                                    if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == 1)
                                    {
                                        ToCheckMate = AStarGreedy;
                                        if (ForCheckMate >= 0)
                                            if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                                AA = true;
                                    }
                                }
                           
                            Order *= -1;
                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            
                                //When there is Brown checked mate.
                                if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == -1)
                                {
                                    ForCheckMate = AStarGreedy;
                                    if (ToCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;



                                }
                                else
                                {
                                    //When there is Gray Checked mate.
                                    if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == 1)
                                    {
                                        ToCheckMate = AStarGreedy;
                                        if (ForCheckMate >= 0)
                                            if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                                AA = true;
                                    }
                                }
                           
                            Order *= -1;
                            for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {

                            
                                //When there is Brown checked mate.
                                if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == -1)
                                {
                                    ForCheckMate = AStarGreedy;
                                    if (ToCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                                else
                                {
                                    //When there is Gray Checked mate.
                                    if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == 1)
                                    {
                                        ToCheckMate = AStarGreedy;
                                        if (ForCheckMate >= 0)
                                            if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                                AA = true;
                                    }
                                }
                           
                            Order *= -1;
                            for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            
                                //When there is Brown checked mate.
                                if (A.CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy == -1)
                                {
                                    ForCheckMate = AStarGreedy;
                                    if (ToCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                                else
                                {
                                    //When there is Gray Checked mate.
                                    if (A.CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy == 1)
                                    {
                                        ToCheckMate = AStarGreedy;
                                        if (ForCheckMate >= 0)
                                            if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                                AA = true;
                                    }
                                }
                           
                            Order *= -1;
                            for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            
                                //When there is Brown checked mate.
                                if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == -1)
                                {
                                    ForCheckMate = AStarGreedy;
                                    if (ToCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                                else
                                {
                                    //When there is Gray Checked mate.
                                    if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == 1)
                                    {
                                        ToCheckMate = AStarGreedy;
                                        if (ForCheckMate >= 0)
                                            if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                                AA = true;


                                    }
                                }
                           
                            Order *= -1;
                            for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            
                                //When there is Brown checked mate.
                                if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == -1)
                                {
                                    ForCheckMate = AStarGreedy;
                                    if (ToCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                                else
                                {
                                    //When there is Gray Checked mate.
                                    if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == 1)
                                    {
                                        ToCheckMate = AStarGreedy;
                                        if (ForCheckMate >= 0)
                                            if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                                AA = true;
                                    }
                                }
                           
                            Order *= -1;
                            for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                }
                else
                {
                    //ChessRules.CurrentOrder = -1;
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {

                            
                                //When there is Brown checked mate.
                                if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == -1)
                                {
                                    ForCheckMate = AStarGreedy;
                                    if (ToCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                                else
                                {
                                    //When there is Gray Checked mate.
                                    if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == 1)
                                    {
                                        ToCheckMate = AStarGreedy;
                                        if (ForCheckMate >= 0)
                                            if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                                AA = true;
                                    }
                                }
                           
                            Order *= -1;
                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            
                                //When there is Brown checked mate.
                                if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == -1)
                                {
                                    ForCheckMate = AStarGreedy;
                                    if (ToCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                                else
                                {
                                    //When there is Gray Checked mate.
                                    if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == 1)
                                    {
                                        ToCheckMate = AStarGreedy;
                                        if (ForCheckMate >= 0)
                                            if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                                AA = true;
                                    }
                                }
                           
                            Order *= -1;
                            for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {

                            
                                //When there is Brown checked mate.
                                if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == -1)
                                {
                                    ForCheckMate = AStarGreedy;
                                    if (ToCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                                else
                                {
                                    //When there is Gray Checked mate.
                                    if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == 1)
                                    {
                                        ToCheckMate = AStarGreedy;
                                        if (ForCheckMate >= 0)
                                            if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                                AA = true;
                                    }
                                }
                           
                            Order *= -1;
                            for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            
                                //When there is Brown checked mate.
                                if (A.CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy == -1)
                                {
                                    ForCheckMate = AStarGreedy;
                                    if (ToCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                                else
                                {
                                    //When there is Gray Checked mate.
                                    if (A.CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy == 1)
                                    {
                                        ToCheckMate = AStarGreedy;
                                        if (ForCheckMate >= 0)
                                            if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                                AA = true;
                                    }
                                }
                           
                            Order *= -1;
                            for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            
                                //When there is Brown checked mate.
                                if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == -1)
                                {
                                    ForCheckMate = AStarGreedy;
                                    if (ToCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                                else
                                {
                                    //When there is Gray Checked mate.
                                    if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == 1)
                                    {
                                        ToCheckMate = AStarGreedy;
                                        if (ForCheckMate >= 0)
                                            if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                                AA = true;
                                    }
                                }
                           

                            Order *= -1;
                            for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = KingMidle; i < KingHigh; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            
                                //When there is Brown checked mate.
                                if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == -1)
                                {
                                    ForCheckMate = AStarGreedy;
                                    if (ToCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                                else
                                {
                                    //When there is Gray Checked mate.
                                    if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == 1)
                                    {
                                        ToCheckMate = AStarGreedy;
                                        if (ForCheckMate >= 0)
                                            if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                                AA = true;
                                    }
                                }

                           
                            Order *= -1;
                            for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }

                }
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsToCheckMateHasLessDeeperThanForCheckMate:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                ChessRules.CurrentOrder = CDummy;
                return AA;
            }
        }
        //When Penalty Regard Branches expanded to sub branches.
        void IsPenaltyRegardCheckMateAtBranch(int Order, ref int Do, AllDraw Base)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                int CDummy = ChessRules.CurrentOrder;
                int COrder = Order;
                //For Gray Order.
                if (Order== 1)
                {
                    ChessRules AA = null;

                    //ChessRules.CurrentOrder = 1;
                    //For  Soldeirs.
                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            

                                //Create Rules Objects For Soldiers.
                                AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, SolderesOnTable[i].SoldierThinking[0].TableListSolder[j][SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]]
                                    , SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]
                                    , Order
                                    , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0]
                                    , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]);
                                //When CheckMate Occured for Current Sodiers
                                if (AA.CheckMate(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Order))
                                    //When Self CheckMate
                                    if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Return Ignore
                                        Do = -1;
                                        //Set Superposition.
                                        SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = -1;
                                        //Penalty Subbranchs.
                                        MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                    else
                                    {
                                        //When Enemy CheckMate
                                        if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                        {
                                            //Set Regard and Set Movements.
                                            Do = 1;
                                            //Regard Subbranchs.
                                            MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                            //Set Superpostion.
                                            SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = 1;
                                        }
                                    }
                           
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Subbranchs.
                                for (var ii = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                    SolderesOnTable[ii].SoldierThinking[0].AStarGreedy[i].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }

                        }
                    //For Elephant.
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            
                                //Create Elephant Rules.
                                AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ElephantOnTable[i].ElefantThinking[0].TableListElefant[j][ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0], ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]]
                                , ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]
                                , Order
                                , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0]
                                , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]);
                                //When CheckMate Occured for Current Elephant.
                                if (AA.CheckMate(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Order))
                                    //For Self Order CheckMate.
                                    if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Penalty Ignore.
                                        Do = -1;
                                        //Set Superposition.
                                        ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = -1;
                                        //Penalty Subbranchs.
                                        MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                    else
                                    {
                                        //For Enemy Order CheckMate.
                                        if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                        {
                                            //Set Regard Continue.
                                            Do = 1;
                                            //Regard Subolders.
                                            MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                            //Set Superposition.
                                            ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = 1;
                                        }
                                    }
                           
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Subbranchs.
                                for (var ii = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                    ElephantOnTable[ii].ElefantThinking[0].AStarGreedy[i].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //For Hourse.
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {

                            
                                //Set Hourse Rules Objects.
                                AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, HoursesOnTable[i].HourseThinking[0].TableListHourse[j][HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0], HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]]
                                , HoursesOnTable[i].HourseThinking[0].TableListHourse[j]
                                , Order
                                , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0]
                                , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]);
                                //When CheckMate Occured.
                                if (AA.CheckMate(HoursesOnTable[i].HourseThinking[0].TableListSolder[j], Order))
                                    //For Self CheckMate.
                                    if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Ignore.
                                        Do = -1;
                                        //Set Superposition.
                                        HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = -1;
                                        //Penalty Subbranchs.
                                        MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                    else
                                    {
                                        //For Enemy CheckMate.
                                        if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                        {
                                            //Set Regard.
                                            Do = 1;
                                            //Superposition.
                                            HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = 1;
                                            //Set Regard For Sub Branches.
                                            MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                        }
                                    }
                           
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Sub branchs For Hourse.
                                for (var ii = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //For Gray Briges.
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            
                                //Castles Gray Rules.
                                AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, CastlesOnTable[i].CastleThinking[0].TableListCastle[j][CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][0], CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][1]]
                                , CastlesOnTable[i].CastleThinking[0].TableListCastle[j]
                                , Order
                                , CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][0]
                                , CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][1]);
                                //When Current Gray Castles CheckMate.
                                if (AA.CheckMate(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Order))
                                    //For Self CheckMate
                                    if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Penalty Ignore.
                                        Do = -1;
                                        //Set Superposition.
                                        CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy = -1;
                                        //Penalty Sub branchs.
                                        MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                    else
                                    {
                                        //For Enemy CheckMate.
                                        if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                        {
                                            //Set Regard.
                                            Do = 1;
                                            //Superpoistion.
                                            CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy = 1;
                                            //Set Regard Subbranchs.
                                            MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                        }
                                    }
                           
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Castles Gray Subbranchs.
                                
                                    for (var ii = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                               
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //For Ministers Gray.
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            
                                //Minister Gray Rules.
                                AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, MinisterOnTable[i].MinisterThinking[0].TableListMinister[j][MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0], MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]]
                                , MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]
                                , Order
                                , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0]
                                , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]);
                                //When M ate Occured in Minister Gray.
                                if (AA.CheckMate(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Order))
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Penalty Ignore.
                                        Do = -1;
                                        //Superpostion.
                                        MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = -1;
                                        //Penalty Subbranchs.
                                        MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                    else
                                    {
                                        //For Enemy CheckMate.
                                        if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                        {
                                            //Regard Setting.
                                            Do = 1;
                                            //Superpoistion.
                                            MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = 1;
                                            //Set Subbranchs Regard.
                                            MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                        }
                                    }
                           
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Gray Ministers Subbranchs.
                                
                                    for (var ii = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                               
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //For Gray King.
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            
                                //Gray King Rules.
                                AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, KingOnTable[i].KingThinking[0].TableListKing[j][KingOnTable[i].KingThinking[0].RowColumnKing[j][0], KingOnTable[i].KingThinking[0].RowColumnKing[j][1]]
                                , KingOnTable[i].KingThinking[0].TableListKing[j]
                                , Order
                                , KingOnTable[i].KingThinking[0].RowColumnKing[j][0]
                                , KingOnTable[i].KingThinking[0].RowColumnKing[j][1]);
                                //When CheckMate Occured in King Gray.
                                if (AA.CheckMate(KingOnTable[i].KingThinking[0].TableListKing[j], Order))
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Penalty Ignore.
                                        Do = -1;
                                        //Superposition.
                                        KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = -1;
                                        //Penalty Subbranchs.
                                        MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                    else
                                    {
                                        //Self CheckMate.
                                        if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                        {
                                            //Regard Setting.
                                            Do = 1;
                                            //Superpoistion.
                                            KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = 1;
                                            //Regard Subbranchs.
                                            MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                        }
                                    }
                           
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For King Gray Subbranchs.
                                
                                    for (var ii = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                        KingOnTable[i].KingThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                               
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                }
                //For Brown Order.
                else
                {
                    ChessRules AA = null;
                    //ChessRules.CurrentOrder = -1;
                    //For Solders Brown.
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {

                            
                                //Solders Brown Rules.
                                AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, SolderesOnTable[i].SoldierThinking[0].TableListSolder[j][SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]]
                                , SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]
                                , Order
                                , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0]
                                , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]);
                                //When Solders Brown CheckMate Occured.
                                if (AA.CheckMate(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Order))
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Ignore Penalty.
                                        Do = -1;
                                        //Supperpoistion.
                                        SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = -1;
                                        //Penalty Subbranchs Soders Brown.
                                        MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                    else
                                    {
                                        //Self CheckMate.
                                        if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                        {
                                            //Set Regard.
                                            Do = 1;
                                            //Superpoition.
                                            SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = 1;
                                            //Penalty Subbranchs.
                                            MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                        }
                                    }
                           
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Solders Brown Subbranchs Calling.
                                
                                    for (var ii = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                               
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //Elephant Brown 
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            
                                //Elephant Brown Rules.
                                AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ElephantOnTable[i].ElefantThinking[0].TableListElefant[j][ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0], ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]]
                                , ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]
                                , Order
                                , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0]
                                , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]);
                                //CheckMate Occured in Elephenat Brown.
                                if (AA.CheckMate(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Order))
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Ignore Penalty.
                                        Do = -1;
                                        //Superpoistion.
                                        ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = -1;
                                        //Penalty Subbranchs.
                                        MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                    else
                                    {
                                        //CheckMate Enemy.
                                        if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                        {
                                            //Set Regrading.
                                            Do = 1;
                                            //Superposition.
                                            ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = 1;
                                            //Regrad Subbranchs.
                                            MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                        }
                                    }
                           
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Subbranchs Elephenat Brown Calling.
                                
                                    for (var ii = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                               
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //Hourse Brown 
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {

                            
                                //Hourse Brown Rules.
                                AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, HoursesOnTable[i].HourseThinking[0].TableListHourse[j][HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0], HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]]
                                , HoursesOnTable[i].HourseThinking[0].TableListHourse[j]
                                , Order
                                , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0]
                                , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]);
                                //When Hourse Broin CheckMate Ocuucred.
                                if (AA.CheckMate(HoursesOnTable[i].HourseThinking[0].TableListSolder[j], Order))
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Ignore Penalty.
                                        Do = -1;
                                        //Superposition.
                                        HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = -1;
                                        //Penalty Subbranchs.
                                        MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                    else
                                    {
                                        //CheckMate Enemy.
                                        if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                        {
                                            //Set Regrad.
                                            Do = 1;
                                            //Superposition.
                                            HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = 1;
                                            //Regrad Subbranchs.
                                            MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                        }
                                    }
                           
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Hourse Brown Calling Subbranchs.
                                
                                    for (var ii = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                               
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //Castles Brown 
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            
                                //Castles Brown Rules.
                                AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, CastlesOnTable[i].CastleThinking[0].TableListCastle[j][CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][0], CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][1]]
                                , CastlesOnTable[i].CastleThinking[0].TableListCastle[j]
                                , Order
                                , CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][0]
                                , CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][1]);
                                //When Brown Castles CheckMate Occured.
                                if (AA.CheckMate(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Order))
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Ignore CheckMate.
                                        Do = -1;
                                        //Superpoistion.
                                        CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy = -1;
                                        //Subbranchs Penalty.
                                        MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                    else
                                    {
                                        //CheckMate Enemy.
                                        if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                        {
                                            //Set Regard.
                                            Do = 1;
                                            //Superpoistion.
                                            CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy = 1;
                                            //Regard Subbranchs.
                                            MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                        }
                                    }
                           
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Brown Castles Calling Subbranches.
                                
                                    for (var ii = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                               
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //Minister Brown 
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            
                                //Minister Brown Rules.
                                AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, MinisterOnTable[i].MinisterThinking[0].TableListMinister[j][MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0], MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]]
                                , MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]
                                , Order
                                , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0]
                                , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]);
                                //When Minister Borwn CheckMate Occcured.
                                if (AA.CheckMate(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Order))
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Ignore.
                                        Do = -1;
                                        //Superpoistion.
                                        MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = -1;
                                        //Penalty Subbranches.
                                        MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                    else
                                    {
                                        //CheckMate Enemy.
                                        if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                        {
                                            //Set Regard.
                                            Do = 1;
                                            //Superposition.
                                            MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = 1;
                                            //Regard SubBranches.
                                            MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                        }
                                    }
                           

                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Minister Brown SubBranches Calling.
                                
                                    for (var ii = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                               
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //King Brown
                    for (var i = KingMidle; i < KingHigh; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            
                                //King Brown Rules.
                                AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, KingOnTable[i].KingThinking[0].TableListKing[j][KingOnTable[i].KingThinking[0].RowColumnKing[j][0], KingOnTable[i].KingThinking[0].RowColumnKing[j][1]]
                                , KingOnTable[i].KingThinking[0].TableListKing[j]
                                , Order
                                , KingOnTable[i].KingThinking[0].RowColumnKing[j][0]
                                , KingOnTable[i].KingThinking[0].RowColumnKing[j][1]);
                                //When King Brown Rules CheckMate Occcured.
                                if (AA.CheckMate(KingOnTable[i].KingThinking[0].TableListKing[j], Order))
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Ignore.
                                        Do = -1;
                                        //Superposition.
                                        KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = -1;
                                        //Penalty SubBranches.
                                        MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                    }
                                    else
                                    {
                                        //CheckMate Enemy.
                                        if (AllDraw.OrderPlate == 1 && AA.CheckMateGray)
                                        {
                                            //Set Regard.
                                            Do = 1;
                                            //Superposition.
                                            KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = 1;
                                            //Regard Subbranches.
                                            MakeRegardAllCheckMateBranches(Base, AllDraw.OrderPlate);
                                        }
                                    }

                           
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //King Brown Subbranches Calling.
                                
                                    for (var ii = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                        KingOnTable[i].KingThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                               
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }

                }
                ChessRules.CurrentOrder = CDummy;
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsPenaltyRegardCheckMateAtBranch:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public void MakePenaltyAllCheckMateBranches(AllDraw A, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                int COrder = Order;
                int CDummy = ChessRules.CurrentOrder;
                if (Order== 1)
                {

                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            
                                A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmPenalty();
                           
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order);
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            
                                A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmPenalty();
                           

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                    MakePenaltyAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            
                                A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmPenalty();

                           

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                    MakePenaltyAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            
                                A.CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmPenalty();
                           

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                    MakePenaltyAllCheckMateBranches(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            
                                A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmPenalty();
                           

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                    MakePenaltyAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            
                                A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmPenalty();
                           

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                    MakePenaltyAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                }
                else
                {
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            
                                A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmPenalty();
                           
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                    MakePenaltyAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            
                                A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmPenalty();
                           

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                    MakePenaltyAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            
                                A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmPenalty();

                           

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                    MakePenaltyAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            
                                A.CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmPenalty();
                           

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                    MakePenaltyAllCheckMateBranches(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            
                                A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmPenalty();
                           

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                    MakePenaltyAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = KingMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            
                                A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmPenalty();
                           

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                    MakePenaltyAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("MakePenaltyAllCheckMateBranches:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public AllDraw RemovePenalltyFromFirstBranches(int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {

                if (Order == 1)
                {

                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            UsePenaltyRegardMechnisamT = false;

                            SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].Initiate();
                            for (int k = 0; k < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; k++)
                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);

                        }
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            UsePenaltyRegardMechnisamT = false;


                            ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].Initiate();
                            for (int k = 0; k < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; k++)
                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            UsePenaltyRegardMechnisamT = false;

                            HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].Initiate();
                            for (int k = 0; k < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; k++)
                                HoursesOnTable[i].HourseThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);



                        }
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            UsePenaltyRegardMechnisamT = false;


                            CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].Initiate();
                            for (int k = 0; k < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; k++)
                                CastlesOnTable[i].CastleThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            UsePenaltyRegardMechnisamT = false;


                            MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].Initiate();
                            for (int k = 0; k < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; k++)
                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            UsePenaltyRegardMechnisamT = false;


                            KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].Initiate();
                            for (int k = 0; k < KingOnTable[i].KingThinking[0].AStarGreedy.Count; k++)
                                KingOnTable[i].KingThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                }
                else
                {
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            UsePenaltyRegardMechnisamT = false;


                            SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].Initiate();
                            for (int k = 0; k < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; k++)
                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);

                        }
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            UsePenaltyRegardMechnisamT = false;


                            ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].Initiate();
                            for (int k = 0; k < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; k++)
                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            UsePenaltyRegardMechnisamT = false;


                            HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].Initiate();
                            for (int k = 0; k < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; k++)
                                HoursesOnTable[i].HourseThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);



                        }
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            UsePenaltyRegardMechnisamT = false;


                            CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].Initiate();
                            for (int k = 0; k < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; k++)
                                CastlesOnTable[i].CastleThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            UsePenaltyRegardMechnisamT = false;


                            MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].Initiate();
                            for (int k = 0; k < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; k++)
                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                    for (var i = KingMidle; i < KingHigh; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null
                            && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            UsePenaltyRegardMechnisamT = false;

                            KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].Initiate();
                            for (int k = 0; k < KingOnTable[i].KingThinking[0].AStarGreedy.Count; k++)
                                KingOnTable[i].KingThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1);


                        }
                }
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("RemovePenalltyFromFirstBranches:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return this;
            }

        }
        bool BondryObjectNumber(int i, int Kind, int Order)
        {
            bool Is = true;
            if (Order == 1)
            {
                if (Kind == 1)
                {
                    if (i >= SodierMidle)
                        Is = false;
                }
                else
                    if (Kind == 2)
                {
                    if (i >= ElefantMidle)
                        Is = false;
                }
                else
                    if (Kind == 3)
                {
                    if (i >= HourseMidle)
                        Is = false;
                }
                else
                    if (Kind == 4)
                {
                    if (i >= CastleMidle)
                        Is = false;
                }
                else
                    if (Kind == 5)
                {
                    if (i >= MinisterMidle)
                        Is = false;
                }
                else
                    if (Kind == 6)
                {
                    if (i >= KingMidle)
                        Is = false;
                }
            }
            else
            {
                if (Kind == 1)
                {
                    if (i < SodierMidle|| i >= SodierHigh)
                        Is = false;
                }
                else
                   if (Kind == 2)
                {
                    if (i < ElefantMidle|| i >= ElefantHigh)
                        Is = false;
                }
                else
                   if (Kind == 3)
                {
                    if (i < HourseMidle|| i >= HourseHight)
                        Is = false;
                }
                else
                   if (Kind == 4)
                {
                    if (i < CastleMidle|| i >= CastleHigh)
                        Is = false;
                }
                else
                   if (Kind == 5)
                {
                    if (i < MinisterMidle|| i >= MinisterHigh)
                        Is = false;
                }
                else
                   if (Kind == 6)
                {
                    if (i < KingMidle|| i >= KingHigh)
                        Is = false;
                }
            }
            return Is;
        }
        public AllDraw FoundOfCurrentTableNodeAstardGreedy(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (BondryObjectNumber(i, 1, Order) && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null)
            {
                //for (var ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                {
                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null)
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);
                }
            }

            if (BondryObjectNumber(i, 2, Order) && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null)
            {
                //for (var ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                {
                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null)
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);
                }
            }
            if (BondryObjectNumber(i, 3, Order) && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null)
            {
                //for (var ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                {
                    if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null)
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);
                }
            }
            if (BondryObjectNumber(i, 4, Order) && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null)
            {
                //for (var ii = 0; ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                {
                    if (CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null)
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);
                }
            }
            if (BondryObjectNumber(i, 5, Order) && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null)
            {
                //for (var ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                {
                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null)
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);
                }
            }
            if (BondryObjectNumber(i, 6, Order) && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count && KingOnTable[i].KingThinking[0].AStarGreedy.Count > j && KingOnTable[i].KingThinking[0].AStarGreedy != null)

                if (KingOnTable[i].KingThinking[0].AStarGreedy.Count > j  && KingOnTable[i].KingThinking[0].AStarGreedy != null)
                {

                    //for (var ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                    {
                        KingOnTable[i].KingThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);
                }
            }
            return THIS;
        }


        public AllDraw FoundOfCurrentTableNode(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {
                //if (Found)
                //if (THIS != null&&THIS.TableList.Count>0) return THIS; else { Found = false; return null; }
                ThinkingChess.NumbersOfAllNode++;
                if ((TableList.Count > 0 && ThinkingChess.TableEqual(TableList[0], Tab)) || FoundOfCurrentTableNodeFirstLevel(Tab, Order, ref THIS, ref Found))
                {
                    if (!Found)
                    {
                        THIS = this;
                        Found = true;
                    }
                    //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfCurrentTableNode:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                    return THIS;
                }

                else
                if (Order == 1)
                {

                    for (var i = 0; i < SodierMidle; i++)
                    {
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {


                            if (ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab))
                            {
                                FoundOfCurrentTableNodeSolderIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;


                            }
                        }
                    }
                    for (var i = 0; i < ElefantMidle; i++)
                    {
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {


                            if (ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab))
                            {
                                FoundOfCurrentTableNodeElephantIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {


                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    for (var i = 0; i < HourseMidle; i++)
                    {
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {

                            if (ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab))
                            {
                                FoundOfCurrentTableNodeHourseIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {


                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    for (var i = 0; i < CastleMidle; i++)
                    {
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            if (ThinkingChess.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab))
                            {
                                FoundOfCurrentTableNodeCastleIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    for (var i = 0; i < MinisterMidle; i++)
                    {
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            if (ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab))
                            {
                                FoundOfCurrentTableNodeMinisterIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    for (var i = 0; i < KingMidle; i++)
                    {
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            if (ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab))
                            {
                                FoundOfCurrentTableNodeKingIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                }
                else
                {
                    for (var i = SodierMidle; i < SodierHigh; i++)
                    {
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {


                            if (ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab))
                            {
                                FoundOfCurrentTableNodeSolderIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {


                            if (ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab))
                            {
                                FoundOfCurrentTableNodeElephantIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    for (var i = HourseMidle; i < HourseHight; i++)
                    {
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {


                            if (ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab))
                            {
                                FoundOfCurrentTableNodeHourseIJ(i, j, Tab, Order, ref THIS, ref Found);

                                if (Found)
                                    return THIS;
                            }
                            else
                            {
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    for (var i = CastleMidle; i < CastleHigh; i++)
                    {
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {


                            if (ThinkingChess.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab))
                            {
                                FoundOfCurrentTableNodeCastleIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }

                        }
                    }
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            if (ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab))
                            {
                                FoundOfCurrentTableNodeMinisterIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    for (var i = KingMidle; i < KingHigh; i++)
                    {
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            if (ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab))
                            {
                                FoundOfCurrentTableNodeKingIJ(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;

                            }
                            else
                            {
                                FoundOfCurrentTableNodeAstardGreedy(i, j, Tab, Order, ref THIS, ref Found);
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                }
                return THIS;
            }
        }

        public bool FoundOfCurrentTableNodeFirstLevel(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (!Found)
                FoundOfCurrentTableNodeSoldeir(Tab, Order, ref THIS, ref Found);
            if (!Found)
                FoundOfCurrentTableNodeElephant(Tab, Order, ref THIS, ref Found);
            if (!Found)
                FoundOfCurrentTableNodeHourse(Tab, Order, ref THIS, ref Found);
            if (!Found)
                FoundOfCurrentTableNodeCastle(Tab, Order, ref THIS, ref Found);
            if (!Found)
                FoundOfCurrentTableNodeMinister(Tab, Order, ref THIS, ref Found);
            if (!Found)
                FoundOfCurrentTableNodeKing(Tab, Order, ref THIS, ref Found);

            return Found;
        }
        bool IsAstargreedyHaveNode(int Kind, int Order)
        {

            bool Is = false;
            if (Order == 1)
            {
                if (Kind == 1)
                {
                    for (int i = 0; SolderesOnTable != null && i < SodierMidle; i++)
                    {
                        if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 2)
                {
                    for (int i = 0; ElephantOnTable != null && i < ElefantMidle; i++)
                    {
                        if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                        {
                            Is = true;
                        }
                    }

                }
                else if (Kind == 3)
                {
                    for (int i = 0; HoursesOnTable != null && i < HourseMidle; i++)
                    {
                        if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 4)
                {
                    for (int i = 0; CastlesOnTable != null && i < CastleMidle; i++)
                    {
                        if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 5)
                {
                    for (int i = 0; MinisterOnTable != null && i < MinisterMidle; i++)
                    {
                        if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else
                    if (Kind == 6)
                {
                    for (int i = 0; KingOnTable != null && i < KingMidle; i++)
                    {
                        if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }

            }
            else
            {
                if (Kind == 1)
                {
                    for (int i = SodierMidle; SolderesOnTable != null && i < SodierHigh; i++)
                    {
                        if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 2)
                {
                    for (int i = ElefantMidle; ElephantOnTable != null && i < ElefantHigh; i++)
                    {
                        if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 3)
                {
                    for (int i = HourseMidle; HoursesOnTable != null && i < HourseHight; i++)
                    {
                        if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else
                    if (Kind == 4)
                {
                    for (int i = CastleMidle; CastlesOnTable != null && i < CastleHigh; i++)
                    {
                        if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else
                    if (Kind == 5)
                {
                    for (int i = MinisterHigh; MinisterOnTable != null && i < MinisterHigh; i++)
                    {
                        if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 6)
                {
                    for (int i = KingMidle; KingOnTable != null && i < KingHigh; i++)
                    {
                        if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
            }

            return Is;

        }
        public void ClearAllTablesHuristicsAndMore(int Order)
        {

            if (Order == 1)
            {

                for (int i = 0; SolderesOnTable != null && i < SodierMidle; i++)
                {
                    if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                    {
                        SolderesOnTable[i].SoldierThinking[0].TableListSolder.Clear();
                        SolderesOnTable[i].SoldierThinking[0].HuristicListSolder.Clear();
                        SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier.Clear();
                        SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder.Clear();
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Clear();
                    }
                }

                for (int i = 0; ElephantOnTable != null && i < ElefantMidle; i++)
                {
                    if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                    {
                        ElephantOnTable[i].ElefantThinking[0].TableListElefant.Clear();
                        ElephantOnTable[i].ElefantThinking[0].HuristicListSolder.Clear();
                        ElephantOnTable[i].ElefantThinking[0].RowColumnElefant.Clear();
                        ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant.Clear();
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Clear();
                    }
                }


                for (int i = 0; HoursesOnTable != null && i < HourseMidle; i++)
                {
                    if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                    {
                        HoursesOnTable[i].HourseThinking[0].TableListHourse.Clear();
                        HoursesOnTable[i].HourseThinking[0].HuristicListHourse.Clear();
                        HoursesOnTable[i].HourseThinking[0].RowColumnHourse.Clear();
                        HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse.Clear();
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy.Clear();
                    }
                }

                for (int i = 0; CastlesOnTable != null && i < CastleMidle; i++)
                {
                    if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                    {
                        CastlesOnTable[i].CastleThinking[0].TableListCastle.Clear();
                        CastlesOnTable[i].CastleThinking[0].HuristicListCastle.Clear();
                        CastlesOnTable[i].CastleThinking[0].RowColumnCastle.Clear();
                        CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle.Clear();
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy.Clear();
                    }
                }

                for (int i = 0; MinisterOnTable != null && i < MinisterMidle; i++)
                {
                    if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                    {
                        MinisterOnTable[i].MinisterThinking[0].TableListMinister.Clear();
                        MinisterOnTable[i].MinisterThinking[0].HuristicListMinister.Clear();
                        MinisterOnTable[i].MinisterThinking[0].RowColumnMinister.Clear();
                        MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister.Clear();
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Clear();
                    }
                }

                for (int i = 0; KingOnTable != null && i < KingMidle; i++)
                {
                    if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                    {
                        KingOnTable[i].KingThinking[0].TableListKing.Clear();
                        KingOnTable[i].KingThinking[0].HuristicListKing.Clear();
                        KingOnTable[i].KingThinking[0].RowColumnKing.Clear();
                        KingOnTable[i].KingThinking[0].PenaltyRegardListKing.Clear();
                        KingOnTable[i].KingThinking[0].AStarGreedy.Clear();
                    }
                }


            }
            else
            {

                for (int i = SodierMidle; SolderesOnTable != null && i < SodierHigh; i++)
                {
                    if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                    {
                        SolderesOnTable[i].SoldierThinking[0].TableListSolder.Clear();
                        SolderesOnTable[i].SoldierThinking[0].HuristicListSolder.Clear();
                        SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier.Clear();
                        SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder.Clear();
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Clear();
                    }
                }

                for (int i = ElefantMidle; ElephantOnTable != null && i < ElefantHigh; i++)
                {
                    if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                    {
                        ElephantOnTable[i].ElefantThinking[0].TableListElefant.Clear();
                        ElephantOnTable[i].ElefantThinking[0].HuristicListElefant.Clear();
                        ElephantOnTable[i].ElefantThinking[0].RowColumnElefant.Clear();
                        ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant.Clear();
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Clear();
                    }
                }

                for (int i = HourseMidle; HoursesOnTable != null && i < HourseHight; i++)
                {
                    if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                    {
                        HoursesOnTable[i].HourseThinking[0].TableListHourse.Clear();
                        HoursesOnTable[i].HourseThinking[0].HuristicListHourse.Clear();
                        HoursesOnTable[i].HourseThinking[0].RowColumnHourse.Clear();
                        HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse.Clear();
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy.Clear();
                    }
                }


                for (int i = CastleMidle; CastlesOnTable != null && i < CastleHigh; i++)
                {
                    if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                    {
                        CastlesOnTable[i].CastleThinking[0].TableListCastle.Clear();
                        CastlesOnTable[i].CastleThinking[0].HuristicListCastle.Clear();
                        CastlesOnTable[i].CastleThinking[0].RowColumnCastle.Clear();
                        CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle.Clear();
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy.Clear();
                    }
                }


                for (int i = MinisterHigh; MinisterOnTable != null && i < MinisterHigh; i++)
                {
                    if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                    {
                        MinisterOnTable[i].MinisterThinking[0].TableListMinister.Clear();
                        MinisterOnTable[i].MinisterThinking[0].HuristicListMinister.Clear();
                        MinisterOnTable[i].MinisterThinking[0].RowColumnMinister.Clear();
                        MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister.Clear();
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Clear();
                    }
                }

                for (int i = KingMidle; KingOnTable != null && i < KingHigh; i++)
                {
                    if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                    {
                        KingOnTable[i].KingThinking[0].TableListKing.Clear();
                        KingOnTable[i].KingThinking[0].HuristicListKing.Clear();
                        KingOnTable[i].KingThinking[0].RowColumnKing.Clear();
                        KingOnTable[i].KingThinking[0].PenaltyRegardListKing.Clear();
                        KingOnTable[i].KingThinking[0].AStarGreedy.Clear();
                    }
                }

            }



        }
        public bool FoundOfCurrentTableNodeSolderIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy == null)
            {
                for (int h = 0; h <= j; h++)
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 1);
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Clear();
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Add(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]);
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].SetRowColumn(0);
                THIS = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }
            else
                                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count < j)
            {
                for (int h = SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; h <= j; h++)
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 1);
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Clear();
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Add(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]);
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].SetRowColumn(0);
                THIS = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }
            else
            {
                if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j)
                {
                    if (!SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].IsAstargreedyHaveNode(1, Order))
                    {
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Clear();
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Add(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]);
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].SetRowColumn(0);
                    }
                    THIS = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }

        public bool FoundOfCurrentTableNodeSoldeir(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; SolderesOnTable != null && i < SodierMidle; i++)
                {
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > j; j++)
                    {
                        if (ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab))
                        {
                            FoundOfCurrentTableNodeSolderIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;
                        }
                    }
                }
            }
            else
            {
                for (int i = SodierMidle; SolderesOnTable != null && i < SodierHigh; i++)
                {
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > j; j++)
                    {
                        if (ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab))
                        {
                            FoundOfCurrentTableNodeSolderIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;

                        }

                    }
                }

            }
            return Found;
        }
        public bool FoundOfCurrentTableNodeElephantIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy == null)
            {
                for (int h = 0; h <= j; h++)
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 2);
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Clear();
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Add(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]);
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].SetRowColumn(0);
                THIS = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }
            else
                                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count < j)
            {
                for (int h = ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; h <= j; h++)
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 2);
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Clear();
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Add(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]);
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].SetRowColumn(0);
                THIS = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }
            else
            {
                if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j)
                {
                    if (!ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].IsAstargreedyHaveNode(2, Order))
                    {
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Clear();
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Add(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]);
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].SetRowColumn(0);
                    }
                    THIS = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        public bool FoundOfCurrentTableNodeElephant(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; ElephantOnTable != null && i < ElefantMidle; i++)
                {
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > j; j++)
                    {
                        if (ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab))
                        {

                            FoundOfCurrentTableNodeElephantIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;
                        }

                    }
                }
            }
            else
            {
                for (int i = ElefantMidle; ElephantOnTable != null && i < ElefantHigh; i++)
                {
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > j; j++)
                    {
                        if (ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab))
                        {
                            FoundOfCurrentTableNodeElephantIJ(i, j, Tab, Order, ref THIS, ref Found);

                            if (Found)
                                return Found;
                        }

                    }
                }

            }
            return Found;
        }
        public bool FoundOfCurrentTableNodeHourseIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (HoursesOnTable[i].HourseThinking[0].AStarGreedy == null)
            {
                for (int h = 0; h <= j; h++)
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 3);
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Clear();
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Add(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]);
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].SetRowColumn(0);
                THIS = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }
            else
                                   if (HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count < j)
            {
                for (int h = HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; h <= j; h++)
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 3);
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Clear();
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Add(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]);
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].SetRowColumn(0);
                THIS = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }
            else
            {
                if (HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j)
                {
                    if (!HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].IsAstargreedyHaveNode(3, Order))
                    {
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Clear();
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Add(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]);
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].SetRowColumn(0);
                    }

                    THIS = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        public bool FoundOfCurrentTableNodeHourse(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; HoursesOnTable != null && i < ElefantMidle; i++)
                {
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > j; j++)
                    {
                        if (ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab))
                        {
                            FoundOfCurrentTableNodeHourseIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;

                        }

                    }
                }
            }
            else
            {
                for (int i = HourseMidle; HoursesOnTable != null && i < HourseHight; i++)
                {
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > j; j++)
                    {
                        if (ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab))
                        {
                            FoundOfCurrentTableNodeHourseIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;

                        }

                    }
                }

            }
            return Found;
        }
        public bool FoundOfCurrentTableNodeCastleIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (CastlesOnTable[i].CastleThinking[0].AStarGreedy == null)
            {
                for (int h = 0; h <= j; h++)
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 4);
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Clear();
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Add(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]);
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].SetRowColumn(0);
                THIS = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }
            else
                      if (CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count < j)
            {
                for (int h = CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; h <= j; h++)
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 4);
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Clear();
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Add(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]);
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].SetRowColumn(0);
                THIS = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }
            else
            {
                if (CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j)
                {
                    if (!CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].IsAstargreedyHaveNode(4, Order))
                    {
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Clear();
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Add(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]);
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].SetRowColumn(0);
                    }
                    THIS = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j];

                    Found = true;
                    return true;
                }
            }
            return false;
        }
        public bool FoundOfCurrentTableNodeCastle(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; CastlesOnTable != null && i < CastleMidle; i++)
                {
                    for (int j = 0; CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > j; j++)
                    {
                        if (ThinkingChess.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab))
                        {

                            FoundOfCurrentTableNodeCastleIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;
                        }

                    }
                }
            }
            else
            {
                for (int i = CastleMidle; CastlesOnTable != null && i < CastleHigh; i++)
                {
                    for (int j = 0; CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > j; j++)
                    {
                        if (ThinkingChess.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab))
                        {
                            FoundOfCurrentTableNodeCastleIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;

                        }

                    }
                }

            }
            return Found;
        }
        public bool FoundOfCurrentTableNodeMinisterIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy == null)
            {
                for (int h = 0; h <= j; h++)
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 5);
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Clear();
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Add(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]);
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].SetRowColumn(0);
                THIS = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }
            else
                                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count < j)
            {
                for (int h = MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; h <= j; h++)
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 5);
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Clear();
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Add(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]);
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].SetRowColumn(0);
                THIS = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }
            else
            {
                if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j)
                {
                    if (!MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].IsAstargreedyHaveNode(5, Order))
                    {
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Clear();
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Add(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]);
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].SetRowColumn(0);
                    }
                    THIS = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        public bool FoundOfCurrentTableNodeMinister(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; MinisterOnTable != null && i < MinisterMidle; i++)
                {
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > j; j++)
                    {
                        if (ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab))
                        {
                            FoundOfCurrentTableNodeMinisterIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;

                        }

                    }
                }
            }
            else
            {
                for (int i = MinisterMidle; MinisterOnTable != null && i < MinisterHigh; i++)
                {
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > j; j++)
                    {
                        if (ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab))
                        {
                            FoundOfCurrentTableNodeMinisterIJ(i, j, Tab, Order, ref THIS, ref Found);

                        }

                    }
                }

            }
            return Found;
        }
        public bool FoundOfCurrentTableNodeKingIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (KingOnTable[i].KingThinking[0].AStarGreedy == null)
            {
                for (int h = 0; h <= j; h++)
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 6);
                KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Clear();
                KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Add(KingOnTable[i].KingThinking[0].TableListKing[j]);
                KingOnTable[i].KingThinking[0].AStarGreedy[j].SetRowColumn(0);
                THIS = KingOnTable[i].KingThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }
            else
                                    if (KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count < j)
            {
                for (int h = KingOnTable[i].KingThinking[0].AStarGreedy.Count; h <= j; h++)
                    BlitzNotValidFullGameThinkingTreePartThree(i, Order, 6);
                KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Clear();
                KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Add(KingOnTable[i].KingThinking[0].TableListKing[j]);
                KingOnTable[i].KingThinking[0].AStarGreedy[j].SetRowColumn(0);
                THIS = KingOnTable[i].KingThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }
            else
            {
                if (KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count > j)
                {
                    if (!KingOnTable[i].KingThinking[0].AStarGreedy[j].IsAstargreedyHaveNode(6, Order))
                    {
                        KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Clear();
                        KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Add(KingOnTable[i].KingThinking[0].TableListKing[j]);
                        KingOnTable[i].KingThinking[0].AStarGreedy[j].SetRowColumn(0);
                    }
                    THIS = KingOnTable[i].KingThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        public bool FoundOfCurrentTableNodeKing(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; KingOnTable != null && i < KingMidle; i++)
                {
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > j; j++)
                    {
                        if (ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab))
                        {
                            FoundOfCurrentTableNodeKingIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;

                        }

                    }
                }
            }
            else
            {
                for (int i = KingMidle; KingOnTable != null && i < KingHigh; i++)
                {
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > j; j++)
                    {
                        if (ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab))
                        {
                            FoundOfCurrentTableNodeKingIJ(i, j, Tab, Order, ref THIS, ref Found);
                            if (Found)
                                return Found;

                        }

                    }
                }

            }
            return Found;
        }

        public AllDraw FoundOfLeafDepenOfKind(int Kind, ref AllDraw Leaf, ref bool Found, int Order, ref int OrderLeaf)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {

                //if (ThinkingChess.FoundFirstMating > MaxAStarGreedy)
                //return Leaf
                if (Found)
                    return Leaf;
                if (Order == 1)
                {

                    for (var i = 0; i < SodierMidle; i++)
                    {
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {


                            if (SolderesOnTable[i].SoldierThinking[0].IsThereMateOfEnemy || SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0 && Kind == 1)
                            {
                                Found = true;
                                Leaf = this;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return Leaf;

                            }
                            else
                                for (var ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1; ii++)
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);


                        }
                    }
                    for (var i = 0; i < ElefantMidle; i++)
                    {
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0 && Kind == 2)
                            {
                                Found = true;
                                Leaf = this;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return Leaf;
                            }
                            else
                                for (var ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1; ii++)
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);



                        }
                    }
                        for (var i = 0; i < HourseMidle; i++)
                        {
                            for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                            {

                                if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0 && Kind == 3)
                                {
                                    Found = true;
                                    Leaf = this;
                                    //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                    return Leaf;
                                }
                                else
                                    for (var ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1; ii++)
                                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);


                            }

                        }
                    
                    for (var i = 0; i < CastleMidle; i++)
                    {
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            if (CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count == 0 && Kind == 4)
                            {
                                Found = true;
                                Leaf = this;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return Leaf;
                            }
                            else
                                for (var ii = 0; ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count - 1; ii++)
                                    CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);

                        }
                    }
                    for (var i = 0; i < MinisterMidle; i++)
                    {
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0 && Kind == 5)
                            {
                                Found = true;
                                Leaf = this;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return Leaf;
                            }
                            else
                                for (var ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1; ii++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);



                        }
                    }
                    for (var i = 0; i < KingMidle; i++)
                    {
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            if (KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0 && Kind == 6)
                            {
                                Found = true;
                                Leaf = this;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return Leaf;
                            }
                            else
                                for (var ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1; ii++)
                                    KingOnTable[i].KingThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);



                        }
                    }
                }
                else
                {
                    for (var i = SodierMidle; i < SodierHigh; i++)
                    {
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {


                            if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0 && Kind == 1)
                            {
                                Found = true;
                                Leaf = this;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return Leaf;
                            }
                            else
                                for (var ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1; ii++)
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);

                        }
                    }
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {


                            if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0 && Kind == 2)
                            {
                                Found = true;
                                Leaf = this;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return Leaf;
                            }
                            else
                                for (var ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1; ii++)
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);

                        }
                    }
                    for (var i = HourseMidle; i < HourseHight; i++)
                    {
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {


                            if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0 && Kind == 3)
                            {
                                Found = true;
                                Leaf = this;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return Leaf;
                            }
                            else
                                for (var ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1; ii++)
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);

                        }
                    }
                    for (var i = CastleMidle; i < CastleHigh; i++)
                    {
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {


                            if (CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count == 0 && Kind == 4)
                            {
                                Found = true;
                                Leaf = this;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return Leaf;
                            }
                            else
                                for (var ii = 0; ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count - 1; ii++)
                                    CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);


                        }
                    }
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0 && Kind == 5)
                            {
                                Found = true;
                                Leaf = this;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return Leaf;
                            }
                            else
                                for (var ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1; ii++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);


                        }
                    }

                    for (var i = KingMidle; i < KingHigh; i++)
                    {
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            if (KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0 && Kind == 6)
                            {
                                Found = true;
                                Leaf = this;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return Leaf;

                            }
                            else
                                for (var ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1; ii++)
                                    KingOnTable[i].KingThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);



                        }
                    }
                }
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfLeafDepenOfKind:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Leaf;
            }
        }
        public bool IsFoundOfLeafDepenOfKindhaveVictory(int Kind, ref bool Found, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {

                //if (ThinkingChess.FoundFirstMating > MaxAStarGreedy)
                //return Leaf
                if (Found)
                    return true;
                if (Order== 1)
                {

                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {

                            
                                if (SolderesOnTable[i].SoldierThinking[0].IsThereMateOfEnemy// && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0 
                                    && Kind == 1)
                                {
                                    Found = true;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                                }
                                else
                                    for (var ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);

                           
                        }
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            
                                if (ElephantOnTable[i].ElefantThinking[0].IsThereMateOfEnemy //&& ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0 
                            && Kind == 2)
                                {
                                    Found = true;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                                }
                                else
                                    for (var ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);


                           
                        }
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            
                                if (HoursesOnTable[i].HourseThinking[0].IsThereMateOfEnemy //&& HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0 
    && Kind == 3)
                                {
                                    Found = true;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                                }
                                else
                                    for (var ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);

                           


                        }
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            
                                if (CastlesOnTable[i].CastleThinking[0].IsThereMateOfEnemy //&& CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count == 0 
                                    && Kind == 4)
                                {
                                    Found = true;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                                }
                                else
                                    for (var ii = 0; ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);
                           

                        }
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            
                                if (MinisterOnTable[i].MinisterThinking[0].IsThereMateOfEnemy //&& MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0 
                                    && Kind == 5)
                                {
                                    Found = true;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                                }
                                else
                                    for (var ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);

                           

                        }
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            
                                if (KingOnTable[i].KingThinking[0].IsThereMateOfEnemy //&& KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0 
                                    && Kind == 6)
                                {
                                    Found = true;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                                }
                                else
                                    for (var ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                        KingOnTable[i].KingThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);

                           

                        }
                }
                else
                {
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            

                                if (SolderesOnTable[i].SoldierThinking[0].IsThereMateOfEnemy //&& SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0 
                                    && Kind == 1)
                                {
                                    Found = true;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                                }
                                else
                                    for (var ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);
                           
                        }
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            

                                if (ElephantOnTable[i].ElefantThinking[0].IsThereMateOfEnemy //&& ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0 
                                    && Kind == 2)
                                {
                                    Found = true;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                                }
                                else
                                    for (var ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);
                           
                        }
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            

                                if (HoursesOnTable[i].HourseThinking[0].IsThereMateOfEnemy //&& HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0 
                                    && Kind == 3)
                                {
                                    Found = true;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                                }
                                else
                                    for (var ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);
                           
                        }
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            

                                if (CastlesOnTable[i].CastleThinking[0].IsThereMateOfEnemy //&& CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count == 0 
                                    && Kind == 4)
                                {
                                    Found = true;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                                }
                                else
                                    for (var ii = 0; ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);

                           
                        }
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            
                                if (MinisterOnTable[i].MinisterThinking[0].IsThereMateOfEnemy //&& MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0
                                    && Kind == 5)
                                {
                                    Found = true;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;
                                }
                                else
                                    for (var ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);

                           
                        }
                    for (var i = KingMidle; i < KingHigh; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            
                                if (KingOnTable[i].KingThinking[0].IsThereMateOfEnemy //&& KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0 
                                    && Kind == 6)
                                {
                                    Found = true;
                                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                                return true;

                                }
                                else
                                    for (var ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                        KingOnTable[i].KingThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref Found, Order * -1);


                           
                        }
                }
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsFoundOfLeafDepenOfKindhaveVictory:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Found;
            }
        }
        public void FoundOfLeafDepenOfKindFullGame(int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int ik, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a1 = new Object();
            lock (a1)
            {
                //if()
                bool FullGameFound = false;
                //if (ThinkingChess.FoundFirstMating > MaxAStarGreedy)
                //   return;
                Object O = new Object();
                lock (O)
                {
                    //table = CloneATable(table);
                    OutPut.Append("\r\nLeaf Tree Creation is " + LeafAStarGreedy.ToString() + "at AStarGreedy " + iAStarGreedy.ToString());
                    if (Order== 1)
                    {

                        for (var i = 0; i < SodierMidle; i++)
                            for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                            {

                                
                                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0)
                                    {
                                        FullGameFound = true;
                                        FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, false, LeafAStarGreedy);

                                    }
                                    else
                                        for (var iii = 0; iii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; iii++)
                                        {
                                            ThinkingChess.NumbersOfAllNode++;
                                            SolderesOnTable[i].SoldierThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(SolderesOnTable[i].SoldierThinking[0].TableT, Order * -1, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy++);
                                        }

                               
                            }
                        for (var i = 0; i < ElefantMidle; i++)
                            for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                            {
                                
                                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0)
                                    {
                                        FullGameFound = true;
                                        FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, false, LeafAStarGreedy);
                                    }
                                    else
                                        for (var iii = 0; iii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; iii++)
                                        {
                                            ThinkingChess.NumbersOfAllNode++;
                                            ElephantOnTable[i].ElefantThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(ElephantOnTable[i].ElefantThinking[0].TableT, Order * -1, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy++);
                                        }


                               
                            }
                        for (var i = 0; i < HourseMidle; i++)
                            for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                            {
                                
                                    if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0)
                                    {
                                        FullGameFound = true;
                                        FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, false, LeafAStarGreedy);
                                    }
                                    else
                                        for (var iii = 0; iii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; iii++)
                                        {
                                            ThinkingChess.NumbersOfAllNode++;
                                            HoursesOnTable[i].HourseThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(HoursesOnTable[i].HourseThinking[0].TableT, Order * -1, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy++);
                                        }

                               


                            }
                        for (var i = 0; i < CastleMidle; i++)
                            for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                            {
                                
                                    if (CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count == 0)
                                    {
                                        FullGameFound = true;
                                        FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, false, LeafAStarGreedy);
                                    }
                                    else
                                        for (var iii = 0; iii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; iii++)
                                        {
                                            ThinkingChess.NumbersOfAllNode++;
                                            CastlesOnTable[i].CastleThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CastlesOnTable[i].CastleThinking[0].TableT, Order * -1, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy++);
                                        }
                               

                            }
                        for (var i = 0; i < MinisterMidle; i++)
                            for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                            {
                                
                                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0)
                                    {
                                        FullGameFound = true;
                                        FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, false, LeafAStarGreedy);
                                    }
                                    else
                                        for (var iii = 0; iii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; iii++)
                                        {
                                            ThinkingChess.NumbersOfAllNode++;
                                            MinisterOnTable[i].MinisterThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(MinisterOnTable[i].MinisterThinking[0].TableT, Order * -1, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy++);
                                        }


                               

                            }
                        for (var i = 0; i < KingMidle; i++)
                            for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                            {
                                
                                    if (KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0)
                                    {
                                        FullGameFound = true;
                                        FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, false, LeafAStarGreedy);
                                    }
                                    else
                                        for (var iii = 0; iii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; iii++)
                                        {
                                            ThinkingChess.NumbersOfAllNode++;
                                            KingOnTable[i].KingThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(KingOnTable[i].KingThinking[0].TableT, Order * -1, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy++);
                                        }

                               

                            }
                    }
                    else
                    {
                        for (var i = SodierMidle; i < SodierHigh; i++)
                            for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                            {
                                

                                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0)
                                    {
                                        FullGameFound = true;
                                        FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, false, LeafAStarGreedy);
                                    }
                                    else
                                        for (var iii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; iii++)
                                        {
                                            ThinkingChess.NumbersOfAllNode++;
                                            SolderesOnTable[i].SoldierThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(SolderesOnTable[i].SoldierThinking[0].TableT, Order * -1, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy++);
                                        }
                               
                            }
                        for (var i = ElefantMidle; i < ElefantHigh; i++)
                            for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                            {
                                

                                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0)
                                    {
                                        FullGameFound = true;
                                        FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, false, LeafAStarGreedy);
                                    }
                                    else
                                        for (var iii = 0; iii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; iii++)
                                        {
                                            ThinkingChess.NumbersOfAllNode++;
                                            ElephantOnTable[i].ElefantThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(ElephantOnTable[i].ElefantThinking[0].TableT, Order * -1, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy++);
                                        }
                               
                            }
                        for (var i = HourseMidle; i < HourseHight; i++)
                            for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                            {
                                

                                    if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0)
                                    {
                                        FullGameFound = true;
                                        FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, false, LeafAStarGreedy);
                                    }
                                    else
                                        for (var iii = 0; iii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; iii++)
                                        {
                                            ThinkingChess.NumbersOfAllNode++;
                                            HoursesOnTable[i].HourseThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(HoursesOnTable[i].HourseThinking[0].TableT, Order * -1, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy++);
                                        }
                               
                            }
                        for (var i = CastleMidle; i < CastleHigh; i++)
                            for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                            {
                                

                                    if (CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count == 0)
                                    {
                                        FullGameFound = true;
                                        FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, false, LeafAStarGreedy);
                                    }
                                    else
                                        for (var iii = 0; iii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; iii++)
                                        {
                                            ThinkingChess.NumbersOfAllNode++;
                                            CastlesOnTable[i].CastleThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CastlesOnTable[i].CastleThinking[0].TableT, Order * -1, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy++);
                                        }

                               
                            }
                        for (var i = MinisterMidle; i < MinisterHigh; i++)
                            for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                            {
                                
                                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0)
                                    {

                                        FullGameFound = true;
                                        FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, false, LeafAStarGreedy);
                                    }
                                    else
                                        for (var iii = 0; iii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; iii++)
                                        {
                                            ThinkingChess.NumbersOfAllNode++;
                                            MinisterOnTable[i].MinisterThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(MinisterOnTable[i].MinisterThinking[0].TableT, Order * -1, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy++);
                                        }

                               
                            }
                        for (var i = KingMidle; i < KingHigh; i++)
                            for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                            {
                                
                                    if (KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0)
                                    {
                                        FullGameFound = true;
                                        FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, false, LeafAStarGreedy);
                                    }
                                    else
                                        for (var iii = 0; iii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; iii++)
                                        {
                                            ThinkingChess.NumbersOfAllNode++;
                                            KingOnTable[i].KingThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(KingOnTable[i].KingThinking[0].TableT, Order * -1, iAStarGreedy, ii, jj, ik, jjj, FOUND, LeafAStarGreedy++);
                                        }


                               
                            }
                    }
                }
                if (!FullGameFound)
                {
                    Object O1 = new Object();
                    lock (O1)
                    {
                        iAStarGreedy++;
                        Color a = Color.Gray;
                        if (Order == -1)
                            a = Color.Brown;
                        InitiateAStarGreedytObject(MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy);
                        //Initiate(ii, jj, a, CloneATable(Table), Order, false, false,LeafAStarGreedy);
                    }
                }
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfLeafDepenOfKindFullGame:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return;
            }
        }
        public void MakeRegardAllCheckMateBranches(AllDraw A, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a = new Object();
            lock (a)
            {

                int COrder = Order;
                int CDummy = ChessRules.CurrentOrder;

                if (Order== 1)
                {

                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {

                            
                                A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmRegard();
                           
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                    MakeRegardAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order);

                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            
                                A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmRegard();

                           
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                    MakeRegardAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            
                                A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmRegard();

                           
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                    MakeRegardAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            
                                A.CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmRegard();
                           
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                    MakeRegardAllCheckMateBranches(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            
                                A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmRegard();
                           

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                    MakeRegardAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            
                                A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmRegard();
                           
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                    MakeRegardAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                }
                else
                {
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            
                                A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmRegard();
                           
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                    MakeRegardAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            
                                A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmRegard();

                           
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                    MakeRegardAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            
                                A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmRegard();

                           
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                    MakeRegardAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            
                                A.CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmRegard();
                           
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                    MakeRegardAllCheckMateBranches(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            
                                A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmRegard();
                           
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                    MakeRegardAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = KingMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            
                                A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmRegard();
                           
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            
                                for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                    MakeRegardAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order);
                           
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("MakeRegardAllCheckMateBranches:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        int[,] HuristicAStarGreadySearchPenalties(int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a1 = new Object();
            lock (a1)
            {

                ChessRules AB = null;

                int ToCheckMate = -1, ForCheckMate = -1, j, i;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                int[,] TableHuristic = new int[8, 8];
                //For Every Soldeir
                for (i = 0; i < SodierMidle; i++)
                {


                    //For Every Soldier Movments AStarGreedy.
                    for (int k = 0; k < AllDraw.SodierMovments; k++)
                        //When There is an Movment in such situation.
                        
                            for (j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[k] != null && SolderesOnTable[i].SoldierThinking[k] != null && j < SolderesOnTable[i].SoldierThinking[k].TableListSolder.Count; j++)
                            {
                                {
                                    
                                        //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                        //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 && //UsePenaltyRegardMechnisamT)
                                        //  if (SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() == 0)
                                        //    continue;
                                        int CDummy = ChessRules.CurrentOrder;
                                        int COrder = Order;
                                        
                                            ChessRules.CurrentOrder *= -1;
                                            Order *= -1;
                                            Do = 0;
                                            if (UsePenaltyRegardMechnisamT)
                                            {
                                                for (int ij = 0; ij < SolderesOnTable[i].SoldierThinking[k].AStarGreedy.Count - 1; ij++)
                                                    SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij]);
                                                Order = COrder;
                                                ChessRules.CurrentOrder = CDummy;

                                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                    continue;
                                            }
                                       
                                        Order = COrder;
                                        ChessRules.CurrentOrder = CDummy;
                                        //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                        //)
                                        if ((SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 && SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || SolderesOnTable[i].WinOcuuredatChiled >= 1 || SolderesOnTable[i].WinOcuuredatChiled >= 2 || SolderesOnTable[i].WinOcuuredatChiled >= 3)
                                        {
                                            //Set Table and Huristic Value and Syntax.
                                            Act = true;
                                            Object On = new Object();
                                            lock (On)
                                            {

                                                AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                                AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                                                AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                                AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];


                                                Less = SolderesOnTable[i].SoldierThinking[k].NumberOfPenalties;
                                            }


                                            TableHuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];


                                            Object O = new Object();
                                            lock (O)
                                            {
                                                ThingsConverter.ActOfClickEqualTow = true;
                                            }
                                            SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                            int Sign = 1;
                                            if (a == Color.Brown)
                                                Sign = -1;


                                            //If there is Soldier Convert.
                                            if (SolderesOnTable[i].Convert)
                                            {

                                                if (SolderesOnTable[i].ConvertedToMinister)
                                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                                else if (SolderesOnTable[i].ConvertedToCastle)
                                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                                else if (SolderesOnTable[i].ConvertedToHourse)
                                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                                else if (SolderesOnTable[i].ConvertedToElefant)
                                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;




                                            }
                                            RegardOccurred = true;
                                            //if (SolderesOnTable[i].WinOcuuredatChiled >= 1 || SolderesOnTable[i].WinOcuuredatChiled >= 2 || SolderesOnTable[i].WinOcuuredatChiled >= 3)
                                            // Less = Int32.MaxValue;
                                            //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                            //return TableHuristic;
                                            continue;
                                        }

                                        //When There is No Movments in Such Order Enemy continue.
                                        Object ol = new Object();
                                        lock (ol)
                                        {
                                            if (Order != AllDraw.OrderPlate)
                                                if (SolderesOnTable[i].SoldierThinking[0].NumberOfPenalties < Less)
                                                    continue;

                                            //When There is greater Huristic Movments.
                                            if (SolderesOnTable[i].SoldierThinking[0].NumberOfPenalties < Less)
                                            {


                                                //retrive table of current huristic.
                                                int[,] TableS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];
                                                int[,] TableSS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];

                                                //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                                if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                                {
                                                    
                                                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                            continue;
                                                   

                                                }
                                                //When there is not Penalty regard mechanism.
                                                //if (!UsePenaltyRegardMechnisamT)
                                                {
                                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 1,CloneATable(TableS), Order, SolderesOnTable[i].SoldierThinking[k].Row, SolderesOnTable[i].SoldierThinking[k].Column);
                                                    //If there is kish or kshachamaz Order.
                                                    if (AB.Check(TableS, Order))
                                                    {
                                                        //When Order is Gray.
                                                        if (Order== 1)
                                                        {
                                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                            if (AB.CheckGray)
                                                                continue;
                                                        }
                                                        else
                                                        {
                                                            //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                            if (AB.CheckBrown)
                                                                continue;
                                                        }
                                                    }
                                                    // }
                                                    else
                                                    {

                                                    }
                                                }
                                                //Sodleirs Initiate.
                                                RW1 = i;
                                                CL1 = k;
                                                Ki1 = j;
                                                RW2 = -1;
                                                CL2 = -1;
                                                Ki2 = -1;
                                                RW3 = -1;
                                                CL3 = -1;
                                                Ki3 = -1;
                                                RW4 = -1;
                                                CL4 = -1;
                                                Ki4 = -1;
                                                RW5 = -1;
                                                CL5 = -1;
                                                Ki5 = -1;
                                                RW6 = -1;
                                                CL6 = -1;
                                                Ki6 = -1;
                                                //Set Max of Soldier.
                                                MaxLess1 = (SolderesOnTable[RW1].SoldierThinking[CL1].NumberOfPenalties
                                                    );
                                                //When Soldeirs is Greater than Others these Set Max.
                                                if (MaxLess1 > MaxLess2)
                                                    MaxLess2 = -1;
                                                if (MaxLess1 > MaxLess3)
                                                    MaxLess3 = -1;
                                                if (MaxLess1 > MaxLess4)
                                                    MaxLess4 = -1;
                                                if (MaxLess1 > MaxLess5)
                                                    MaxLess5 = -1;
                                                if (MaxLess1 > MaxLess6)
                                                    MaxLess6 = -1;

                                                if (AStarGreedyi == 1)
                                                {
                                                    Object O = new Object();
                                                    lock (O)
                                                    {
                                                        if (Order== 1)
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Sodier By Bob!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                        else//If Order is Brown.
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Sodier By Alice!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                    }
                                                    //Set Table and Huristic Value and Syntax.
                                                    Act = true;
                                                    Object On = new Object();
                                                    lock (On)
                                                    {
                                                        AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                                        AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                                                        AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                                        AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
                                                    }

                                                    Less = SolderesOnTable[i].SoldierThinking[k].NumberOfPenalties;


                                                    TableHuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];


                                                    Object O1 = new Object();
                                                    lock (O1)
                                                    {
                                                        ThingsConverter.ActOfClickEqualTow = true;
                                                    }
                                                    SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                                    int Sign = 1;
                                                    if (a == Color.Brown)
                                                        Sign = -1;
                                                    //If there is Soldier Convert.
                                                    if (SolderesOnTable[i].Convert)
                                                    {

                                                        if (SolderesOnTable[i].ConvertedToMinister)
                                                            TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                                        else if (SolderesOnTable[i].ConvertedToCastle)
                                                            TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                                        else if (SolderesOnTable[i].ConvertedToHourse)
                                                            TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                                        else if (SolderesOnTable[i].ConvertedToElefant)
                                                            TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;





                                                    }
                                                }


                                            }
                                            else
                                            {
                                                //Set Table and Huristic Value and Syntax.
                                                
                                                    if (AStarGreedyi == 1)
                                                    {

                                                        //TakeRoot.Pointer = this;
                                                        //Found of Max Non Probable Movments.
                                                        Founded.Clear();
                                                        int LessB = Int32.MinValue;
                                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                        RW1 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                        CL1 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                        Ki1 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                        if (Founded[0] != MaxSoldeirFounded)
                                                            continue;
                                                        Act = true;
                                                        Object On = new Object();
                                                        lock (On)
                                                        {
                                                            AllDraw.LastRow = SolderesOnTable[RW1].SoldierThinking[CL1].Row;
                                                            AllDraw.LastColumn = SolderesOnTable[RW1].SoldierThinking[CL1].Column;
                                                            AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                                            AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
                                                        }
                                                        Less = SolderesOnTable[RW1].SoldierThinking[CL1].ReturnHuristic(RW1, Ki1, Order, false,ref HaveKilled);


                                                        TableHuristic = SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1];


                                                        Object O1 = new Object();
                                                        lock (O1)
                                                        {
                                                            ThingsConverter.ActOfClickEqualTow = true;
                                                        }
                                                        SolderesOnTable[RW1].ConvertOperation(SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], a, SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1], Order, false, i);
                                                        int Sign = 1;
                                                        if (a == Color.Brown)
                                                            Sign = -1;
                                                        //If there is Soldier Convert.
                                                        if (SolderesOnTable[RW1].Convert)
                                                        {

                                                            if (SolderesOnTable[RW1].ConvertedToMinister)
                                                                TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 5 * Sign;
                                                            else if (SolderesOnTable[RW1].ConvertedToCastle)
                                                                TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 4 * Sign;
                                                            else if (SolderesOnTable[RW1].ConvertedToHourse)
                                                                TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 3 * Sign;
                                                            else if (SolderesOnTable[RW1].ConvertedToElefant)
                                                                TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 2 * Sign;





                                                        }
                                                        Object O = new Object();
                                                        lock (O)
                                                        {
                                                            if (Order== 1)
                                                            {
                                                                OutPut.Append("\r\nChess Huristic Sodier By Bob!");
                                                                //THIS.RefreshBoxText();
                                                            }
                                                            else//If Order is Brown.
                                                            {
                                                                OutPut.Append("\r\nChess Huristic Sodier By Alice!");
                                                                //THIS.RefreshBoxText();
                                                            }
                                                        }
                                                    }
                                               
                                            }
                                        }

                                   
                                }
                            }

                       
                    
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                   

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;

                }
                //Do For Remaining Objects same as Soldeir Documentation.
                for (i = 0; i < ElefantMidle; i++)
                {
                    for (int k = 0; k < AllDraw.ElefantMovments; k++)
                        
                            for (j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[k] != null && ElephantOnTable[i].ElefantThinking[k] != null && j < ElephantOnTable[i].ElefantThinking[k].TableListElefant.Count; j++)
                            {
                                {
                                    
                                        //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                        ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                                        //    if (ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                                        //        continue;
                                        int CDummy = ChessRules.CurrentOrder;
                                        int COrder = Order;
                                        
                                            ChessRules.CurrentOrder *= -1;
                                            Order *= -1;
                                            Do = 0;
                                            if (UsePenaltyRegardMechnisamT)
                                            {
                                                for (int ij = 0; ij < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1; ij++)
                                                    ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij]);
                                                Order = COrder;
                                                ChessRules.CurrentOrder = CDummy;
                                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                    continue;
                                            }
                                       
                                        Order = COrder;
                                        ChessRules.CurrentOrder = CDummy;
                                        //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                        //)
                                        if ((ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 && ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || ElephantOnTable[i].WinOcuuredatChiled >= 1 || ElephantOnTable[i].WinOcuuredatChiled >= 2 || ElephantOnTable[i].WinOcuuredatChiled >= 3)
                                        {

                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                                AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                                                AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                                AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];


                                                Act = true;
                                                Less = ElephantOnTable[i].ElefantThinking[k].NumberOfPenalties;
                                            }
                                            TableHuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                            //if (ElephantOnTable[i].WinOcuuredatChiled >= 1 || ElephantOnTable[i].WinOcuuredatChiled >= 2 || ElephantOnTable[i].WinOcuuredatChiled >= 3)
                                            //Less = Int32.MaxValue;
                                            RegardOccurred = true;
                                            //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                            //return TableHuristic;
                                            continue;

                                        }

                                        Object ol = new Object();
                                        lock (ol)
                                        {
                                            //When There is No Movments in Such Order Enemy continue.
                                            if (Order != AllDraw.OrderPlate)
                                                if (ElephantOnTable[i].ElefantThinking[0].NumberOfPenalties < Less)
                                                    continue;
                                            //When There is greater Huristic Movments.

                                            if (ElephantOnTable[i].ElefantThinking[0].NumberOfPenalties < Less)
                                            {


                                                //retrive table of current huristic.
                                                int[,] TableS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                                int[,] TableSS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                                //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                                if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                                {
                                                    
                                                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                            continue;
                                                   


                                                }
                                                //When there is not Penalty regard mechanism.
                                                //if (!UsePenaltyRegardMechnisamT)
                                                {
                                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 2,CloneATable(TableS), Order, -1, -1);
                                                    //If there is kish or kshachamaz Order.
                                                    if (AB.Check(TableS, Order))
                                                    {
                                                        //When Order is Gray.
                                                        if (Order== 1)
                                                        {
                                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                            if (AB.CheckGray)
                                                                continue;
                                                        }
                                                        else
                                                        {
                                                            //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                            if (AB.CheckBrown)
                                                                continue;
                                                        }
                                                    }
                                                    else
                                                    {

                                                    }

                                                }
                                                RW2 = i;
                                                CL2 = k;
                                                Ki2 = j;
                                                RW1 = -1;
                                                CL1 = -1;
                                                Ki1 = -1;
                                                RW3 = -1;
                                                CL3 = -1;
                                                Ki3 = -1;
                                                RW4 = -1;
                                                CL4 = -1;
                                                Ki4 = -1;
                                                RW5 = -1;
                                                CL5 = -1;
                                                Ki5 = -1;
                                                RW6 = -1;
                                                CL6 = -1;
                                                Ki6 = -1;
                                                MaxLess2 = (ElephantOnTable[RW2].ElefantThinking[CL2].NumberOfPenalties);
                                                if (MaxLess2 > MaxLess1)
                                                    MaxLess1 = -1;
                                                if (MaxLess2 > MaxLess3)
                                                    MaxLess3 = -1;
                                                if (MaxLess2 > MaxLess4)
                                                    MaxLess4 = -1;
                                                if (MaxLess2 > MaxLess5)
                                                    MaxLess5 = -1;
                                                if (MaxLess2 > MaxLess6)
                                                    MaxLess6 = -1;

                                                if (AStarGreedyi == 1)
                                                {
                                                    Object O = new Object();
                                                    lock (O)
                                                    {
                                                        if (Order== 1)
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Elephant By Bob!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                        else//If Order is Brown.
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Elephant By Alice!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                    }

                                                    Object On = new Object();
                                                    lock (On)
                                                    {
                                                        AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                                        AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                                                        AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                                        AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
                                                    }
                                                    Act = true;
                                                    Less = ElephantOnTable[i].ElefantThinking[k].NumberOfPenalties;
                                                    TableHuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                                }
                                            }
                                            else
                                            {

                                                
                                                    if (AStarGreedyi == 1)
                                                    {
                                                        //TakeRoot.Pointer = this;
                                                        //Found of Max Non Probable Movments.
                                                        Founded.Clear();
                                                        int LessB = Int32.MinValue;
                                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                        RW2 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                        CL2 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                        Ki2 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                        if (Founded[0] != MaxElephntFounded)
                                                            continue;

                                                        Object On = new Object();
                                                        lock (On)
                                                        {
                                                            AllDraw.LastRow = ElephantOnTable[RW2].ElefantThinking[CL2].Row;
                                                            AllDraw.LastColumn = ElephantOnTable[RW2].ElefantThinking[CL2].Column;
                                                            AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                                            AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
                                                        }
                                                        Act = true;
                                                        Less = ElephantOnTable[RW2].ElefantThinking[CL2].ReturnHuristic(RW2, Ki2, Order, false,ref HaveKilled);
                                                        TableHuristic = ElephantOnTable[RW2].ElefantThinking[CL2].TableListElefant[Ki2];
                                                        Object O = new Object();
                                                        lock (O)
                                                        {
                                                            if (Order== 1)
                                                            {
                                                                OutPut.Append("\r\nChess Huristic Sodier By Bob!");
                                                                //THIS.RefreshBoxText();
                                                            }
                                                            else//If Order is Brown.
                                                            {
                                                                OutPut.Append("\r\nChess Huristic Sodier By Alice!");
                                                                //THIS.RefreshBoxText();
                                                            }
                                                        }
                                                    }
                                               
                                            }
                                        }
                                   
                                }

                            }
                       

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }

                for (i = 0; i < HourseMidle; i++)
                {
                    for (int k = 0; k < AllDraw.HourseMovments; k++)
                        
                            for (j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[k] != null && HoursesOnTable[i].HourseThinking[k] != null && j < HoursesOnTable[i].HourseThinking[k].TableListHourse.Count; j++)
                            {
                                {
                                    
                                        //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                        ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                                        //     if (HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() == 0)
                                        //       continue;
                                        int CDummy = ChessRules.CurrentOrder;
                                        int COrder = Order;
                                        
                                            ChessRules.CurrentOrder *= -1;
                                            Order *= -1;
                                            Do = 0;
                                            if (UsePenaltyRegardMechnisamT)
                                            {
                                                for (int ij = 0; ij < HoursesOnTable[i].HourseThinking[k].AStarGreedy.Count - 1; ij++)
                                                    HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij]);
                                                Order = COrder;
                                                ChessRules.CurrentOrder = CDummy;
                                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                    continue;
                                            }

                                       
                                        Order = COrder;
                                        ChessRules.CurrentOrder = CDummy;
                                        //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                        //)
                                        if ((HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 && HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || HoursesOnTable[i].WinOcuuredatChiled >= 1 || HoursesOnTable[i].WinOcuuredatChiled >= 2 || HoursesOnTable[i].WinOcuuredatChiled >= 3)
                                        {
                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                                AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                                                AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                                AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];

                                                Act = true;
                                                Less = HoursesOnTable[i].HourseThinking[k].NumberOfPenalties;
                                            }
                                            TableHuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                            RegardOccurred = true;
                                            //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                            //return TableHuristic;
                                            //if (HoursesOnTable[i].WinOcuuredatChiled >= 1 || HoursesOnTable[i].WinOcuuredatChiled >= 2 || HoursesOnTable[i].WinOcuuredatChiled >= 3)
                                            //Less = Int32.MaxValue;
                                            continue;

                                        }
                                        Object ol = new Object();
                                        lock (ol)
                                        {
                                            //When There is No Movments in Such Order Enemy continue.
                                            if (Order != AllDraw.OrderPlate)
                                                if (HoursesOnTable[i].HourseThinking[0].NumberOfPenalties < Less)
                                                    continue;
                                            //When There is greater Huristic Movments.
                                            if (HoursesOnTable[i].HourseThinking[0].NumberOfPenalties < Less)
                                            {

                                                //retrive table of current huristic.
                                                int[,] TableS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                                int[,] TableSS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                                {
                                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                                    if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                                    {
                                                        
                                                            if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                                continue;
                                                       

                                                    }
                                                    //When there is not Penalty regard mechanism.
                                                    //if (!UsePenaltyRegardMechnisamT)
                                                    {
                                                        AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 3,CloneATable(TableS), Order, HoursesOnTable[i].HourseThinking[k].Row, HoursesOnTable[i].HourseThinking[k].Column);
                                                        //If there is kish or kshachamaz Order.
                                                        if (AB.Check(TableS, Order))
                                                        {
                                                            //When Order is Gray.
                                                            if (Order== 1)
                                                            {
                                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                                if (AB.CheckGray)
                                                                    continue;
                                                            }
                                                            else
                                                            {
                                                                //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                                if (AB.CheckBrown)
                                                                    continue;
                                                            }
                                                        }
                                                        else
                                                        {

                                                        }
                                                    }


                                                }
                                                RW3 = i;
                                                CL3 = k;
                                                Ki3 = j;
                                                RW1 = -1;
                                                CL1 = -1;
                                                Ki1 = -1;
                                                RW2 = -1;
                                                CL2 = -1;
                                                Ki2 = -1;
                                                RW4 = -1;
                                                CL4 = -1;
                                                Ki4 = -1;
                                                RW5 = -1;
                                                CL5 = -1;
                                                Ki5 = -1;
                                                RW6 = -1;
                                                CL6 = -1;
                                                Ki6 = -1;
                                                MaxLess3 = (HoursesOnTable[RW3].HourseThinking[CL3].NumberOfPenalties);
                                                if (MaxLess3 > MaxLess1)
                                                    MaxLess1 = -1;
                                                if (MaxLess3 > MaxLess2)
                                                    MaxLess2 = -1;
                                                if (MaxLess3 > MaxLess4)
                                                    MaxLess4 = -1;
                                                if (MaxLess3 > MaxLess5)
                                                    MaxLess5 = -1;
                                                if (MaxLess3 > MaxLess6)
                                                    MaxLess6 = -1;

                                                if (AStarGreedyi == 1)
                                                {
                                                    Object O = new Object();
                                                    lock (O)
                                                    {
                                                        if (Order== 1)
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Hourse By Bob!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                        else//If Order is Brown.
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Hourse By Alice!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                    }
                                                    //Set Table and Huristic Value and Syntax.

                                                    Object On = new Object();
                                                    lock (On)
                                                    {
                                                        AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                                        AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                                                        AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                                        AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
                                                    }
                                                    Act = true;
                                                    Less = HoursesOnTable[i].HourseThinking[k].NumberOfPenalties;
                                                    TableHuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];

                                                }

                                            }
                                            else
                                            //Set Table and Huristic Value and Syntax.
                                            {
                                                
                                                    if (AStarGreedyi == 1)
                                                    {
                                                        //TakeRoot.Pointer = this;
                                                        //Found of Max Non Probable Movments.
                                                        Founded.Clear();
                                                        int LessB = Int32.MinValue;
                                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                        RW3 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                        CL3 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                        Ki3 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                        if (Founded[0] != MaxHourseFounded)
                                                            continue;

                                                        Object On = new Object();
                                                        lock (On)
                                                        {
                                                            AllDraw.LastRow = HoursesOnTable[RW3].HourseThinking[CL3].Row;
                                                            AllDraw.LastColumn = HoursesOnTable[RW3].HourseThinking[CL3].Column;
                                                            AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                                            AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
                                                        }
                                                        Act = true;
                                                        Less = HoursesOnTable[RW3].HourseThinking[CL3].ReturnHuristic(RW3, Ki3, Order, false,ref HaveKilled);
                                                        TableHuristic = HoursesOnTable[RW3].HourseThinking[CL3].TableListHourse[Ki3];
                                                        Object O = new Object();
                                                        lock (O)
                                                        {
                                                            if (Order== 1)
                                                            {
                                                                OutPut.Append("\r\nChess Huristic Sodier By Bob!");
                                                                //THIS.RefreshBoxText();
                                                            }
                                                            else//If Order is Brown.
                                                            {
                                                                OutPut.Append("\r\nChess Huristic Sodier By Alice!");
                                                                //THIS.RefreshBoxText();
                                                            }
                                                        }
                                                    }
                                               
                                            }
                                        }
                                   
                                }
                            }
                       
                    


                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                   

                }

                for (i = 0; i < CastleMidle; i++)
                {
                    for (int k = 0; k < AllDraw.CastleMovments; k++)
                        
                            for (j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[k] != null && CastlesOnTable[i].CastleThinking[k] != null && j < CastlesOnTable[i].CastleThinking[k].TableListCastle.Count; j++)
                            {
                                {
                                    
                                        //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                        ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                                        //    if (CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() == 0)
                                        //       continue;
                                        int CDummy = ChessRules.CurrentOrder;
                                        int COrder = Order;
                                        
                                            ChessRules.CurrentOrder *= -1;
                                            Order *= -1;
                                            Do = 0;
                                            if (UsePenaltyRegardMechnisamT)
                                            {
                                                for (int ij = 0; ij < CastlesOnTable[i].CastleThinking[k].AStarGreedy.Count - 1; ij++)
                                                    CastlesOnTable[i].CastleThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, CastlesOnTable[i].CastleThinking[k].AStarGreedy[ij]);
                                                Order = COrder;
                                                ChessRules.CurrentOrder = CDummy;
                                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                    continue;
                                            }

                                       
                                        Order = COrder;
                                        ChessRules.CurrentOrder = CDummy;
                                        //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                        //)
                                        if ((CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 && CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || CastlesOnTable[i].WinOcuuredatChiled >= 1 || CastlesOnTable[i].WinOcuuredatChiled >= 2 || CastlesOnTable[i].WinOcuuredatChiled >= 3)
                                        {

                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                                                AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                                                AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                                AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];

                                                Act = true;
                                                Less = CastlesOnTable[i].CastleThinking[k].NumberOfPenalties;
                                            }
                                            TableHuristic = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                            RegardOccurred = true;
                                            //if (CastlesOnTable[i].WinOcuuredatChiled >= 1 || CastlesOnTable[i].WinOcuuredatChiled >= 2 || CastlesOnTable[i].WinOcuuredatChiled >= 3)
                                            //Less = Int32.MaxValue;
                                            //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                            //return TableHuristic;
                                            continue;
                                        }
                                        Object ol = new Object();
                                        lock (ol)
                                        {
                                            //When There is No Movments in Such Order Enemy continue.
                                            if (Order != AllDraw.OrderPlate)
                                                if (CastlesOnTable[i].CastleThinking[0].NumberOfPenalties < Less) continue;
                                            //When There is greater Huristic Movments.
                                            if (CastlesOnTable[i].CastleThinking[0].NumberOfPenalties < Less)
                                            {

                                                //retrive table of current huristic.
                                                int[,] TableS = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                                int[,] TableSS = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                                //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                                if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                                {
                                                    
                                                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                            continue;
                                                   


                                                }
                                                //When there is not Penalty regard mechanism.
                                                //if (!UsePenaltyRegardMechnisamT)
                                                {
                                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 4,CloneATable(TableS), Order, CastlesOnTable[i].CastleThinking[k].Row, CastlesOnTable[i].CastleThinking[k].Column);
                                                    //If there is kish or kshachamaz Order.
                                                    if (AB.Check(TableS, Order))
                                                    {
                                                        //When Order is Gray.
                                                        if (Order== 1)
                                                        {
                                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                            if (AB.CheckGray)
                                                                continue;
                                                        }
                                                        else
                                                        {
                                                            //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                            if (AB.CheckBrown)
                                                                continue;
                                                        }
                                                    }
                                                    else
                                                    {

                                                    }

                                                }
                                                RW4 = i;
                                                CL4 = k;
                                                Ki4 = j;
                                                RW1 = -1;
                                                CL1 = -1;
                                                Ki1 = -1;
                                                RW2 = -1;
                                                CL2 = -1;
                                                Ki2 = -1;
                                                RW3 = -1;
                                                CL3 = -1;
                                                Ki3 = -1;
                                                RW5 = -1;
                                                CL5 = -1;
                                                Ki5 = -1;
                                                RW6 = -1;
                                                CL6 = -1;
                                                Ki6 = -1;
                                                MaxLess4 = (CastlesOnTable[RW4].CastleThinking[CL4].NumberOfPenalties);
                                                if (MaxLess4 > MaxLess1)
                                                    MaxLess1 = -1;
                                                if (MaxLess4 > MaxLess2)
                                                    MaxLess2 = -1;
                                                if (MaxLess4 > MaxLess3)
                                                    MaxLess3 = -1;
                                                if (MaxLess4 > MaxLess5)
                                                    MaxLess5 = -1;
                                                if (MaxLess4 > MaxLess6)
                                                    MaxLess6 = -1;


                                                if (AStarGreedyi == 1)
                                                {
                                                    Object O = new Object();
                                                    lock (O)
                                                    {
                                                        if (Order== 1)
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Castles By Bob!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                        else//If Order is Brown.
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Castles By Alice!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                    }
                                                    Object On = new Object();
                                                    lock (On)
                                                    {
                                                        AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                                                        AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                                                        AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                                        AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                                    }
                                                    Act = true;
                                                    Less = CastlesOnTable[i].CastleThinking[k].NumberOfPenalties;
                                                    TableHuristic = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];

                                                }
                                            }
                                            else//Set Table and Huristic Value and Syntax.
                                            {
                                                
                                                    if (AStarGreedyi == 1)
                                                    {
                                                        //TakeRoot.Pointer = this;
                                                        //Found of Max Non Probable Movments.
                                                        Founded.Clear();
                                                        int LessB = Int32.MinValue;
                                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                        RW4 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                        CL4 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                        Ki4 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                        if (Founded[0] != MaxCastlesFounded)
                                                            continue;

                                                        Object On = new Object();
                                                        lock (On)
                                                        {
                                                            AllDraw.LastRow = CastlesOnTable[RW4].CastleThinking[CL4].Row;
                                                            AllDraw.LastColumn = CastlesOnTable[RW4].CastleThinking[CL4].Column;
                                                            AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                                            AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                                        }
                                                        Act = true;
                                                        Less = CastlesOnTable[RW4].CastleThinking[CL4].ReturnHuristic(RW4, Ki4, Order, false,ref HaveKilled);
                                                        TableHuristic = CastlesOnTable[RW4].CastleThinking[CL4].TableListCastle[Ki4];
                                                        Object O = new Object();
                                                        lock (O)
                                                        {
                                                            if (Order== 1)
                                                            {
                                                                OutPut.Append("\r\nChess Huristic Sodier By Bob!");
                                                                //THIS.RefreshBoxText();
                                                            }
                                                            else//If Order is Brown.
                                                            {
                                                                OutPut.Append("\r\nChess Huristic Sodier By Alice!");
                                                                //THIS.RefreshBoxText();
                                                            }
                                                        }
                                                    }
                                               
                                            }
                                        }
                                   
                                }
                            }
                       
                    
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                   

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }


                for (i = 0; i < MinisterMidle; i++)
                {
                    for (int k = 0; k < AllDraw.MinisterMovments; k++)
                        
                            for (j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[k] != null && MinisterOnTable[i].MinisterThinking[k] != null && j < MinisterOnTable[i].MinisterThinking[k].TableListMinister.Count; j++)
                            {
                                {
                                    //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                    ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                                    //    if (MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() == 0)
                                    //        continue;
                                    int CDummy = ChessRules.CurrentOrder;
                                    int COrder = Order;
                                    
                                        ChessRules.CurrentOrder *= -1;
                                        Order *= -1;
                                        Do = 0;
                                        if (UsePenaltyRegardMechnisamT)
                                        {
                                            for (int ij = 0; ij < MinisterOnTable[i].MinisterThinking[k].AStarGreedy.Count - 1; ij++)
                                                MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij]);
                                            Order = COrder;
                                            ChessRules.CurrentOrder = CDummy;
                                            ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                continue;
                                        }

                                   
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                    //)
                                    if ((MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 && MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || MinisterOnTable[i].WinOcuuredatChiled >= 1 || MinisterOnTable[i].WinOcuuredatChiled >= 2 || MinisterOnTable[i].WinOcuuredatChiled >= 3)
                                    {

                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                            AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                                            AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                            AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];

                                            Act = true;
                                            Less = MinisterOnTable[i].MinisterThinking[k].NumberOfPenalties;
                                        }
                                        TableHuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                        RegardOccurred = true;
                                        //if (MinisterOnTable[i].WinOcuuredatChiled >= 1 || MinisterOnTable[i].WinOcuuredatChiled >= 2 || MinisterOnTable[i].WinOcuuredatChiled >= 3)
                                        //Less = Int32.MaxValue;
                                        //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                        //return TableHuristic;
                                        continue;
                                    }
                                    Object ol = new Object();
                                    lock (ol)
                                    {
                                        if (Order != AllDraw.OrderPlate)
                                            if (MinisterOnTable[i].MinisterThinking[0].NumberOfPenalties < Less)
                                                continue;
                                        if (MinisterOnTable[i].MinisterThinking[0].NumberOfPenalties < Less)
                                        {

                                            //retrive table of current huristic.

                                            //retrive table of current huristic.
                                            int[,] TableS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                            int[,] TableSS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                            //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                            if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                            {
                                                
                                                    if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                        continue;
                                               

                                            }
                                            {
                                                //When there is not Penalty regard mechanism.
                                                //if (!UsePenaltyRegardMechnisamT)
                                                {
                                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 5,CloneATable(TableS), Order, MinisterOnTable[i].MinisterThinking[k].Row, MinisterOnTable[i].MinisterThinking[k].Column);
                                                    //If there is kish or kshachamaz Order.
                                                    if (AB.Check(TableS, Order))
                                                    {
                                                        //When Order is Gray.
                                                        if (Order== 1)
                                                        {
                                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                            if (AB.CheckGray)
                                                                continue;
                                                        }
                                                        else
                                                        {
                                                            //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                            if (AB.CheckBrown)
                                                                continue;
                                                        }
                                                    }
                                                    else
                                                    {

                                                    }
                                                }

                                            }
                                            RW5 = i;
                                            CL5 = k;
                                            Ki5 = j;
                                            RW1 = -1;
                                            CL1 = -1;
                                            Ki1 = -1;
                                            RW2 = -1;
                                            CL2 = -1;
                                            Ki2 = -1;
                                            RW3 = -1;
                                            CL3 = -1;
                                            Ki3 = -1;
                                            RW4 = -1;
                                            CL4 = -1;
                                            Ki4 = -1;
                                            RW6 = -1;
                                            CL6 = -1;
                                            Ki6 = -1;
                                            MaxLess5 = (MinisterOnTable[RW5].MinisterThinking[CL5].NumberOfPenalties);
                                            if (MaxLess5 > MaxLess1)
                                                MaxLess1 = -1;
                                            if (MaxLess5 > MaxLess2)
                                                MaxLess2 = -1;
                                            if (MaxLess5 > MaxLess3)
                                                MaxLess3 = -1;
                                            if (MaxLess5 > MaxLess4)
                                                MaxLess4 = -1;
                                            if (MaxLess5 > MaxLess6)
                                                MaxLess6 = -1;


                                            if (AStarGreedyi == 1)
                                            {
                                                Object O = new Object();
                                                lock (O)
                                                {
                                                    if (Order== 1)
                                                    {
                                                        OutPut.Append("\r\nChess Huristic Minister By Bob!");
                                                        //THIS.RefreshBoxText();
                                                    }
                                                    else//If Order is Brown.
                                                    {
                                                        OutPut.Append("\r\nChess Huristic Minister By Alice!");
                                                        //THIS.RefreshBoxText();
                                                    }   //Set Table and Huristic Value and Syntax.
                                                }
                                                Object On = new Object();
                                                lock (On)
                                                {
                                                    AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                                    AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                                                    AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                                    AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
                                                }
                                                Act = true;
                                                Less = MinisterOnTable[i].MinisterThinking[k].NumberOfPenalties;
                                                TableHuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];

                                            }
                                        }
                                        else//Set Table and Huristic Value and Syntax.
                                        {
                                            
                                                if (AStarGreedyi == 1)
                                                {
                                                    //TakeRoot.Pointer = this;
                                                    //Found of Max Non Probable Movments.
                                                    Founded.Clear();
                                                    int LessB = Int32.MinValue;
                                                    BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                    RW5 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                    CL5 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                    Ki5 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                    if (Founded[0] != MaxMinisterFounded)
                                                        continue;

                                                    Object On = new Object();
                                                    lock (On)
                                                    {
                                                        AllDraw.LastRow = MinisterOnTable[RW5].MinisterThinking[CL5].Row;
                                                        AllDraw.LastColumn = MinisterOnTable[RW5].MinisterThinking[CL5].Column;
                                                        AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                                        AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
                                                    }
                                                    Act = true;
                                                    Less = MinisterOnTable[RW5].MinisterThinking[CL5].ReturnHuristic(RW5, Ki5, Order, false,ref HaveKilled);
                                                    TableHuristic = MinisterOnTable[RW5].MinisterThinking[CL5].TableListMinister[Ki5];
                                                    Object O = new Object();
                                                    lock (O)
                                                    {
                                                        if (Order== 1)
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Sodier By Bob!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                        else//If Order is Brown.
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Sodier By Alice!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                    }
                                                }
                                           
                                        }
                                    }
                                }
                            }
                       
                    
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                   

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }

                for (i = 0; i < KingMidle; i++)
                {
                    for (int k = 0; k < AllDraw.KingMovments; k++)
                        
                            for (j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[k] != null && KingOnTable[i].KingThinking[k] != null && j < KingOnTable[i].KingThinking[k].TableListKing.Count; j++)
                            {
                                {
                                    
                                        //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                        ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                                        //   if (KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() == 0)
                                        //       continue;
                                        int CDummy = ChessRules.CurrentOrder;
                                        int COrder = Order;
                                        
                                            ChessRules.CurrentOrder *= -1;
                                            Order *= -1;
                                            Do = 0;
                                            if (UsePenaltyRegardMechnisamT)
                                            {
                                                for (int ij = 0; ij < KingOnTable[i].KingThinking[k].AStarGreedy.Count - 1; ij++)
                                                    KingOnTable[i].KingThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, KingOnTable[i].KingThinking[k].AStarGreedy[ij]);
                                                Order = COrder;
                                                ChessRules.CurrentOrder = CDummy;
                                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                    continue;
                                            }

                                       
                                        Order = COrder;
                                        ChessRules.CurrentOrder = CDummy;
                                        //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                        //)
                                        if ((KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() != 0 && KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)
                                        {
                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                                                AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                                                AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                                AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];

                                                Act = true;
                                                Less = KingOnTable[i].KingThinking[k].NumberOfPenalties;
                                            }
                                            TableHuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
                                            RegardOccurred = true;
                                            //if (KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)
                                            //Less = Int32.MaxValue;
                                            //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                            //return TableHuristic;
                                            continue;
                                        }
                                        Object ol = new Object();
                                        lock (ol)
                                        {

                                            //When There is No Movments in Such Order Enemy continue.
                                            if (Order != AllDraw.OrderPlate)
                                                if (KingOnTable[i].KingThinking[0].NumberOfPenalties < Less)
                                                    continue;
                                            //When There is greater Huristic Movments.
                                            if (KingOnTable[i].KingThinking[0].NumberOfPenalties < Less)
                                            {

                                                //retrive table of current huristic.

                                                //retrive table of current huristic.
                                                int[,] TableS = KingOnTable[i].KingThinking[k].TableListKing[j];
                                                int[,] TableSS = KingOnTable[i].KingThinking[k].TableListKing[j];
                                                //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                                if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                                {
                                                    
                                                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                            continue;
                                                   
                                                }
                                                //When there is not Penalty regard mechanism.
                                                //if (!UsePenaltyRegardMechnisamT)
                                                {
                                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 6,CloneATable(TableS), Order, KingOnTable[i].KingThinking[k].Row, KingOnTable[i].KingThinking[k].Column);
                                                    //If there is kish or kshachamaz Order.
                                                    if (AB.Check(TableS, Order))
                                                    {
                                                        //When Order is Gray.
                                                        if (Order== 1)
                                                        {
                                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                            if (AB.CheckGray)
                                                                continue;
                                                        }
                                                        else
                                                        {
                                                            //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                            if (AB.CheckBrown)
                                                                continue;
                                                        }
                                                    }
                                                    else
                                                    {

                                                    }


                                                }


                                                RW6 = i;
                                                CL6 = k;
                                                Ki6 = j;
                                                RW1 = -1;
                                                CL1 = -1;
                                                Ki1 = -1;
                                                RW2 = -1;
                                                CL2 = -1;
                                                Ki2 = -1;
                                                RW3 = -1;
                                                CL3 = -1;
                                                Ki3 = -1;
                                                RW4 = -1;
                                                CL4 = -1;
                                                Ki4 = -1;
                                                RW5 = -1;
                                                CL5 = -1;
                                                Ki5 = -1;
                                                MaxLess6 = (KingOnTable[RW6].KingThinking[CL6].NumberOfPenalties);
                                                if (MaxLess6 > MaxLess1)
                                                    MaxLess1 = -1;
                                                if (MaxLess6 > MaxLess2)
                                                    MaxLess2 = -1;
                                                if (MaxLess6 > MaxLess3)
                                                    MaxLess3 = -1;
                                                if (MaxLess6 > MaxLess4)
                                                    MaxLess4 = -1;
                                                if (MaxLess6 > MaxLess5)
                                                    MaxLess5 = -1;


                                                if (AStarGreedyi == 1)
                                                {
                                                    Object O = new Object();
                                                    lock (O)
                                                    {
                                                        if (Order== 1)
                                                        {
                                                            OutPut.Append("\r\nChess Huristic King By Bob!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                        else//If Order is Brown.
                                                        {
                                                            OutPut.Append("\r\nChess Huristic King By Alice!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                    }
                                                    Object On = new Object();
                                                    lock (On)
                                                    {
                                                        AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                                                        AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                                                        AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                                        AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
                                                    }
                                                    Act = true;
                                                    Less = KingOnTable[i].KingThinking[k].NumberOfPenalties;
                                                    TableHuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
                                                }


                                            }
                                            else//Set Table and Huristic Value and Syntax.
                                            {
                                                
                                                    if (AStarGreedyi == 1)
                                                    {
                                                        //TakeRoot.Pointer = this;
                                                        //Found of Max Non Probable Movments.
                                                        Founded.Clear();
                                                        int LessB = Int32.MinValue;
                                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                        RW6 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                        CL6 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                        Ki6 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                        if (Founded[0] != MaxKingFounded)
                                                            continue;

                                                        Object On = new Object();
                                                        lock (On)
                                                        {
                                                            AllDraw.LastRow = KingOnTable[RW6].KingThinking[CL6].Row;
                                                            AllDraw.LastColumn = KingOnTable[RW6].KingThinking[CL6].Column;
                                                            AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                                            AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
                                                        }

                                                        Act = true;
                                                        Less = KingOnTable[RW6].KingThinking[CL6].ReturnHuristic(RW6, Ki6, Order, false,ref HaveKilled);
                                                        TableHuristic = KingOnTable[RW6].KingThinking[CL6].TableListKing[Ki6];
                                                        Object O = new Object();
                                                        lock (O)
                                                        {
                                                            if (Order== 1)
                                                            {
                                                                OutPut.Append("\r\nChess Huristic Sodier By Bob!");
                                                                //THIS.RefreshBoxText();
                                                            }
                                                            else//If Order is Brown.
                                                            {
                                                                OutPut.Append("\r\nChess Huristic Sodier By Alice!");
                                                                //THIS.RefreshBoxText();
                                                            }
                                                        }
                                                    }
                                               
                                            }
                                        }
                                   
                                }
                                // else
                                {
                                }

                            }
                       
                    
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                   

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchPenalties:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        void StringHuristics(int Obj, int Sec, bool AA, int Do, int WinOcuuredatChiled, int LoseOcuuredatChiled)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            String SOut = "";
            if (Obj == 1)
            {
                SOut = "Soldier ";
            }
            else
                if (Obj == 2)
            {
                SOut = "Elephant ";
            }
            else
                if (Obj == 3)
            {
                SOut = "Hourse ";
            }
            else
                if (Obj == 4)
            {
                SOut = "Castle ";
            }
            else
                if (Obj == 5)
            {
                SOut = "Minister ";
            }
            else
                    if (Obj == 6)
            {
                SOut = "King ";
            }
            SOut += "AStar Huristics ";
            if (Sec == 1)
                SOut += " -Initiatetion- ";
            if (Sec == 2)
                SOut += " -Regard- ";
            if (Sec == 3)
                SOut += " -Foundation Greatest- ";
            if (WinOcuuredatChiled >= 1)
                SOut += " At -WinKing Checked Mate- is active For Eneter Regard- ";
            if (LoseOcuuredatChiled <= -1)
                SOut += " At -LoseKing Checked Mate- is active For Eneter Penelty- ";
            if (AA)
                SOut += " '-AA-' is Active due to Regard Enter- ";
            if (Do == 1)
                SOut += " '-Do-' is Active due to Regard Enter- ";
            SOut += " With Huristic Count " + AllDraw.Less;
            Object O = new Object();
            lock (O)
            {
                OutPut.Append("\r\n" + SOut);
            }
            Thread.Sleep(10);
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("StringHuristics:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void SaveLess(int i, int j, int k, int Kind, ref int Less, bool AA, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            if (Kind == 1)
            {
                Less = SolderesOnTable[i].SoldierThinking[k].ReturnHuristic(i, j, Order, AA, ref HaveKilled);
            }
            else
        if (Kind == 2)
            {
                Less = ElephantOnTable[i].ElefantThinking[k].ReturnHuristic(i, j, Order, AA, ref HaveKilled);
            }
            else
        if (Kind == 3)
            {
                Less = HoursesOnTable[i].HourseThinking[k].ReturnHuristic(i, j, Order, AA, ref HaveKilled);
            }
            else
        if (Kind == 4)
            {
                Less = CastlesOnTable[i].CastleThinking[k].ReturnHuristic(i, j, Order, AA, ref HaveKilled);
            }
            else
        if (Kind == 5)
            {
                Less = MinisterOnTable[i].MinisterThinking[k].ReturnHuristic(i, j, Order, AA, ref HaveKilled);
            }
            else
        if (Kind == 6)
            {
                Less = KingOnTable[i].KingThinking[k].ReturnHuristic(i, j, Order, AA, ref HaveKilled);
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SaveLess:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }



        void SaveTableHuristic(int i, int j, int k, int Kind, ref int[,] TableHuristic)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            if (Kind == 1)
            {
                TableHuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];
            }
            else
                if (Kind == 2)
            {
                TableHuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
            }
            else
                if (Kind == 3)
            {
                TableHuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
            }
            else
                if (Kind == 4)
            {
                TableHuristic = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
            }
            else
                if (Kind == 5)
            {
                TableHuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
            }
            else
                if (Kind == 6)
            {
                TableHuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SaveTableHuristic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void SaveBeginEndLocation(int i, int j, int k, int Kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            if (Kind == 1)
            {
                AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
            }
            else
                 if (Kind == 2)
            {
                AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
            }
            else
                 if (Kind == 3)
            {
                AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
            }
            else
                 if (Kind == 4)
            {
                AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
            }
            else
                 if (Kind == 5)
            {
                AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
            }
            else
                 if (Kind == 6)
            {
                AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SaveBeginEndLocation:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }

        bool HuristicRegardSection(int i, int j, int k, ref bool Act, ref int[,] TableHuristic, ref bool AA, Color a, int Kind, ref int Do, int AStarGreedyi, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool continued = false;
            if (Kind == 1)
            {
                if ((SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 && SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((((Do == 1 || AA) && UsePenaltyRegardMechnisamT)) && UsePenaltyRegardMechnisamT) || SolderesOnTable[i].WinOcuuredatChiled >= 1 || SolderesOnTable[i].WinOcuuredatChiled >= 2 || SolderesOnTable[i].WinOcuuredatChiled >= 3)
                {
                    //Set Table and Huristic Value and Syntax.
                    Act = true;
                    Object On = new Object();
                    lock (On)
                    {
                        SaveBeginEndLocation(i, j, k, 1);

                        SaveTableHuristic(i, j, k, 1, ref TableHuristic);

                        SaveLess(i, j, k, 1, ref Less, AA, Order);
                    }

                    Object O = new Object();
                    lock (O)
                    {
                        ThingsConverter.ActOfClickEqualTow = true;
                    }

                    SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);

                    int Sign = 1;
                    if (a == Color.Brown)
                        Sign = -1;


                    //If there is Soldier Convert.
                    if (SolderesOnTable[i].Convert)
                    {

                        if (SolderesOnTable[i].ConvertedToMinister)
                            TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                        else if (SolderesOnTable[i].ConvertedToCastle)
                            TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                        else if (SolderesOnTable[i].ConvertedToHourse)
                            TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                        else if (SolderesOnTable[i].ConvertedToElefant)
                            TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;

                    }

                    RegardOccurred = true;

                    StringHuristics(1, 2, AA, Do, SolderesOnTable[i].WinOcuuredatChiled, SolderesOnTable[i].LoseOcuuredatChiled);

                    continued = true;
                }

            }
            else
            if (Kind == 2)
            {
                if ((ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 && ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || ElephantOnTable[i].WinOcuuredatChiled >= 1 || ElephantOnTable[i].WinOcuuredatChiled >= 2 || ElephantOnTable[i].WinOcuuredatChiled >= 3)
                {

                    Object On = new Object();
                    lock (On)
                    {
                        SaveBeginEndLocation(i, j, k, 2);

                        SaveTableHuristic(i, j, k, 2, ref TableHuristic);

                        SaveLess(i, j, k, 2, ref Less, AA, Order);
                    }

                    StringHuristics(2, 2, AA, Do, ElephantOnTable[i].WinOcuuredatChiled, ElephantOnTable[i].LoseOcuuredatChiled);

                    RegardOccurred = true;

                    continued = true;

                }
            }
            else
            if (Kind == 3)
            {
                if ((HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 && HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || HoursesOnTable[i].WinOcuuredatChiled >= 1 || HoursesOnTable[i].WinOcuuredatChiled >= 2 || HoursesOnTable[i].WinOcuuredatChiled >= 3)
                {
                    Object On = new Object();
                    lock (On)
                    {
                        SaveBeginEndLocation(i, j, k, 3);

                        SaveTableHuristic(i, j, k, 3, ref TableHuristic);

                        SaveLess(i, j, k, 3, ref Less, AA, Order);
                    }

                    RegardOccurred = true;

                    StringHuristics(3, 2, AA, Do, HoursesOnTable[i].WinOcuuredatChiled, HoursesOnTable[i].LoseOcuuredatChiled);

                    continued = true;

                }

            }
            else
            if (Kind == 4)
            {
                if ((CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 && CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || CastlesOnTable[i].WinOcuuredatChiled >= 1 || CastlesOnTable[i].WinOcuuredatChiled >= 2 || CastlesOnTable[i].WinOcuuredatChiled >= 3)
                {

                    Object On = new Object();
                    lock (On)
                    {
                        SaveBeginEndLocation(i, j, k, 4);

                        SaveTableHuristic(i, j, k, 4, ref TableHuristic);

                        SaveLess(i, j, k, 4, ref Less, AA, Order);
                    }

                    RegardOccurred = true;
                    StringHuristics(4, 2, AA, Do, CastlesOnTable[i].WinOcuuredatChiled, CastlesOnTable[i].LoseOcuuredatChiled);
                    //if (CastlesOnTable[i].WinOcuuredatChiled >= 1 || CastlesOnTable[i].WinOcuuredatChiled >= 2 || CastlesOnTable[i].WinOcuuredatChiled >= 3)
                    //Less = Int32.MaxValue;



                    //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                    //return TableHuristic;
                    continued = true;
                }
            }
            else
                if (Kind == 5)
            {
                if ((MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 && MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || MinisterOnTable[i].WinOcuuredatChiled >= 1 || MinisterOnTable[i].WinOcuuredatChiled >= 2 || MinisterOnTable[i].WinOcuuredatChiled >= 3)
                {

                    Object On = new Object();
                    lock (On)
                    {
                        SaveBeginEndLocation(i, j, k, 5);

                        SaveTableHuristic(i, j, k, 5, ref TableHuristic);

                        SaveLess(i, j, k, 5, ref Less, AA, Order);
                    }

                    TableHuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                    RegardOccurred = true;
                    StringHuristics(5, 2, AA, Do, MinisterOnTable[i].WinOcuuredatChiled, MinisterOnTable[i].LoseOcuuredatChiled);

                    continued = true;
                }
            }
            else
            if (Kind == 6)
            {
                if ((KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() != 0 && KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)
                {
                    Object On = new Object();
                    lock (On)
                    {
                        SaveBeginEndLocation(i, j, k, 6);

                        SaveTableHuristic(i, j, k, 6, ref TableHuristic);

                        SaveLess(i, j, k, 6, ref Less, AA, Order);
                    }

                    RegardOccurred = true;
                    StringHuristics(6, 2, AA, Do, KingOnTable[i].WinOcuuredatChiled, KingOnTable[i].LoseOcuuredatChiled);

                    //if (KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)
                    // Less = Int32.MaxValue;



                    //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                    //return TableHuristic;
                    continued = true;
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicRegardSection:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return continued;
        }
        void InitiateVars(int i, int j, int k, int Kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            RW1 = -1;
            CL1 = -1;
            Ki1 = -1;
            RW2 = -1;
            CL2 = -1;
            Ki2 = -1;
            RW3 = -1;
            CL3 = -1;
            Ki3 = -1;
            RW4 = -1;
            CL4 = -1;
            Ki4 = -1;
            RW5 = -1;
            CL5 = -1;
            Ki5 = -1;
            RW6 = -1;
            CL6 = -1;
            Ki6 = -1;
            //Sodleirs Initiate.
            if (Kind == 1)
            {
                RW1 = i;
                CL1 = k;
                Ki1 = j;
            }
            else
                if (Kind == 2)
            {
                RW2 = i;
                CL2 = k;
                Ki2 = j;
            }
            else
                if (Kind == 3)
            {
                RW3 = i;
                CL3 = k;
                Ki3 = j;
            }
            else
                if (Kind == 4)
            {
                RW4 = i;
                CL4 = k;
                Ki4 = j;
            }
            else
                if (Kind == 5)
            {
                RW5 = i;
                CL5 = k;
                Ki5 = j;
            }
            else
                if (Kind == 6)
            {
                RW6 = i;
                CL6 = k;
                Ki6 = j;
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateVars:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        bool CheckeHuristci(int[,] TableS, int Order, int i, int j, int k)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool continued = false;
            ChessRules AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 1,CloneATable(TableS), Order, SolderesOnTable[i].SoldierThinking[k].Row, SolderesOnTable[i].SoldierThinking[k].Column);
            //If there is kish or kshachamaz Order.
            if (AB.Check(TableS, Order))
            {
                //When Order is Gray.
                if (Order== 1)
                {
                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                    if (AB.CheckGray)
                        continued = true;
                }
                else
                {
                    //Continue when CheckBrown and AStarGreadyFirstSearch. 
                    if (AB.CheckBrown)
                        continued = true;
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CheckeHuristci:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return continued;
        }
        void OutputHuristic(int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {
                if (Order== 1)
                {
                    OutPut.Append("\r\nChess Huristic Elephant By Bob!");
                    //THIS.RefreshBoxText();
                }
                else//If Order is Brown.
                {
                    OutPut.Append("\r\nChess Huristic Elephant By Alice!");
                    //THIS.RefreshBoxText();
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("OutputHuristic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        bool HuristicMainBody(int i, int j, int k, ref bool Act, ref int[,] TableHuristic, ref bool CurrentTableHuristic, ref bool AA, Color a, int Kind, ref int Do, int AStarGreedyi, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool continued = false;

            if (Kind == 1)
            {
                if (SolderesOnTable[i].SoldierThinking[0].ReturnHuristic(i, j, Order, AA, ref HaveKilled) > Less)
                {

                    Object O11 = new Object();
                    lock (O11)
                    {
                        int[,] TableS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];

                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                        if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                        {
                            
                                if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                {
                                if (Order== 1)
                                AllDraw.OutPut.Append("\r\nHuristic Soldier By Bob was not Valid Movment!");
                                else
                                AllDraw.OutPut.Append("\r\nHuristic Soldier By Alice was not Valid Movment!");

                                    return true;
                                }
                           

                        }
                        //When there is not Penalty regard mechanism.
                        if (CheckeHuristci(TableS, Order, i, j, k))
                            return true;


                        InitiateVars(i, j, k, 1);

                        //Set Max of Soldier.
                        MaxLess1 = SolderesOnTable[RW1].SoldierThinking[CL1].ReturnHuristic(i, j, Order, AA, ref HaveKilled);
                        if (ThinkingChess.IsAtLeastOneKillerAtDraw)
                        {
                            if ((!KiilledForce(HaveKilled)) && (HaveKilled < 0))
                                return true;
                        }
                        if (!KillerForce(HaveKilled))
                            return true;

                        //When Soldeirs is Greater than Others these Set Max.
                        if (MaxLess1 > MaxLess2)
                            MaxLess2 = -1;
                        if (MaxLess1 > MaxLess3)
                            MaxLess3 = -1;
                        if (MaxLess1 > MaxLess4)
                            MaxLess4 = -1;
                        if (MaxLess1 > MaxLess5)
                            MaxLess5 = -1;
                        if (MaxLess1 > MaxLess6)
                            MaxLess6 = -1;

                        if (AStarGreedyi == 1)
                        {
                            OutputHuristic(Order);

                            //Set Table and Huristic Value and Syntax.
                            Act = true;
                            Object On = new Object();
                            lock (On)
                            {
                                SaveBeginEndLocation(i, j, k, 1);

                                SaveTableHuristic(i, j, k, 1, ref TableHuristic);

                                SaveLess(i, j, k, 1, ref Less, AA, Order);
                            }

                            StringHuristics(1, 3, AA, Do, SolderesOnTable[i].WinOcuuredatChiled, SolderesOnTable[i].LoseOcuuredatChiled);



                            Object O1 = new Object();
                            lock (O1)
                            {
                                ThingsConverter.ActOfClickEqualTow = true;
                            }
                            SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                            int Sign = 1;
                            if (a == Color.Brown)
                                Sign = -1;
                            //If there is Soldier Convert.
                            if (SolderesOnTable[i].Convert)
                            {

                                if (SolderesOnTable[i].ConvertedToMinister)
                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                else if (SolderesOnTable[i].ConvertedToCastle)
                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                else if (SolderesOnTable[i].ConvertedToHourse)
                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                else if (SolderesOnTable[i].ConvertedToElefant)
                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;

                            }
                        }
                    }
                }
            }
            else if (Kind == 2)
            {
                if (ElephantOnTable[i].ElefantThinking[0].ReturnHuristic(i, j, Order, AA, ref HaveKilled) > Less)
                {

                    Object O = new Object();
                    lock (O)
                    {
                        //ActionString = ThinkingChess.ActionsString; AllDraw.ActionStringReady = true;
                    }
                    //retrive table of current huristic.
                    int[,] TableS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                    {
                        
                            if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                            {
                            if (Order== 1)
                            AllDraw.OutPut.Append("\r\nHuristic Elephant By Bob was not Valid Movment!");
                            else
                            AllDraw.OutPut.Append("\r\nHuristic Elephant By Alice was not Valid Movment!");

                                return true;
                            }
                       


                    }
                    //When there is not Penalty regard mechanism.
                    if (CheckeHuristci(TableS, Order, i, j, k))
                        return true;


                    InitiateVars(i, j, k, 2);

                    MaxLess2 = (ElephantOnTable[RW2].ElefantThinking[CL2].ReturnHuristic(RW2, Ki2, Order, false, ref HaveKilled));

                    if (ThinkingChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(HaveKilled))
                        return true;

                    if (MaxLess2 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess2 > MaxLess3)
                        MaxLess3 = -1;
                    if (MaxLess2 > MaxLess4)
                        MaxLess4 = -1;
                    if (MaxLess2 > MaxLess5)
                        MaxLess5 = -1;
                    if (MaxLess2 > MaxLess6)
                        MaxLess6 = -1;

                    if (AStarGreedyi == 1)
                    {
                        OutputHuristic(Order);

                        //Set Table and Huristic Value and Syntax.

                        Object On = new Object();
                        lock (On)
                        {
                            SaveBeginEndLocation(i, j, k, 2);

                            SaveTableHuristic(i, j, k, 2, ref TableHuristic);

                            SaveLess(i, j, k, 2, ref Less, AA, Order);
                        }
                        Act = true;

                        StringHuristics(2, 3, AA, Do, ElephantOnTable[i].WinOcuuredatChiled, ElephantOnTable[i].LoseOcuuredatChiled);


                    }
                }
            }
            else if (Kind == 3)
            {
                if (HoursesOnTable[i].HourseThinking[0].ReturnHuristic(i, j, Order, AA, ref HaveKilled) > Less)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        //ActionString = ThinkingChess.ActionsString; AllDraw.ActionStringReady = true;
                    }
                    //retrive table of current huristic.
                    int[,] TableS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];

                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                    {

                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            if (Order== 1)
                            {
                                AllDraw.OutPut.Append("\r\nHuristic Hourse By Bob was not Valid Movment!");
                            }
                            else
                            {
                                AllDraw.OutPut.Append("\r\nHuristic Hourse By Alice was not Valid Movment!");

                                return true;
                            }
                        }

                    }
                    //When there is not Penalty regard mechanism.
                    if (CheckeHuristci(TableS, Order, i, j, k))
                        return true;

                    InitiateVars(i, j, k, 3);


                    MaxLess3 = (HoursesOnTable[RW3].HourseThinking[CL3].ReturnHuristic(RW3, Ki3, Order, false, ref HaveKilled));

                    if (ThinkingChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(HaveKilled))
                        return true;

                    if (MaxLess3 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess3 > MaxLess2)
                        MaxLess2 = -1;
                    if (MaxLess3 > MaxLess4)
                        MaxLess4 = -1;
                    if (MaxLess3 > MaxLess5)
                        MaxLess5 = -1;
                    if (MaxLess3 > MaxLess6)
                        MaxLess6 = -1;

                    if (AStarGreedyi == 1)
                    {
                        OutputHuristic(Order);

                        //Set Table and Huristic Value and Syntax.
                        Object On = new Object();
                        lock (On)
                        {
                            SaveBeginEndLocation(i, j, k, 3);

                            SaveTableHuristic(i, j, k, 3, ref TableHuristic);

                            SaveLess(i, j, k, 3, ref Less, AA, Order);
                        }

                        Act = true;

                        StringHuristics(3, 3, AA, Do, HoursesOnTable[i].WinOcuuredatChiled, HoursesOnTable[i].LoseOcuuredatChiled);
                    }

                }

            }
            else if (Kind == 4)
            {
                if (CastlesOnTable[i].CastleThinking[0].ReturnHuristic(i, j, Order, AA, ref HaveKilled) > Less)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        //ActionString = ThinkingChess.ActionsString; AllDraw.ActionStringReady = true;
                    }
                    //retrive table of current huristic.

                    //retrive table of current huristic.
                    int[,] TableS = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                    {
                        
                            if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                            {
                                if (Order== 1)
                                    AllDraw.OutPut.Append("\r\nHuristic Castle By Bob was not Valid Movment!");
                                else
                                    AllDraw.OutPut.Append("\r\nHuristic Castle By Alice was not Valid Movment!");

                                return true;
                            }
                       


                    }
                    //When there is not Penalty regard mechanism.
                    if (CheckeHuristci(TableS, Order, i, j, k))
                        return true;


                    InitiateVars(i, j, k, 4);

                    MaxLess4 = (CastlesOnTable[RW4].CastleThinking[CL4].ReturnHuristic(RW4, Ki4, Order, false, ref HaveKilled));

                    if (ThinkingChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(HaveKilled))
                        return true;

                    if (MaxLess4 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess4 > MaxLess2)
                        MaxLess2 = -1;
                    if (MaxLess4 > MaxLess3)
                        MaxLess3 = -1;
                    if (MaxLess4 > MaxLess5)
                        MaxLess5 = -1;
                    if (MaxLess4 > MaxLess6)
                        MaxLess6 = -1;


                    if (AStarGreedyi == 1)
                    {
                        OutputHuristic(Order);

                        //Set Table and Huristic Value and Syntax.

                        Object On = new Object();
                        lock (On)
                        {
                            SaveBeginEndLocation(i, j, k, 4);

                            SaveTableHuristic(i, j, k, 4, ref TableHuristic);

                            SaveLess(i, j, k, 4, ref Less, AA, Order);
                        }

                        Act = true;
                        StringHuristics(4, 3, AA, Do, CastlesOnTable[i].WinOcuuredatChiled, CastlesOnTable[i].LoseOcuuredatChiled);
                    }
                }
                else//Set Table and Huristic Value and Syntax.
                {
                }
            }
            else if (Kind == 5)
            {
                if (MinisterOnTable[i].MinisterThinking[0].ReturnHuristic(i, j, Order, AA, ref HaveKilled) > Less)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        //ActionString = ThinkingChess.ActionsString; AllDraw.ActionStringReady = true;
                    }
                    //retrive table of current huristic.

                    //retrive table of current huristic.
                    int[,] TableS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                    {
                        
                            if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                            {
                            if (Order== 1)
                            AllDraw.OutPut.Append("\r\nHuristic Minister By Bob was not Valid Movment!");
                            else { }
                                AllDraw.OutPut.Append("\r\nHuristic Minister By Alice was not Valid Movment!");

                                return true;
                            }
                       
                    }

                    //When there is not Penalty regard mechanism.
                    if (CheckeHuristci(TableS, Order, i, j, k))
                        return true;



                    InitiateVars(i, j, k, 5);


                    MaxLess5 = (MinisterOnTable[RW5].MinisterThinking[CL5].ReturnHuristic(RW5, Ki5, Order, false, ref HaveKilled));

                    if (ThinkingChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(HaveKilled))
                        return true;


                    if (MaxLess5 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess5 > MaxLess2)
                        MaxLess2 = -1;
                    if (MaxLess5 > MaxLess3)
                        MaxLess3 = -1;
                    if (MaxLess5 > MaxLess4)
                        MaxLess4 = -1;
                    if (MaxLess5 > MaxLess6)
                        MaxLess6 = -1;


                    if (AStarGreedyi == 1)
                    {
                        OutputHuristic(Order);

                        //Set Table and Huristic Value and Syntax.

                        Object On = new Object();
                        lock (On)
                        {
                            SaveBeginEndLocation(i, j, k, 5);

                            SaveTableHuristic(i, j, k, 5, ref TableHuristic);

                            SaveLess(i, j, k, 5, ref Less, AA, Order);
                        }

                        Act = true;

                        StringHuristics(5, 3, AA, Do, MinisterOnTable[i].WinOcuuredatChiled, MinisterOnTable[i].LoseOcuuredatChiled);
                    }
                }

            }
            else if (Kind == 6)
            {
                if (KingOnTable[i].KingThinking[0].ReturnHuristic(i, j, Order, AA, ref HaveKilled) > Less)
                {
                    Object OO = new Object();
                    lock (OO)
                    {
                        //ActionString = ThinkingChess.ActionsString; AllDraw.ActionStringReady = true;
                    }
                    //retrive table of current huristic.

                    //retrive table of current huristic.
                    int[,] TableS = KingOnTable[i].KingThinking[k].TableListKing[j];

                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                    {
                        
                            if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                            {
                                if (Order== 1)
                                    AllDraw.OutPut.Append("\r\nHuristic King By Bob was not Valid Movment!");
                                else
                                    AllDraw.OutPut.Append("\r\nHuristic King By Alice was not Valid Movment!");

                                return true;
                            }
                       
                    }
                    //When there is not Penalty regard mechanism.

                    if (CheckeHuristci(TableS, Order, i, j, k))
                        return true;

                    InitiateVars(i, j, k, 6);


                    MaxLess6 = (KingOnTable[RW6].KingThinking[CL6].ReturnHuristic(RW6, Ki6, Order, false, ref HaveKilled));

                    if (ThinkingChess.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(HaveKilled))
                        return true;

                    if (MaxLess6 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess6 > MaxLess2)
                        MaxLess2 = -1;
                    if (MaxLess6 > MaxLess3)
                        MaxLess3 = -1;
                    if (MaxLess6 > MaxLess4)
                        MaxLess4 = -1;
                    if (MaxLess6 > MaxLess5)
                        MaxLess5 = -1;


                    if (AStarGreedyi == 1)
                    {
                        OutputHuristic(Order);

                        //Set Table and Huristic Value and Syntax.

                        Object On = new Object();
                        lock (On)
                        {
                            SaveBeginEndLocation(i, j, k, 6);

                            SaveTableHuristic(i, j, k, 6, ref TableHuristic);

                            SaveLess(i, j, k, 6, ref Less, AA, Order);
                        }

                        Act = true;

                        StringHuristics(6, 3, AA, Do, KingOnTable[i].WinOcuuredatChiled, KingOnTable[i].LoseOcuuredatChiled);
                    }


                }
                else//Set Table and Huristic Value and Syntax.
                {
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicMainBody:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return continued;
        }
        bool KiilledForce(int HaveKiller)
        {
            if (ThinkingChess.IsAtLeastOneKillerAtDraw)
            {
                if (System.Math.Abs(HaveKilled) > 0)
                    return true;

            }

            return false;
        }
        bool KillerForce(int HaveKiller)
        {
            return ((ThinkingChess.IsAtLeastOneKillerAtDraw) || (!(HaveKiller > 0)));
        }
        int[,] HuristicAStarGreadySearchSoldier(ref int[,] TableHuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;


            Object a1 = new Object();
            lock (a1)
            {
                //ChessRules AB = null;

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;



                //For Every Soldier Movments AStarGreedy.
                for (int k = 0; k < AllDraw.SodierMovments; k++)
                //When There is an Movment in such situation.
                {
                    for (j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[k] != null && j < SolderesOnTable[i].SoldierThinking[k].TableListSolder.Count; j++)
                    {
                        //System.Threading.Thread.Sleep(2);
                        {
                            
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            if (SolderesOnTable[i].SoldierThinking[k].AStarGreedy.Count > j)
                                SolderesOnTable[i].SoldierThinking[k].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AA, Order * -1);
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;


                            StringHuristics(1, 1, AA, Do, SolderesOnTable[i].WinOcuuredatChiled, SolderesOnTable[i].LoseOcuuredatChiled);

                            if (SolderesOnTable[i].LoseOcuuredatChiled <= -1 || SolderesOnTable[i].LoseOcuuredatChiled <= -2 || SolderesOnTable[i].LoseOcuuredatChiled <= -3)
                                continue;

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)


                            if (HuristicRegardSection(i, j, k, ref Act, ref TableHuristic, ref AA, a, 1, ref Do, AStarGreedyi, Order))
                                continue;
                            //When There is No Movments in Such Order Enemy continue.
                            Object ol = new Object();
                            lock (ol)
                            {
                                if (Order != AllDraw.OrderPlate)
                                    if (SolderesOnTable[i].SoldierThinking[0].ReturnHuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                //When There is greater Huristic Movments.

                                if (HuristicMainBody(i, j, k, ref Act, ref TableHuristic, ref CurrentTableHuristic, ref AA, a, 1, ref Do, AStarGreedyi, Order))
                                    continue;

                            }

                        }
                    }

                }
                                  

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchSoldier:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }

        int[,] HuristicAStarGreadySearchSoldierGray(ref int[,] TableHuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            Object a1 = new Object();
            lock (a1)
            {

                if (SodierMidle != 0)
                {
                    for (var i = 0; i < SodierMidle; i++)
                        TableHuristic = HuristicAStarGreadySearchSoldier(ref TableHuristic, i, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                }
                else
                    CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchSoldierGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchSoldierBrown(ref int[,] TableHuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a1 = new Object();
            lock (a1)
            {
                if (SodierMidle != SodierHigh)
                {

                    for (var i = SodierMidle; i < SodierHigh; i++)
                        TableHuristic = HuristicAStarGreadySearchSoldier(ref TableHuristic, i, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                }
                else
                    CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchSoldierBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }

        int[,] HuristicAStarGreadySearchElephantGray(ref int[,] TableHuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            Object a1 = new Object();
            lock (a1)
            {
                if (0 != ElefantMidle)
                {
                    //Do For Remaining Objects same as Soldeir Documentation.
                    for (var i = 0; i < ElefantMidle; i++)
                        TableHuristic = HuristicAStarGreadySearchElephant(ref TableHuristic, i, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                }
                else
                    CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchElephantGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchElephantBrown(ref int[,] TableHuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a1 = new Object();
            lock (a1)
            {

                if (ElefantHigh != ElefantMidle)
                {
                    //Do For Remaining Objects same as Soldeir Documentation.
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        TableHuristic = HuristicAStarGreadySearchElephant(ref TableHuristic, i, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                }
                else
                    CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchElephantBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchElephant(ref int[,] TableHuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a1 = new Object();
            lock (a1)
            {

                //ChessRules AB = null;

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;

                for (int k = 0; k < AllDraw.ElefantMovments; k++)

                {
                    for (j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[k] != null && j < ElephantOnTable[i].ElefantThinking[k].TableListElefant.Count; j++)
                    {
                        //System.Threading.Thread.Sleep(2);
                        {

                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j)
                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(2, ref AA, Order * -1);
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;


                            StringHuristics(2, 1, AA, Do, ElephantOnTable[i].WinOcuuredatChiled, ElephantOnTable[i].LoseOcuuredatChiled);
                            if (ElephantOnTable[i].LoseOcuuredatChiled <= -1 || ElephantOnTable[i].LoseOcuuredatChiled <= -2 || ElephantOnTable[i].LoseOcuuredatChiled <= -3)
                                continue;
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)


                            if (HuristicRegardSection(i, j, k, ref Act, ref TableHuristic, ref AA, a, 2, ref Do, AStarGreedyi, Order))
                                continue;


                            Object ol = new Object();
                            lock (ol)
                            {

                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlate)
                                    if (ElephantOnTable[i].ElefantThinking[0].ReturnHuristic(i, j, Order, AA, ref HaveKilled) >Less)
                                        continue;
                                //When There is greater Huristic Movments.
                                if (HuristicMainBody(i, j, k, ref Act, ref TableHuristic, ref CurrentTableHuristic, ref AA, a, 2, ref Do, AStarGreedyi, Order))
                                    continue;



                            }


                        }

                    }
                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchElephant:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }


        }
        int[,] HuristicAStarGreadySearchHourseGray(ref int[,] TableHuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            Object a1 = new Object();
            lock (a1)
            {
                if (0 != HourseMidle)
                {
                    //For Every Soldeir
                    for (var i = 0; i < HourseMidle; i++)
                        TableHuristic = HuristicAStarGreadySearchHourse(ref TableHuristic, i, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                }
                else
                    CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchHourseGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchHourseBrown(ref int[,] TableHuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a1 = new Object();
            lock (a1)
            {

                if (HourseHight != HourseMidle)
                {
                    //For Every Soldeir
                    for (var i = HourseMidle; i < HourseHight; i++)
                        TableHuristic = HuristicAStarGreadySearchHourse(ref TableHuristic, i, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                }
                else
                    CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchHourseBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchHourse(ref int[,] TableHuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object a1 = new Object();
            lock (a1)
            {

                //ChessRules AB = null;

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;


                for (int k = 0; k < AllDraw.HourseMovments; k++)
                {
                    for (j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[k] != null && j < HoursesOnTable[i].HourseThinking[k].TableListHourse.Count; j++)
                    {
                        //System.Threading.Thread.Sleep(2);
                        {

                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j)
                                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(3, ref AA, Order * -1);
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;

                            StringHuristics(3, 1, AA, Do, HoursesOnTable[i].WinOcuuredatChiled, HoursesOnTable[i].LoseOcuuredatChiled);

                            if (HoursesOnTable[i].LoseOcuuredatChiled <= -1 || HoursesOnTable[i].LoseOcuuredatChiled <= -2 || HoursesOnTable[i].LoseOcuuredatChiled <= -3)
                                continue;


                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)

                            if (HuristicRegardSection(i, j, k, ref Act, ref TableHuristic, ref AA, a, 3, ref Do, AStarGreedyi, Order))
                                continue;

                            Object ol = new Object();
                            lock (ol)
                            {

                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlate)
                                    if (HoursesOnTable[i].HourseThinking[0].ReturnHuristic(i, j, Order, AA, ref HaveKilled) >Less)
                                        continue;
                                //When There is greater Huristic Movments.
                                if (HuristicMainBody(i, j, k, ref Act, ref TableHuristic, ref CurrentTableHuristic, ref AA, a, 3, ref Do, AStarGreedyi, Order))
                                    continue;


                            }

                        }
                    }
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchHourse:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchCastleGray(ref int[,] TableHuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                if (0 != HourseMidle)
                {
                    for (var i = 0; i < CastleMidle; i++)
                        TableHuristic = HuristicAStarGreadySearchCastle(ref TableHuristic, i, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                }
                else
                    CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchCastleGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchCastleBrown(ref int[,] TableHuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {


                if (CastleMidle != CastleHigh)
                {
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        TableHuristic = HuristicAStarGreadySearchCastle(ref TableHuristic, i, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);

                }
                else
                    CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchCastleBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchCastle(ref int[,] TableHuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O1 = new Object();
            lock (O1)
            {


                //ChessRules AB = null;

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;

                for (int k = 0; k < AllDraw.CastleMovments; k++)
                {
                    for (j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[k] != null && j < CastlesOnTable[i].CastleThinking[k].TableListCastle.Count; j++)
                    {
                        //System.Threading.Thread.Sleep(2);
                        {

                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            if (CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j)
                                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(4, ref AA, Order * -1);
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;

                            Order = COrder;
                            StringHuristics(4, 1, AA, Do, CastlesOnTable[i].WinOcuuredatChiled, CastlesOnTable[i].LoseOcuuredatChiled);

                            if (CastlesOnTable[i].LoseOcuuredatChiled <= -1 || CastlesOnTable[i].LoseOcuuredatChiled <= -2 || CastlesOnTable[i].LoseOcuuredatChiled <= -3)
                                continue;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)


                            if (HuristicRegardSection(i, j, k, ref Act, ref TableHuristic, ref AA, a, 4, ref Do, AStarGreedyi, Order))
                                continue;


                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlate)
                                    if (CastlesOnTable[i].CastleThinking[0].ReturnHuristic(i, j, Order, AA, ref HaveKilled) >Less)
                                        continue;
                                //When There is greater Huristic Movments.
                                if (HuristicMainBody(i, j, k, ref Act, ref TableHuristic, ref CurrentTableHuristic, ref AA, a, 4, ref Do, AStarGreedyi, Order))
                                    continue;

                            }

                        }
                    }


                }
               

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchCastle:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchMinsisterGray(ref int[,] TableHuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                if (0 != MinisterMidle)
                {
                    for (var i = 0; i < MinisterMidle; i++)
                        TableHuristic = HuristicAStarGreadySearchMinsister(ref TableHuristic, i, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);

                }
                else
                    CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchMinsisterGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }

        }
        int[,] HuristicAStarGreadySearchMinsisterBrown(ref int[,] TableHuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                if (MinisterHigh != MinisterMidle)
                {
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        TableHuristic = HuristicAStarGreadySearchMinsister(ref TableHuristic, i, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);

                }
                else
                    CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchMinsisterBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchMinsister(ref int[,] TableHuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O3 = new Object();
            lock (O3)
            {

                //ChessRules AB = null;

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;

                for (int k = 0; k < AllDraw.MinisterMovments; k++)
                {
                    for (j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[k] != null && j < MinisterOnTable[i].MinisterThinking[k].TableListMinister.Count; j++)
                    {
                        //System.Threading.Thread.Sleep(2);
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j)
                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(5, ref AA, Order * -1);
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;

                            StringHuristics(5, 1, AA, Do, MinisterOnTable[i].WinOcuuredatChiled, MinisterOnTable[i].LoseOcuuredatChiled);

                            if (MinisterOnTable[i].LoseOcuuredatChiled <= -1 || MinisterOnTable[i].LoseOcuuredatChiled <= -2 || MinisterOnTable[i].LoseOcuuredatChiled <= -3)
                                continue;
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)


                            if (HuristicRegardSection(i, j, k, ref Act, ref TableHuristic, ref AA, a, 5, ref Do, AStarGreedyi, Order))
                                continue;

                            Object ol = new Object();
                            lock (ol)
                            {
                                if (Order != AllDraw.OrderPlate)
                                    if (MinisterOnTable[i].MinisterThinking[0].ReturnHuristic(i, j, Order, AA, ref HaveKilled) >Less)
                                        continue;
                                if (HuristicMainBody(i, j, k, ref Act, ref TableHuristic, ref CurrentTableHuristic, ref AA, a, 5, ref Do, AStarGreedyi, Order))
                                    continue;

                            }
                        }
                    }


                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchMinsister:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchKingGray(ref int[,] TableHuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                if (0 != KingMidle)
                {
                    for (var i = 0; i < KingMidle; i++)
                        TableHuristic = HuristicAStarGreadySearchKing(ref TableHuristic, i, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                }
                else
                    CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchKingGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchKingBrown(ref int[,] TableHuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                if (KingHigh != KingMidle)
                {
                    for (var i = KingMidle; i < KingHigh; i++)
                        TableHuristic = HuristicAStarGreadySearchKing(ref TableHuristic, i, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                }
                else
                    CodeClass.SaveByCode(1, callStack.GetFileLineNumber(), callStack.GetFileName());
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchKingBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchKing(ref int[,] TableHuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                //ChessRules AB = null;

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;

                for (int k = 0; k < AllDraw.KingMovments; k++)
                {
                    for (j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[k] != null && KingOnTable[i].KingThinking != null && j < KingOnTable[i].KingThinking[k].TableListKing.Count; j++)
                    {
                        //System.Threading.Thread.Sleep(2);
                        {

                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;

                            if (KingOnTable[i].KingThinking[0].AStarGreedy.Count > j)
                                KingOnTable[i].KingThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(6, ref AA, Order * -1);
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;

                            StringHuristics(6, 1, AA, Do, KingOnTable[i].WinOcuuredatChiled, KingOnTable[i].LoseOcuuredatChiled);

                            if (KingOnTable[i].LoseOcuuredatChiled <= -1 || KingOnTable[i].LoseOcuuredatChiled <= -2 || KingOnTable[i].LoseOcuuredatChiled <= -3)
                                continue;
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)


                            if (HuristicRegardSection(i, j, k, ref Act, ref TableHuristic, ref AA, a, 6, ref Do, AStarGreedyi, Order))
                                continue;

                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlate)
                                    if (KingOnTable[i].KingThinking[0].ReturnHuristic(i, j, Order, AA, ref HaveKilled) >Less)
                                        continue;
                                //When There is greater Huristic Movments.
                                if (HuristicMainBody(i, j, k, ref Act, ref TableHuristic, ref CurrentTableHuristic, ref AA, a, 6, ref Do, AStarGreedyi, Order))
                                    continue;

                            }

                        }
                    }
                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchKing:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchGray(int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                int[,] TableHuristic = new int[8, 8];

                HuristicAStarGreadySearchSoldierGray(ref TableHuristic, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);

                HuristicAStarGreadySearchElephantGray(ref TableHuristic, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);


                HuristicAStarGreadySearchHourseGray(ref TableHuristic, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);


                HuristicAStarGreadySearchCastleGray(ref TableHuristic, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);

                HuristicAStarGreadySearchMinsisterGray(ref TableHuristic, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);

                HuristicAStarGreadySearchKingGray(ref TableHuristic, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] HuristicAStarGreadySearchBrown(int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[,] TableHuristic = new int[8, 8];

                HuristicAStarGreadySearchSoldierBrown(ref TableHuristic, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);

                HuristicAStarGreadySearchElephantBrown(ref TableHuristic, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);


                HuristicAStarGreadySearchHourseBrown(ref TableHuristic, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);


                HuristicAStarGreadySearchCastleBrown(ref TableHuristic, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);

                HuristicAStarGreadySearchMinsisterBrown(ref TableHuristic, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);

                HuristicAStarGreadySearchKingBrown(ref TableHuristic, AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreadySearchBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        int[,] BrownHuristicAStarGreaedySearchPenalites(int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                ChessRules AB = null;

                int ToCheckMate = -1, ForCheckMate = -1, j, i;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                int[,] TableHuristic = new int[8, 8];
                //For Every Soldeir
                for (i = SodierMidle; i < SodierHigh; i++)
                {

                    //For Every Soldier Movments AStarGreedy.
                    for (int k = 0; k < AllDraw.SodierMovments; k++)
                        //When There is an Movment in such situation.
                        
                            for (j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[k] != null && SolderesOnTable[i].SoldierThinking[k] != null && j < SolderesOnTable[i].SoldierThinking[k].TableListSolder.Count; j++)
                            {
                                
                                    //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                    ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                                    //  if (SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() == 0)
                                    //      continue;
                                    int CDummy = ChessRules.CurrentOrder;
                                    int COrder = Order;
                                    
                                        ChessRules.CurrentOrder *= -1;
                                        Order *= -1;
                                        Do = 0;
                                        if (UsePenaltyRegardMechnisamT)
                                        {
                                            for (int ij = 0; ij < SolderesOnTable[i].SoldierThinking[k].AStarGreedy.Count - 1; ij++)
                                                SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij]);
                                            Order = COrder;
                                            ChessRules.CurrentOrder = CDummy;
                                            ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                continue;
                                        }

                                   
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;

                                    //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                    //)
                                    if ((SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 && SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                                    {
                                        //Set Table and Huristic Value and Syntax.
                                        Act = true;
                                        Object o1l = new Object();
                                        lock (o1l)
                                        {

                                            AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                            AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                                            AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                            AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];

                                            Less = SolderesOnTable[i].SoldierThinking[k].NumberOfPenalties;
                                        }


                                        TableHuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];


                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            ThingsConverter.ActOfClickEqualTow = true;
                                        }
                                        SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                        int Sign = 1;
                                        if (a == Color.Brown)
                                            Sign = -1;
                                        //If there is Soldier Convert.
                                        if (SolderesOnTable[i].Convert)
                                        {

                                            if (SolderesOnTable[i].ConvertedToMinister)
                                                TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToCastle)
                                                TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToHourse)
                                                TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToElefant)
                                                TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;




                                            RegardOccurred = true;
                                            //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                            //return TableHuristic;
                                            continue;
                                        }

                                    }
                                    Object ol = new Object();
                                    lock (ol)
                                    {
                                        //When There is No Movments in Such Order Enemy continue.
                                        if (Order != AllDraw.OrderPlate)
                                            if (SolderesOnTable[i].SoldierThinking[0].NumberOfPenalties < Less)
                                                continue;
                                        //When There is greater Huristic Movments.
                                        if (SolderesOnTable[i].SoldierThinking[0].NumberOfPenalties < Less)
                                        {

                                            //retrive table of current huristic.

                                            //if (CheckG || CheckB)
                                            //{
                                            //retrive table of current huristic.
                                            int[,] TableS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];

                                            //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                            if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                            {
                                                
                                                    if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                        continue;
                                               
                                            }
                                            //When there is not Penalty regard mechanism.
                                            //if (!UsePenaltyRegardMechnisamT)
                                            {
                                                AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 1,CloneATable(TableS), Order, SolderesOnTable[i].SoldierThinking[k].Row, SolderesOnTable[i].SoldierThinking[k].Column);
                                                //If there is kish or kshachamaz Order.
                                                if (AB.Check(TableS, Order))
                                                {
                                                    //When Order is Gray.
                                                    if (Order== 1)
                                                    {
                                                        //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                        if (AB.CheckGray)
                                                            continue;
                                                    }
                                                    else
                                                    {
                                                        //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                        if (AB.CheckBrown)
                                                            continue;
                                                    }
                                                }
                                                // }
                                                else
                                                {

                                                }
                                            }
                                            RW1 = i;
                                            CL1 = k;
                                            Ki1 = j;
                                            RW2 = -1;
                                            CL2 = -1;
                                            Ki2 = -1;
                                            RW3 = -1;
                                            CL3 = -1;
                                            Ki3 = -1;
                                            RW4 = -1;
                                            CL4 = -1;
                                            Ki4 = -1;
                                            RW5 = -1;
                                            CL5 = -1;
                                            Ki5 = -1;
                                            RW6 = -1;
                                            CL6 = -1;
                                            Ki6 = -1;
                                            MaxLess1 = SolderesOnTable[RW1].SoldierThinking[CL1].NumberOfPenalties;
                                            if (MaxLess1 > MaxLess2)
                                                MaxLess2 = -1;
                                            if (MaxLess1 > MaxLess3)
                                                MaxLess3 = -1;
                                            if (MaxLess1 > MaxLess4)
                                                MaxLess4 = -1;
                                            if (MaxLess1 > MaxLess5)
                                                MaxLess5 = -1;
                                            if (MaxLess1 > MaxLess6)
                                                MaxLess6 = -1;

                                            //Set Table and Huristic Value and Syntax.
                                            if (AStarGreedyi == 1)
                                            {
                                                Object OO = new Object();
                                                lock (OO)
                                                {
                                                    if (Order== 1)
                                                    {
                                                        OutPut.Append("\r\nChess Huristic Sodier By Bob!");
                                                        //THIS.RefreshBoxText();
                                                    }
                                                    else//If Order is Brown.
                                                    {
                                                        OutPut.Append("\r\nChess Huristic Sodier By Alice!");
                                                        //THIS.RefreshBoxText();
                                                    }
                                                }
                                                //Set Table and Huristic Value and Syntax.
                                                Act = true;
                                                Object On = new Object();
                                                lock (On)
                                                {
                                                    AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                                    AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                                                    AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                                    AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
                                                }

                                                Less = SolderesOnTable[i].SoldierThinking[k].NumberOfPenalties;


                                                TableHuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];


                                                Object O1 = new Object();
                                                lock (O1)
                                                {
                                                    ThingsConverter.ActOfClickEqualTow = true;
                                                }
                                                SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                                int Sign = 1;
                                                if (a == Color.Brown)
                                                    Sign = -1;
                                                //If there is Soldier Convert.
                                                if (SolderesOnTable[i].Convert)
                                                {

                                                    if (SolderesOnTable[i].ConvertedToMinister)
                                                        TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                                    else if (SolderesOnTable[i].ConvertedToCastle)
                                                        TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                                    else if (SolderesOnTable[i].ConvertedToHourse)
                                                        TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                                    else if (SolderesOnTable[i].ConvertedToElefant)
                                                        TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;





                                                }

                                            }
                                            else
                                            {  //Set Table and Huristic Value and Syntax.
                                                
                                                    if (AStarGreedyi == 1)
                                                    {
                                                        //TakeRoot.Pointer = this;
                                                        //Found of Max Non Probable Movments.
                                                        Founded.Clear();
                                                        int LessB = Int32.MinValue;
                                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                        RW1 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                        CL1 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                        Ki1 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                        if (Founded[0] != MaxSoldeirFounded)
                                                            continue;
                                                        Act = true;
                                                        Object On = new Object();
                                                        lock (On)
                                                        {
                                                            AllDraw.LastRow = SolderesOnTable[RW1].SoldierThinking[CL1].Row;
                                                            AllDraw.LastColumn = SolderesOnTable[RW1].SoldierThinking[CL1].Column;
                                                            AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                                            AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
                                                        }
                                                        Less = SolderesOnTable[RW1].SoldierThinking[CL1].ReturnHuristic(RW1, Ki1, Order, false,ref HaveKilled);


                                                        TableHuristic = SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1];


                                                        Object O1 = new Object();
                                                        lock (O1)
                                                        {
                                                            ThingsConverter.ActOfClickEqualTow = true;
                                                        }
                                                        SolderesOnTable[RW1].ConvertOperation(SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], a, SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1], Order, false, i);
                                                        int Sign = 1;
                                                        if (a == Color.Brown)
                                                            Sign = -1;
                                                        //If there is Soldier Convert.
                                                        if (SolderesOnTable[RW1].Convert)
                                                        {

                                                            if (SolderesOnTable[RW1].ConvertedToMinister)
                                                                TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 5 * Sign;
                                                            else if (SolderesOnTable[RW1].ConvertedToCastle)
                                                                TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 4 * Sign;
                                                            else if (SolderesOnTable[RW1].ConvertedToHourse)
                                                                TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 3 * Sign;
                                                            else if (SolderesOnTable[RW1].ConvertedToElefant)
                                                                TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 2 * Sign;




                                                        }
                                                        Object OO = new Object();
                                                        lock (OO)
                                                        {
                                                            if (Order== 1)
                                                            {
                                                                OutPut.Append("\r\nChess Huristic Sodier By Bob!");
                                                                //THIS.RefreshBoxText();
                                                            }
                                                            else//If Order is Brown.
                                                            {
                                                                OutPut.Append("\r\nChess Huristic Sodier By Alice!");
                                                                //THIS.RefreshBoxText();
                                                            }
                                                        }
                                                    }
                                               

                                            }
                                        }
                                    }
                               
                            }
                       
                    /*
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                for (int p = 0; p < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; p++)
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[p].HuristicAStarGreedySearch(AStarGreedyi, A, a, ref Less, Order, false,ref HaveKilled);
                              */
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                   

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                //Do For Remaining Objects same as Soldeir Documentation.
                for (i = ElefantMidle; i < ElefantHigh; i++)
                {
                    for (int k = 0; k < AllDraw.ElefantMovments; k++)
                        
                            for (j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[k] != null && ElephantOnTable[i].ElefantThinking[k] != null && j < ElephantOnTable[i].ElefantThinking[k].TableListElefant.Count; j++)
                            {
                                
                                    //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                    ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                                    //   if (ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                                    //       continue;
                                    int CDummy = ChessRules.CurrentOrder;
                                    int COrder = Order;
                                    
                                        ChessRules.CurrentOrder *= -1;
                                        Order *= -1;
                                        Do = 0;
                                        if (UsePenaltyRegardMechnisamT)
                                        {
                                            for (int ij = 0; ij < ElephantOnTable[i].ElefantThinking[k].AStarGreedy.Count - 1; ij++)
                                                ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij]);
                                            Order = COrder;
                                            ChessRules.CurrentOrder = CDummy;
                                            ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                continue;
                                        }

                                   
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                    //)
                                    if ((ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 && ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                                    {
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                            AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                                            AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                            AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];


                                            Act = true;
                                            Less = ElephantOnTable[i].ElefantThinking[k].NumberOfPenalties;
                                        }
                                        TableHuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                        RegardOccurred = true;
                                        //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                        //return TableHuristic;
                                        continue;
                                    }
                                    //When There is No Movments in Such Order Enemy continue.
                                    if (ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                                        continue;
                                    Object ol = new Object();
                                    lock (ol)
                                    {
                                        //When There is No Movments in Such Order Enemy continue.
                                        if (Order != AllDraw.OrderPlate)
                                            if (ElephantOnTable[i].ElefantThinking[0].NumberOfPenalties < Less)
                                                continue;
                                        //When There is greater Huristic Movments.
                                        if (ElephantOnTable[i].ElefantThinking[0].NumberOfPenalties < Less)
                                        {

                                            //retrive table of current huristic.

                                            //if (CheckG || CheckB)
                                            //{
                                            //retrive table of current huristic.
                                            int[,] TableS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                            //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                            if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                            {
                                                
                                                    if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                        continue;
                                               
                                            }
                                            //When there is not Penalty regard mechanism.
                                            //if (!UsePenaltyRegardMechnisamT)
                                            {
                                                AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 2,CloneATable(TableS), Order, ElephantOnTable[i].ElefantThinking[k].Row, ElephantOnTable[i].ElefantThinking[k].Column);
                                                //If there is kish or kshachamaz Order.
                                                if (AB.Check(TableS, Order))
                                                {
                                                    //When Order is Gray.
                                                    if (Order== 1)
                                                    {
                                                        //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                        if (AB.CheckGray)
                                                            continue;
                                                    }
                                                    else
                                                    {
                                                        //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                        if (AB.CheckBrown)
                                                            continue;
                                                    }
                                                }
                                                else
                                                {

                                                }


                                            }
                                            RW2 = i;
                                            CL2 = k;
                                            Ki2 = j;
                                            RW1 = -1;
                                            CL1 = -1;
                                            Ki1 = -1;
                                            RW3 = -1;
                                            CL3 = -1;
                                            Ki3 = -1;
                                            RW4 = -1;
                                            CL4 = -1;
                                            Ki4 = -1;
                                            RW5 = -1;
                                            CL5 = -1;
                                            Ki5 = -1;
                                            RW6 = -1;
                                            CL6 = -1;
                                            Ki6 = -1;
                                            MaxLess2 = (ElephantOnTable[RW2].ElefantThinking[CL2].NumberOfPenalties);
                                            MaxLess1 = -1;
                                            if (MaxLess2 > MaxLess3)
                                                MaxLess3 = -1;
                                            if (MaxLess2 > MaxLess4)
                                                MaxLess4 = -1;
                                            if (MaxLess2 > MaxLess5)
                                                MaxLess5 = -1;
                                            if (MaxLess2 > MaxLess6)
                                                MaxLess6 = -1;
                                            if (AStarGreedyi == 1)
                                            {
                                                Object OO = new Object();
                                                lock (OO)
                                                {
                                                    if (Order== 1)
                                                    {
                                                        OutPut.Append("\r\nChess Huristic Elephant By Bob!");
                                                        //THIS.RefreshBoxText();
                                                    }
                                                    else//If Order is Brown.
                                                    {
                                                        OutPut.Append("\r\nChess Huristic Elephant By Alice!");
                                                        //THIS.RefreshBoxText();
                                                    }
                                                }
                                                Object On = new Object();
                                                lock (On)
                                                {
                                                    AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                                    AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                                                    AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                                    AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
                                                }

                                                Act = true;
                                                Less = ElephantOnTable[i].ElefantThinking[k].NumberOfPenalties;
                                                TableHuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];

                                            }
                                        }
                                        else//Set Table and Huristic Value and Syntax.
                                        {
                                            
                                                if (AStarGreedyi == 1)
                                                {
                                                    //TakeRoot.Pointer = this;
                                                    //Found of Max Non Probable Movments.
                                                    Founded.Clear();
                                                    int LessB = Int32.MinValue;
                                                    BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                    RW2 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                    CL2 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                    Ki2 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                    if (Founded[0] != MaxElephntFounded)
                                                        continue;

                                                    Object On = new Object();
                                                    lock (On)
                                                    {
                                                        AllDraw.LastRow = ElephantOnTable[RW2].ElefantThinking[CL2].Row;
                                                        AllDraw.LastColumn = ElephantOnTable[RW2].ElefantThinking[CL2].Column;
                                                        AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                                        AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
                                                    }

                                                    Act = true;
                                                    Less = ElephantOnTable[RW2].ElefantThinking[CL2].ReturnHuristic(RW2, Ki2, Order, false,ref HaveKilled);
                                                    TableHuristic = ElephantOnTable[RW2].ElefantThinking[CL2].TableListElefant[Ki2];
                                                    Object OO = new Object();
                                                    lock (OO)
                                                    {
                                                        if (Order== 1)
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Sodier By Bob!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                        else//If Order is Brown.
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Sodier By Alice!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                    }
                                                }
                                           

                                        }
                                    }
                               
                            }
                       
                    
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                   

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }

                for (i = HourseMidle; i < HourseHight; i++)
                {
                    for (int k = 0; k < AllDraw.HourseMovments; k++)
                        
                            for (j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[k] != null && HoursesOnTable[i].HourseThinking[k] != null && j < HoursesOnTable[i].HourseThinking[k].TableListHourse.Count; j++)
                            {
                                
                                    //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                    ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                                    //    if (HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() == 0)
                                    //        continue;
                                    int CDummy = ChessRules.CurrentOrder;
                                    int COrder = Order;
                                    
                                        ChessRules.CurrentOrder *= -1;
                                        Order *= -1;
                                        Do = 0;
                                        if (UsePenaltyRegardMechnisamT)
                                        {
                                            for (int ij = 0; ij < HoursesOnTable[i].HourseThinking[k].AStarGreedy.Count - 1; ij++)
                                                HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij]);
                                            Order = COrder;
                                            ChessRules.CurrentOrder = CDummy;
                                            ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                continue;
                                        }

                                   
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                    //)
                                    if ((HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 && HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                                    {
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                            AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                                            AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                            AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];


                                            Act = true;
                                            Less = HoursesOnTable[i].HourseThinking[k].NumberOfPenalties;
                                        }
                                        TableHuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                        RegardOccurred = true;
                                        //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                        //return TableHuristic;
                                        continue;
                                    }

                                    Object ol = new Object();
                                    lock (ol)
                                    {
                                        //When There is No Movments in Such Order Enemy continue.
                                        if (Order != AllDraw.OrderPlate)
                                            if (HoursesOnTable[i].HourseThinking[0].NumberOfPenalties < Less)

                                                continue;
                                        //When There is greater Huristic Movments.
                                        if (HoursesOnTable[i].HourseThinking[0].NumberOfPenalties < Less)
                                        {

                                            //retrive table of current huristic.

                                            //retrive table of current huristic.
                                            int[,] TableS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                            {
                                                //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                                if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                                {
                                                    
                                                        if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                            continue;
                                                   

                                                }
                                                //When there is not Penalty regard mechanism.
                                                //if (!UsePenaltyRegardMechnisamT)
                                                {
                                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 3,CloneATable(TableS), Order, HoursesOnTable[i].HourseThinking[k].Row, HoursesOnTable[i].HourseThinking[k].Column);
                                                    //If there is kish or kshachamaz Order.
                                                    if (AB.Check(TableS, Order))
                                                    {
                                                        //When Order is Gray.
                                                        if (Order== 1)
                                                        {
                                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                            if (AB.CheckGray)
                                                                continue;
                                                        }
                                                        else
                                                        {
                                                            //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                            if (AB.CheckBrown)
                                                                continue;
                                                        }
                                                    }
                                                    else
                                                    {

                                                    }
                                                }


                                            }
                                            RW1 = -1;
                                            CL1 = -1;
                                            Ki1 = -1;
                                            RW2 = -1;
                                            CL2 = -1;
                                            Ki2 = -1;
                                            RW3 = i;
                                            CL3 = k;
                                            Ki3 = j;
                                            RW4 = -1;
                                            CL4 = -1;
                                            Ki4 = -1;
                                            RW5 = -1;
                                            CL5 = -1;
                                            Ki5 = -1;
                                            RW6 = -1;
                                            CL6 = -1;
                                            Ki6 = -1;
                                            MaxLess3 = HoursesOnTable[RW3].HourseThinking[CL3].NumberOfPenalties;
                                            if (MaxLess3 > MaxLess1)
                                                MaxLess1 = -1;
                                            if (MaxLess3 > MaxLess2)
                                                MaxLess2 = -1;
                                            if (MaxLess3 > MaxLess4)
                                                MaxLess4 = -1;
                                            if (MaxLess3 > MaxLess5)
                                                MaxLess5 = -1;
                                            if (MaxLess3 > MaxLess6)
                                                MaxLess6 = -1;

                                            if (AStarGreedyi == 1)
                                            {
                                                Object OO = new Object();
                                                lock (OO)
                                                {
                                                    if (Order== 1)
                                                    {
                                                        OutPut.Append("\r\nChess Huristic Hourse By Bob!");
                                                        //THIS.RefreshBoxText();
                                                    }
                                                    else//If Order is Brown.
                                                    {
                                                        OutPut.Append("\r\nChess Huristic Hourse By Alice!");
                                                        //THIS.RefreshBoxText();
                                                    }
                                                }
                                                //Set Table and Huristic Value and Syntax.

                                                Object On = new Object();
                                                lock (On)
                                                {
                                                    AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                                    AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                                                    AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                                    AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
                                                }

                                                Act = true;
                                                Less = HoursesOnTable[i].HourseThinking[k].NumberOfPenalties;
                                                TableHuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];

                                            }
                                        }
                                        else//Set Table and Huristic Value and Syntax.
                                        {
                                            
                                                if (AStarGreedyi == 1)
                                                {
                                                    //TakeRoot.Pointer = this;
                                                    //Found of Max Non Probable Movments.
                                                    Founded.Clear();
                                                    int LessB = Int32.MinValue;
                                                    BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                    RW3 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                    CL3 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                    Ki3 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                    if (Founded[0] != MaxHourseFounded)
                                                        continue;

                                                    Object On = new Object();
                                                    lock (On)
                                                    {
                                                        AllDraw.LastRow = HoursesOnTable[RW3].HourseThinking[CL3].Row;
                                                        AllDraw.LastColumn = HoursesOnTable[RW3].HourseThinking[CL3].Column;
                                                        AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                                        AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
                                                    }

                                                    Act = true;
                                                    Less = HoursesOnTable[RW3].HourseThinking[CL3].ReturnHuristic(RW3, Ki3, Order, false,ref HaveKilled);
                                                    TableHuristic = HoursesOnTable[RW3].HourseThinking[CL3].TableListHourse[Ki3];
                                                    Object OO = new Object();
                                                    lock (OO)
                                                    {
                                                        if (Order== 1)
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Sodier By Bob!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                        else//If Order is Brown.
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Sodier By Alice!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                    }
                                                }
                                           


                                        }
                                    }
                               
                            }
                       
                    
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                   

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }

                for (i = CastleMidle; i < CastleHigh; i++)
                {
                    for (int k = 0; k < AllDraw.CastleMovments; k++)
                        
                            for (j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[k] != null && CastlesOnTable[i].CastleThinking[k] != null && j < CastlesOnTable[i].CastleThinking[k].TableListCastle.Count; j++)
                            {
                                
                                    //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                    ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                                    ///   if (CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() == 0)
                                    //       continue;

                                    int CDummy = ChessRules.CurrentOrder;
                                    int COrder = Order;
                                    
                                        ChessRules.CurrentOrder *= -1;
                                        Order *= -1;
                                        Do = 0;
                                        if (UsePenaltyRegardMechnisamT)
                                        {
                                            for (int ij = 0; ij < CastlesOnTable[i].CastleThinking[k].AStarGreedy.Count - 1; ij++)
                                                CastlesOnTable[i].CastleThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, CastlesOnTable[i].CastleThinking[k].AStarGreedy[ij]);
                                            Order = COrder;
                                            ChessRules.CurrentOrder = CDummy;
                                            ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                continue;
                                        }

                                   
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                    //)
                                    if ((CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 && CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                                    {

                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                                            AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                                            AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                            AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                            Act = true;
                                            Less = CastlesOnTable[i].CastleThinking[k].NumberOfPenalties;
                                        }
                                        TableHuristic = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                        RegardOccurred = true;
                                        //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                        //return TableHuristic;
                                        continue;
                                    }
                                    Object ol = new Object();
                                    lock (ol)
                                    {
                                        if (Order != AllDraw.OrderPlate)
                                            if (CastlesOnTable[i].CastleThinking[0].NumberOfPenalties < Less)
                                                continue;
                                        //When There is greater Huristic Movments.
                                        if (CastlesOnTable[i].CastleThinking[0].NumberOfPenalties < Less)
                                        {

                                            //retrive table of current huristic.
                                            //retrive table of current huristic.
                                            int[,] TableS = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                            //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                            if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                            {
                                                
                                                    if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                        continue;
                                               

                                            }
                                            //When there is not Penalty regard mechanism.
                                            //if (!UsePenaltyRegardMechnisamT)
                                            {
                                                AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 4,CloneATable(TableS), Order, CastlesOnTable[i].CastleThinking[k].Row, CastlesOnTable[i].CastleThinking[k].Column);
                                                //If there is kish or kshachamaz Order.
                                                if (AB.Check(TableS, Order))
                                                {
                                                    //When Order is Gray.
                                                    if (Order== 1)
                                                    {
                                                        //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                        if (AB.CheckGray)
                                                            continue;
                                                    }
                                                    else
                                                    {
                                                        //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                        if (AB.CheckBrown)
                                                            continue;
                                                    }
                                                }
                                                else
                                                {

                                                }

                                            }
                                            RW4 = i;
                                            CL4 = k;
                                            Ki4 = j;
                                            RW1 = -1;
                                            CL1 = -1;
                                            Ki1 = -1;
                                            RW2 = -1;
                                            CL2 = -1;
                                            Ki2 = -1;
                                            RW3 = -1;
                                            CL3 = -1;
                                            Ki3 = -1;
                                            RW5 = -1;
                                            CL5 = -1;
                                            Ki5 = -1;
                                            RW6 = -1;
                                            CL6 = -1;
                                            Ki6 = -1;
                                            MaxLess4 = (CastlesOnTable[RW4].CastleThinking[CL4].NumberOfPenalties);
                                            if (MaxLess4 > MaxLess1)
                                                MaxLess1 = -1;
                                            if (MaxLess4 > MaxLess2)
                                                MaxLess2 = -1;
                                            if (MaxLess4 > MaxLess3)
                                                MaxLess3 = -1;
                                            if (MaxLess4 > MaxLess5)
                                                MaxLess5 = -1;
                                            if (MaxLess4 > MaxLess6)
                                                MaxLess6 = -1;

                                            if (AStarGreedyi == 1)
                                            {
                                                Object OO = new Object();
                                                lock (OO)
                                                {
                                                    if (Order== 1)
                                                    {
                                                        OutPut.Append("\r\nChess Huristic Castles By Bob!");
                                                        //THIS.RefreshBoxText();
                                                    }
                                                    else//If Order is Brown.
                                                    {
                                                        OutPut.Append("\r\nChess Huristic Castles By Alice!");
                                                        //THIS.RefreshBoxText();
                                                    }
                                                }
                                                //Set Table and Huristic Value and Syntax.

                                                Object On = new Object();
                                                lock (On)
                                                {
                                                    AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                                                    AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                                                    AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                                    AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                                }

                                                Act = true;
                                                Less = CastlesOnTable[i].CastleThinking[k].NumberOfPenalties;
                                                TableHuristic = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];

                                            }
                                        }
                                        else//Set Table and Huristic Value and Syntax.
                                        {
                                            
                                                if (AStarGreedyi == 1)
                                                {
                                                    //TakeRoot.Pointer = this;
                                                    //Found of Max Non Probable Movments.
                                                    Founded.Clear();
                                                    int LessB = Int32.MinValue;
                                                    BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                    RW4 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                    CL4 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                    Ki4 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                    if (Founded[0] != MaxCastlesFounded)
                                                        continue;

                                                    Object On = new Object();
                                                    lock (On)
                                                    {
                                                        AllDraw.LastRow = CastlesOnTable[RW4].CastleThinking[CL4].Row;
                                                        AllDraw.LastColumn = CastlesOnTable[RW4].CastleThinking[CL4].Column;
                                                        AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                                        AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                                    }

                                                    Act = true;
                                                    Less = CastlesOnTable[RW4].CastleThinking[CL4].ReturnHuristic(RW4, Ki4, Order, false,ref HaveKilled);
                                                    TableHuristic = CastlesOnTable[RW4].CastleThinking[CL4].TableListCastle[Ki4];
                                                    Object OO = new Object();
                                                    lock (OO)
                                                    {
                                                        if (Order== 1)
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Sodier By Bob!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                        else//If Order is Brown.
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Sodier By Alice!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                    }
                                                }
                                           

                                        }
                                    }
                               
                            }
                       
                    
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                   
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }


                for (i = MinisterMidle; i < MinisterHigh; i++)
                {
                    for (int k = 0; k < AllDraw.MinisterMovments; k++)
                        
                            for (j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[k] != null && MinisterOnTable[i].MinisterThinking[k] != null && j < MinisterOnTable[i].MinisterThinking[k].TableListMinister.Count; j++)
                            {
                                
                                    //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                    ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                                    ////    if (MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() == 0)
                                    //     continue;
                                    int CDummy = ChessRules.CurrentOrder;
                                    int COrder = Order;
                                    
                                        ChessRules.CurrentOrder *= -1;
                                        Order *= -1;
                                        Do = 0;
                                        if (UsePenaltyRegardMechnisamT)
                                        {
                                            for (int ij = 0; ij < MinisterOnTable[i].MinisterThinking[k].AStarGreedy.Count - 1; ij++)
                                                MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij]);
                                            Order = COrder;
                                            ChessRules.CurrentOrder = CDummy;
                                            ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                continue;
                                        }

                                   
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                    //)
                                    if ((MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 && MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                                    {

                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                            AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                                            AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                            AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];


                                            Act = true;
                                            Less = MinisterOnTable[i].MinisterThinking[k].NumberOfPenalties;
                                        }
                                        TableHuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                        RegardOccurred = true;
                                        //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                        //return TableHuristic;
                                        continue;
                                    }
                                    Object ol = new Object();
                                    lock (ol)
                                    {
                                        //When There is No Movments in Such Order Enemy continue.
                                        if (Order != AllDraw.OrderPlate)
                                            if (MinisterOnTable[i].MinisterThinking[0].NumberOfPenalties < Less)
                                                continue;


                                        //When There is greater Huristic Movments.
                                        if (MinisterOnTable[i].MinisterThinking[0].NumberOfPenalties < Less)

                                        //retrive table of current huristic.
                                        {

                                            //retrive table of current huristic.
                                            int[,] TableS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                            //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                            if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                            {
                                                
                                                    if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                        continue;
                                               
                                            }
                                            {
                                                //When there is not Penalty regard mechanism.
                                                //if (!UsePenaltyRegardMechnisamT)
                                                {
                                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 5,CloneATable(TableS), Order, MinisterOnTable[i].MinisterThinking[k].Row, MinisterOnTable[i].MinisterThinking[k].Column);
                                                    //If there is kish or kshachamaz Order.
                                                    if (AB.Check(TableS, Order))
                                                    {
                                                        //When Order is Gray.
                                                        if (Order== 1)
                                                        {
                                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                            if (AB.CheckGray)
                                                                continue;
                                                        }
                                                        else
                                                        {
                                                            //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                            if (AB.CheckBrown)
                                                                continue;
                                                        }
                                                    }
                                                    else
                                                    {

                                                    }
                                                }

                                            }
                                            RW5 = i;
                                            CL5 = k;
                                            Ki5 = j;
                                            RW1 = -1;
                                            CL1 = -1;
                                            Ki1 = -1;
                                            RW2 = -1;
                                            CL2 = -1;
                                            Ki2 = -1;
                                            RW3 = -1;
                                            CL3 = -1;
                                            Ki3 = -1;
                                            RW4 = -1;
                                            CL4 = -1;
                                            Ki4 = -1;
                                            RW6 = -1;
                                            CL6 = -1;
                                            Ki6 = -1;
                                            MaxLess5 = (MinisterOnTable[RW5].MinisterThinking[CL5].NumberOfPenalties);
                                            if (MaxLess5 > MaxLess1)
                                                MaxLess1 = -1;
                                            if (MaxLess5 > MaxLess2)
                                                MaxLess2 = -1;
                                            if (MaxLess5 > MaxLess3)
                                                MaxLess3 = -1;
                                            if (MaxLess5 > MaxLess4)
                                                MaxLess4 = -1;
                                            if (MaxLess5 > MaxLess6)
                                                MaxLess6 = -1;
                                            if (AStarGreedyi == 1)
                                            {
                                                Object OO = new Object();
                                                lock (OO)
                                                {
                                                    if (Order== 1)
                                                    {
                                                        OutPut.Append("\r\nChess Huristic Minister By Bob!");
                                                        //THIS.RefreshBoxText();
                                                    }
                                                    else//If Order is Brown.
                                                    {
                                                        OutPut.Append("\r\nChess Huristic Minister By Alice!");
                                                        //THIS.RefreshBoxText();
                                                    }
                                                }
                                                Object On = new Object();
                                                lock (On)
                                                {
                                                    AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                                    AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                                                    AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                                    AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
                                                }

                                                Act = true;
                                                Less = MinisterOnTable[i].MinisterThinking[k].NumberOfPenalties;
                                                TableHuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];

                                            }
                                        }
                                        else//Set Table and Huristic Value and Syntax.
                                        {
                                            
                                                if (AStarGreedyi == 1)
                                                {
                                                    //TakeRoot.Pointer = this;
                                                    //Found of Max Non Probable Movments.
                                                    Founded.Clear();
                                                    int LessB = Int32.MinValue;
                                                    BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                    RW5 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                    CL5 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                    Ki5 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                    if (Founded[0] != MaxMinisterFounded)
                                                        continue;

                                                    Object On = new Object();
                                                    lock (On)
                                                    {
                                                        AllDraw.LastRow = MinisterOnTable[RW5].MinisterThinking[CL5].Row;
                                                        AllDraw.LastColumn = MinisterOnTable[RW5].MinisterThinking[CL5].Column;
                                                        AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                                        AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
                                                    }
                                                    Act = true;
                                                    Less = MinisterOnTable[RW5].MinisterThinking[CL5].ReturnHuristic(RW5, Ki5, Order, false,ref HaveKilled);
                                                    TableHuristic = MinisterOnTable[RW5].MinisterThinking[CL5].TableListMinister[Ki5];
                                                    Object OO = new Object();
                                                    lock (OO)
                                                    {
                                                        if (Order== 1)
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Sodier By Bob!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                        else//If Order is Brown.
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Sodier By Alice!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                    }
                                                }
                                           
                                        }
                                    }
                               
                            }
                       
                    
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                   

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                for (i = KingMidle; i < KingHigh; i++)
                {
                    for (int k = 0; k < AllDraw.KingMovments; k++)
                        
                            for (j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[k] != null && KingOnTable[i].KingThinking[k] != null && j < KingOnTable[i].KingThinking[k].TableListKing.Count; j++)
                            {
                                
                                    //////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                                    //    if (KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() == 0)
                                    //        continue;
                                    int CDummy = ChessRules.CurrentOrder;
                                    int COrder = Order;
                                    
                                        ChessRules.CurrentOrder *= -1;
                                        Order *= -1;
                                        Do = 0;
                                        if (UsePenaltyRegardMechnisamT)
                                        {
                                            for (int ij = 0; ij < KingOnTable[i].KingThinking[k].AStarGreedy.Count - 1; ij++)
                                                KingOnTable[i].KingThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, KingOnTable[i].KingThinking[k].AStarGreedy[ij]);
                                            Order = COrder;
                                            ChessRules.CurrentOrder = CDummy;
                                            ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                continue;
                                        }

                                   
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                    //)
                                    if ((KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() != 0 && KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                                    {

                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                                            AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                                            AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                            AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];


                                            Act = true;
                                            Less = KingOnTable[i].KingThinking[k].NumberOfPenalties;
                                        }
                                        TableHuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
                                        RegardOccurred = true;
                                        //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                                        //return TableHuristic;
                                        continue;
                                    }
                                    Object ol = new Object();
                                    lock (ol)
                                    {

                                        //When There is No Movments in Such Order Enemy continue.
                                        if (Order != AllDraw.OrderPlate)
                                            if (KingOnTable[i].KingThinking[0].NumberOfPenalties < Less)
                                                continue;


                                        //When There is greater Huristic Movments.
                                        if (KingOnTable[i].KingThinking[0].NumberOfPenalties < Less)
                                        //retrive table of current huristic.
                                        {


                                            //retrive table of current huristic.
                                            int[,] TableS = KingOnTable[i].KingThinking[k].TableListKing[j];
                                            //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                            if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                            {
                                                
                                                    if (!IsEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                        continue;
                                               

                                            }
                                            //When there is not Penalty regard mechanism.
                                            //if (!UsePenaltyRegardMechnisamT)
                                            {
                                                AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 6,CloneATable(TableS), Order, KingOnTable[i].KingThinking[k].Row, KingOnTable[i].KingThinking[k].Column);
                                                //If there is kish or kshachamaz Order.
                                                if (AB.Check(TableS, Order))
                                                {
                                                    //When Order is Gray.
                                                    if (Order== 1)
                                                    {
                                                        //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                        if (AB.CheckGray)
                                                            continue;
                                                    }
                                                    else
                                                    {
                                                        //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                        if (AB.CheckBrown)
                                                            continue;
                                                    }
                                                }
                                                else
                                                {

                                                }


                                            }
                                            RW6 = i;
                                            CL6 = k;
                                            Ki6 = j;
                                            RW1 = -1;
                                            CL1 = -1;
                                            Ki1 = -1;
                                            RW2 = -1;
                                            CL2 = -1;
                                            Ki2 = -1;
                                            RW3 = -1;
                                            CL3 = -1;
                                            Ki3 = -1;
                                            RW4 = -1;
                                            CL4 = -1;
                                            Ki4 = -1;
                                            RW5 = -1;
                                            CL5 = -1;
                                            Ki5 = -1;
                                            MaxLess6 = (KingOnTable[RW6].KingThinking[CL6].NumberOfPenalties);
                                            if (MaxLess6 > MaxLess1)
                                                MaxLess1 = -1;
                                            if (MaxLess6 > MaxLess2)
                                                MaxLess2 = -1;
                                            if (MaxLess6 > MaxLess3)
                                                MaxLess3 = -1;
                                            if (MaxLess6 > MaxLess4)
                                                MaxLess4 = -1;
                                            if (MaxLess6 > MaxLess5)
                                                MaxLess5 = -1;
                                            if (AStarGreedyi == 1)
                                            {
                                                Object OO = new Object();
                                                lock (OO)
                                                {
                                                    if (Order== 1)
                                                    {
                                                        OutPut.Append("\r\nChess Huristic King By Bob!");
                                                        //THIS.RefreshBoxText();
                                                    }
                                                    else//If Order is Brown.
                                                    {
                                                        OutPut.Append("\r\nChess Huristic King By Alice!");
                                                        //THIS.RefreshBoxText();
                                                    }
                                                }
                                                Object On = new Object();
                                                lock (On)
                                                {
                                                    AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                                                    AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                                                    AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                                    AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
                                                }

                                                Act = true;
                                                Less = KingOnTable[i].KingThinking[k].NumberOfPenalties;
                                                TableHuristic = KingOnTable[i].KingThinking[k].TableListKing[j];

                                            }
                                        }
                                        else//Set Table and Huristic Value and Syntax.
                                        {
                                            
                                                if (AStarGreedyi == 1)
                                                {
                                                    //TakeRoot.Pointer = this;
                                                    //Found of Max Non Probable Movments.
                                                    Founded.Clear();
                                                    int LessB = Int32.MinValue;
                                                    BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                    if (Founded[0] != 1)
                                                        continue;
                                                    RW6 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                    CL6 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                    Ki6 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                    if (Founded[0] != MaxKingFounded)
                                                        continue;

                                                    Object On = new Object();
                                                    lock (On)
                                                    {
                                                        AllDraw.LastRow = KingOnTable[RW6].KingThinking[CL6].Row;
                                                        AllDraw.LastColumn = KingOnTable[RW6].KingThinking[CL6].Column;
                                                        AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                                        AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
                                                    }

                                                    Act = true;
                                                    Less = KingOnTable[RW6].KingThinking[CL6].ReturnHuristic(RW6, Ki6, Order, false,ref HaveKilled);
                                                    TableHuristic = KingOnTable[RW6].KingThinking[CL6].TableListKing[Ki6];
                                                    Object OO = new Object();
                                                    lock (OO)
                                                    {
                                                        if (Order== 1)
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Sodier By Bob!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                        else//If Order is Brown.
                                                        {
                                                            OutPut.Append("\r\nChess Huristic Sodier By Alice!");
                                                            //THIS.RefreshBoxText();
                                                        }
                                                    }
                                                }
                                           

                                        }

                                        //else
                                        {
                                        }
                                    }
                               
                            }
                       
                    
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                   

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BrownHuristicAStarGreaedySearchPenalites:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        //AStarGreedy First Huristic Method.
        public int[,] HuristicAStarGreedySearch(int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[,] TableHuristic = new int[8, 8];

                AStarGreedyi++;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                //Initiate For Dynamic Backward Current AStarGreedyi Non Minus Founded Max Movments Detection Global Variables.
                List<int> Founded = new List<int>();
                //Initiateing Indicating Huristic Multiple Same Value Best Found of Movments.
                MaxLess1 = -1;
                MaxLess2 = -1;
                MaxLess3 = -1;
                MaxLess4 = -1;
                MaxLess5 = -1;
                MaxLess6 = -1;
                RW1 = -1;
                CL1 = -1;
                Ki1 = -1;
                RW2 = -1;
                CL2 = -1;
                Ki2 = -1;
                RW3 = -1;
                CL3 = -1;
                Ki3 = -1;
                RW4 = -1;
                CL4 = -1;
                Ki4 = -1;
                RW5 = -1;
                CL5 = -1;
                Ki5 = -1;
                RW6 = -1;
                CL6 = -1;
                Ki6 = -1;

                int[] BacWard = new int[25];
                Object Omm = new Object();
                lock (Omm)
                {

                    if (AStarGreedyi > MaxAStarGreedy)
                        return TableHuristic;
                }
                bool Act = false;

                if (Order== 1)
                {
                    TableHuristic = HuristicAStarGreadySearchGray(AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                }
                else
                {
                    TableHuristic = HuristicAStarGreadySearchBrown(AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //Store In Local Variable and Dynamic Purpose Proccessing.
                //Every Non Minuse Non Idept in List Has Gretest Max Order.
                //Is Desired of Idept Oner Best Movments.
                BacWard[0] = AStarGreedyi;

                BacWard[1] = MaxLess1;
                BacWard[2] = RW1;
                BacWard[3] = RW1;
                BacWard[4] = Ki1;


                BacWard[5] = MaxLess2;
                BacWard[6] = RW2;
                BacWard[7] = RW2;
                BacWard[8] = Ki2;

                BacWard[9] = MaxLess3;
                BacWard[10] = RW3;
                BacWard[11] = RW3;
                BacWard[12] = Ki3;

                BacWard[13] = MaxLess4;
                BacWard[14] = RW4;
                BacWard[15] = RW4;
                BacWard[16] = Ki4;

                BacWard[17] = MaxLess5;
                BacWard[18] = RW5;
                BacWard[19] = RW5;
                BacWard[20] = Ki5;

                BacWard[21] = MaxLess6;
                BacWard[22] = RW6;
                BacWard[23] = RW6;
                BacWard[24] = Ki6;

                //We Have Information of Maximum of Huristic in Each Level and Table.
                MaxHuristicAStarGreedytBackWard.Add(BacWard);
                MaxHuristicAStarGreedytBackWardTable.Add(TableHuristic);

                Founded.Clear();
                //If Found retrun table.
                if (Act)
                    return TableHuristic;
                //Return what found table.
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreedySearch:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return TableHuristic;
            }
        }
        public int[,] HuristicAStarGreedySearchPenalties(int AStarGreedyi, Color a, int Order, bool CurrentTableHuristic)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[,] TableHuristic = new int[8, 8];

                AStarGreedyi++;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                //Initiate For Dynamic Backward Current AStarGreedyi Non Minus Founded Max Movments Detection Global Variables.
                List<int> Founded = new List<int>();
                //Initiateing Indicating Huristic Multiple Same Value Best Found of Movments.
                MaxLess1 = -1;
                MaxLess2 = -1;
                MaxLess3 = -1;
                MaxLess4 = -1;
                MaxLess5 = -1;
                MaxLess6 = -1;
                RW1 = -1;
                CL1 = -1;
                Ki1 = -1;
                RW2 = -1;
                CL2 = -1;
                Ki2 = -1;
                RW3 = -1;
                CL3 = -1;
                Ki3 = -1;
                RW4 = -1;
                CL4 = -1;
                Ki4 = -1;
                RW5 = -1;
                CL5 = -1;
                Ki5 = -1;
                RW6 = -1;
                CL6 = -1;
                Ki6 = -1;

                int[] BacWard = new int[25];
                Object Omm = new Object();
                lock (Omm)
                {
                    if (AStarGreedyi > MaxAStarGreedy)
                        return TableHuristic;
                }
                bool Act = false;
                if (Order== 1)
                {
                    TableHuristic = HuristicAStarGreadySearchPenalties(AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                }
                else
                {
                    TableHuristic = BrownHuristicAStarGreaedySearchPenalites(AStarGreedyi, a, Order, CurrentTableHuristic, ref Act);
                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //Store In Local Variable and Dynamic Purpose Proccessing.
                //Every Non Minuse Non Idept in List Has Gretest Max Order.
                //Is Desired of Idept Oner Best Movments.
                BacWard[0] = AStarGreedyi;

                BacWard[1] = MaxLess1;
                BacWard[2] = RW1;
                BacWard[3] = RW1;
                BacWard[4] = Ki1;


                BacWard[5] = MaxLess2;
                BacWard[6] = RW2;
                BacWard[7] = RW2;
                BacWard[8] = Ki2;

                BacWard[9] = MaxLess3;
                BacWard[10] = RW3;
                BacWard[11] = RW3;
                BacWard[12] = Ki3;

                BacWard[13] = MaxLess4;
                BacWard[14] = RW4;
                BacWard[15] = RW4;
                BacWard[16] = Ki4;

                BacWard[17] = MaxLess5;
                BacWard[18] = RW5;
                BacWard[19] = RW5;
                BacWard[20] = Ki5;

                BacWard[21] = MaxLess6;
                BacWard[22] = RW6;
                BacWard[23] = RW6;
                BacWard[24] = Ki6;

                //We Have Information of Maximum of Huristic in Each Level and Table.
                MaxHuristicAStarGreedytBackWard.Add(BacWard);
                MaxHuristicAStarGreedytBackWardTable.Add(TableHuristic);

                Founded.Clear();
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("HuristicAStarGreedySearchPenalties:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                //If Found retrun table.
                if (Act)
                    return TableHuristic;
                //Return what found table.
                return TableHuristic;
            }
        }
        //Genethic Algorithm Game Method.
        public void InitiateGenetic(int ii, int jj, Color a, int[,] Table, int Order, bool TB)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //Initiate Local and Global Variables.
                int Current = ChessRules.CurrentOrder;
                int DummyOrder = Order;

                TableList.Add(Table);


                Object OO = new Object();
                lock (OO)
                {
                    ThinkingChess.NotSolvedKingDanger = false;
                }
                LoopHuristicIndex = 0;
                //For One time.
                for (var i = 0; i < 1; i++)
                {
                    //If Order is Gray.
                    Object O2 = new Object();
                    lock (O2)
                    {
                        if (Order== 1)
                        {
                            OutPut.Append("\r\nChess Genetic By Bob!");
                            //THIS.RefreshBoxText();
                        }
                        else//If Order is Brown.
                        {
                            OutPut.Append("\r\nChess Genetic By Alice!");
                            //THIS.RefreshBoxText();

                        }
                    }
                    //Initiate Local Variables.
                    int[,] TablInit = new int[8, 8];
                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    int In = 0;
                    //Found Of Random Movments.
                    do
                    {
                        if (Order== 1)
                            In = (new System.Random()).Next(0, 8);
                        else
                            In = (new System.Random()).Next(8, 16);
                    } while (SolderesOnTable[In] == null);


                    //If Order is Gray.
                    Object OOO = new Object();
                    lock (OOO)
                    {
                        if (Order== 1)
                        {
                            OutPut.Append("\r\nGenetic Algorithm Begin AStarGreedy " + i.ToString() + " By Bob!");
                            //THIS.RefreshBoxText();
                        }
                        else//If Order is Brown.
                        {
                            OutPut.Append("\r\nGenetic Algirithm Begin AStarGreedy " + i.ToString() + " By Alice!");
                            //THIS.RefreshBoxText();

                        }
                    }
                    //Found Of Genetic Algorithm Movments By GeneticAlgorithm Call Objectsand Method.
                    ChessGeneticAlgorithm R = (new ChessGeneticAlgorithm(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                    //Found Table.
                    int[,] Tab = R.GenerateTable(TableListAction, 0, Order);
                    //If Order is Gray.
                    Object OOO1 = new Object();
                    lock (OOO1)
                    {
                        if (Order== 1)
                        {
                            OutPut.Append("\r\nGenetic Algorithm Finsished AStarGreedy " + i.ToString() + " By Bob!");
                            //THIS.RefreshBoxText();
                        }
                        else//If Order is Brown.
                        {
                            OutPut.Append("\r\nGenetic Algirithm Finished AStarGreedy " + i.ToString() + " By Alice!");
                            //THIS.RefreshBoxText();

                        }
                    }

                    //If Table Found.
                    if (Tab != null)
                    {
                        //Construct a Clone Copy of Table.
                        for (var iii = 0; iii < 8; iii++)
                            for (var jjj = 0; jjj < 8; jjj++)
                            {
                                TablInit[iii, jjj] = Tab[iii, jjj];
                            }
                        //Initiate a Table.
                        Table = new int[8, 8];
                        //Construct a Clone Copy of Table.
                        for (var iii = 0; iii < 8; iii++)
                            for (var jjj = 0; jjj < 8; jjj++)
                            {
                                Table[iii, jjj] = TablInit[iii, jjj];
                            }
                        //Initiate Local and Global Varibales.
                        TableList.Add(TablInit);
                        ClList.Add(CL);
                        RWList.Add(RW);
                        KiList.Add(Ki);
                        // Order = Order * -1;
                        // ChessRules.CurrentOrder = Order;
                        AStarGreedy++;
                        //return;

                    }
                }
            //Determination of CheckMate Consideration.
            (new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 1, CloneATable(Table), Order, -1, -1)).CheckMate(CloneATable(Table), Order);

                //Reconstruction of Order Global Varibales.
                Order = DummyOrder;
                ChessRules.CurrentOrder = Current;

                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateGenetic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            }
        }
        //AStarGreedy First Initiat Thinking Main Method.
        public AllDraw InitiateAStarGreedytOneNode(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, int iIndex, int KindIndex, int LeafAStarGreedy
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            {
                SetObjectNumbers(Tab);
                //List<Task> tHA = new List<Task>();
                int[,] Table = new int[8, 8];
                for (var iii = 0; iii < 8; iii++)
                    for (var jjj = 0; jjj < 8; jjj++)
                        Table[iii, jjj] = Tab[iii, jjj];
                //ParallelOptions parallelOptions = new ParallelOptions();
                //parallelOptions.MaxDegreeOfParallelism = PlatformHelper.ProcessorCount;
                Object O = new Object();
                lock (O)
                {
                    ThinkingChess.BeginThread = 0;
                    ThinkingChess.EndThread = 0;
                }
                //Initiate of global Variables Byte Local Variables.
                int DummyOrder = new int();
                DummyOrder = Order;
                int DummyCurrentOrder = new int();
                DummyCurrentOrder = ChessRules.CurrentOrder;
                List<Task> tH = new List<Task>();
                int[,] TablInit = new int[8, 8];
                if (Order== 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                var j = 0;
                Object Omm = new Object();
                lock (Omm)
                {
                    if (iAStarGreedy >= MaxAStarGreedy)
                        return null;
                }

                iAStarGreedy++;

                {
                    //Initiate Of Local Variables.
                    {


                        {
                            //If Order is Gray.
                            if (Order== 1)
                            {
                                //For Gray Soldeirs Objects. 
                                //                    for (i = 0; i < SodierMidle; i++)
                                if (KindIndex == 1)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //If Solders Not Exist Continue and Traversal Back.
                                        //If There is no Thinking Movments on Current Object  


                                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                                        { ASS = AllDraw.Blitz; }
                                        if (!ASS)
                                        {
                                            //Thinking of Gray Solder Operation.
                                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                                            SolderesOnTable[iIndex].SoldierThinking[0].Thinking(ref SolderesOnTable[iIndex].LoseOcuuredatChiled, ref SolderesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(SolderesOnTable[iIndex].SoldierThinking[0].Thinking));
                                            SolderesOnTable[iIndex].SoldierThinking[0].t.Start();
                                            if (SolderesOnTable[iIndex].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(SolderesOnTable[iIndex].SoldierThinking[0].t); } }*/
                                        }
                                        else if (ASS)
                                        //If There is A Soldeir Movments.                                   
                                        {

                                            //Thinking of Gray Soldeir Operations.
                                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                                            SolderesOnTable[iIndex].SoldierThinking[0].Thinking(ref SolderesOnTable[iIndex].LoseOcuuredatChiled, ref SolderesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(SolderesOnTable[iIndex].SoldierThinking[0].Thinking));
                                            SolderesOnTable[iIndex].SoldierThinking[0].t.Start();
                                            if (SolderesOnTable[iIndex].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                    { tH.Add(SolderesOnTable[iIndex].SoldierThinking[0].t); } }*/
                                        }
                                   
                                }
                                //Progressing.
                                //For All Gray Elephant Objects.

                                if (KindIndex == 2)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //Ignore of Non Exist Current Elephant Gray Objects.
                                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                                        { ASS = AllDraw.Blitz; }
                                        if (!ASS)
                                        {
                                            //Operational Thinking Gray Elephant. 
                                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                                            ElephantOnTable[iIndex].ElefantThinking[0].Thinking(ref ElephantOnTable[iIndex].LoseOcuuredatChiled, ref ElephantOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(ElephantOnTable[iIndex].ElefantThinking[0].Thinking));
                                            ElephantOnTable[iIndex].ElefantThinking[0].t.Start();
                                            if (ElephantOnTable[iIndex].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(ElephantOnTable[iIndex].ElefantThinking[0].t); } }*/
                                        }//If There is Movment Thinking Gary Elphant Object List.
                                        else if (ASS)
                                        {
                                            //For Every Gray Elephant Thinking Movments.
                                            //Gray Elephant Object Thinking Operations.
                                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                                            ElephantOnTable[iIndex].ElefantThinking[0].Thinking(ref ElephantOnTable[iIndex].LoseOcuuredatChiled, ref ElephantOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(ElephantOnTable[iIndex].ElefantThinking[0].Thinking));
                                            ElephantOnTable[iIndex].ElefantThinking[0].t.Start();
                                            if (ElephantOnTable[iIndex].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                    { tH.Add(ElephantOnTable[iIndex].ElefantThinking[0].t); } }*/
                                        }
                                   
                                }
                                //Progressing.

                                //For All Gray Hourse Objects.
                                if (KindIndex == 3)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;

                                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                                        { ASS = AllDraw.Blitz; }
                                        if (!ASS)
                                        {
                                            //Thinking of Gray Hourse Oprational.
                                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                                            HoursesOnTable[iIndex].HourseThinking[0].Thinking(ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(HoursesOnTable[iIndex].HourseThinking[0].Thinking));
                                            HoursesOnTable[iIndex].HourseThinking[0].t.Start();
                                            if (HoursesOnTable[iIndex].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt)
                                                { tH.Add(HoursesOnTable[iIndex].HourseThinking[0].t); } }*/
                                        }
                                        else if (ASS)//If Table List Exist int The Thinking.
                                        {

                                            //Thinking Operation of Gray Hourse.
                                            HoursesOnTable[iIndex].HourseThinking[0].TableT = HoursesOnTable[iIndex].HourseThinking[0].TableListHourse[j];
                                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                                            HoursesOnTable[iIndex].HourseThinking[0].Thinking(ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(HoursesOnTable[iIndex].HourseThinking[0].Thinking));
                                            HoursesOnTable[iIndex].HourseThinking[0].t.Start();
                                            if (HoursesOnTable[iIndex].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                    { tH.Add(HoursesOnTable[iIndex].HourseThinking[0].t); } }*/
                                        }
                                   
                                }
                                //Progressing.


                                if (KindIndex == 4)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                                        { ASS = AllDraw.Blitz; }
                                        if (!ASS)
                                        {
                                            //When There is Possible Thinking Castle of Gray Table
                                            //Thinking of Gray Castles Operational.
                                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingBegin = true;
                                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingFinished = false;
                                            CastlesOnTable[iIndex].CastleThinking[0].Thinking(ref CastlesOnTable[iIndex].LoseOcuuredatChiled, ref CastlesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(CastlesOnTable[iIndex].CastleThinking[0].Thinking));
                                            CastlesOnTable[iIndex].CastleThinking[0].t.Start();
                                            if (CastlesOnTable[iIndex].CastleThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(CastlesOnTable[iIndex].CastleThinking[0].t); } }*/

                                        }
                                        else if (ASS)
                                        {
                                            //When There is Possible Thinking Castle of Gray Table
                                            //Thinking of Gray Castles  Objective Movments.
                                            CastlesOnTable[iIndex].CastleThinking[0].TableT = CastlesOnTable[iIndex].CastleThinking[0].TableListCastle[j];
                                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingBegin = true;
                                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingFinished = false;
                                            CastlesOnTable[iIndex].CastleThinking[0].Thinking(ref CastlesOnTable[iIndex].LoseOcuuredatChiled, ref CastlesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(CastlesOnTable[iIndex].CastleThinking[0].Thinking));
                                            CastlesOnTable[iIndex].CastleThinking[0].t.Start();
                                            if (CastlesOnTable[iIndex].CastleThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                    { tH.Add(CastlesOnTable[iIndex].CastleThinking[0].t); } }*/
                                        }
                                   
                                }
                                if (KindIndex == 5)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                                        { ASS = AllDraw.Blitz; }
                                        if (!ASS)
                                        {//When There is Table Gray Minister Count of Thinking.
                                         //Thinking of Gray Minister Operational.
                                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                                            MinisterOnTable[iIndex].MinisterThinking[0].Thinking(ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(MinisterOnTable[iIndex].MinisterThinking[0].Thinking));
                                            MinisterOnTable[iIndex].MinisterThinking[0].t.Start();
                                            if (MinisterOnTable[iIndex].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(MinisterOnTable[iIndex].MinisterThinking[0].t); } }*/
                                        }
                                        else if (ASS)//When There is Table Gray Minister Count of Thinking.
                                        {
                                            //Thinking.
                                            MinisterOnTable[iIndex].Table = MinisterOnTable[iIndex].MinisterThinking[0].TableListMinister[j];
                                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                                            MinisterOnTable[iIndex].MinisterThinking[0].Thinking(ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(MinisterOnTable[iIndex].MinisterThinking[0].Thinking));
                                            MinisterOnTable[iIndex].MinisterThinking[0].t.Start();
                                            if (MinisterOnTable[iIndex].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                    { tH.Add(MinisterOnTable[iIndex].MinisterThinking[0].t); } }*/
                                        }
                                   
                                }

                                if (KindIndex == 6)
                                {

                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                                        { ASS = AllDraw.Blitz; }
                                        if (!ASS)
                                        {//When Thinking Gray King Count of Existing Operations.
                                         //Thinking Of Gray King Operatins.
                                            KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                                            KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                                            KingOnTable[iIndex].KingThinking[0].Thinking(ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(KingOnTable[iIndex].KingThinking[0].Thinking));
                                            KingOnTable[iIndex].KingThinking[0].t.Start();
                                            if (KingOnTable[iIndex].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(KingOnTable[iIndex].KingThinking[0].t); } }*/
                                        }
                                        else if (ASS)//When Thinking Gray King Count of Existing Operations.
                                        {
                                            //Gray King Thinking Operations.                                        
                                            KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                                            KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                                            KingOnTable[iIndex].KingThinking[0].Thinking(ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(KingOnTable[iIndex].KingThinking[0].Thinking));
                                            KingOnTable[iIndex].KingThinking[0].t.Start();
                                            if (KingOnTable[iIndex].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(KingOnTable[iIndex].KingThinking[0].t); } }*/
                                        }
                                   
                                }
                            }
                            else//Brown Order Considarations.
                            {

                                if (KindIndex == -1)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                                        { ASS = AllDraw.Blitz; }
                                        if (!ASS)//When There is Current Brown Existing Objective Thinking Movments.
                                        {
                                            //Wheen Brown King Object There is Not Continue Traversal Back.
                                            //Thinking Operations of Brown Current Objects.
                                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                                            SolderesOnTable[iIndex].SoldierThinking[0].Thinking(ref SolderesOnTable[iIndex].LoseOcuuredatChiled, ref SolderesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(SolderesOnTable[iIndex].SoldierThinking[0].Thinking));
                                            SolderesOnTable[iIndex].SoldierThinking[0].t.Start();
                                            if (SolderesOnTable[iIndex].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(SolderesOnTable[iIndex].SoldierThinking[0].t); } }*/

                                        }

                                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                                        {
                                            //Thinking of Thinking Brown CurrentTable Objective Operations.
                                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                                            SolderesOnTable[iIndex].SoldierThinking[0].Thinking(ref SolderesOnTable[iIndex].LoseOcuuredatChiled, ref SolderesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(SolderesOnTable[iIndex].SoldierThinking[0].Thinking));
                                            SolderesOnTable[iIndex].SoldierThinking[0].t.Start();
                                            if (SolderesOnTable[iIndex].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(SolderesOnTable[iIndex].SoldierThinking[0].t); } }*/

                                        }
                                   
                                }
                                if (KindIndex == -2)
                                {
                                    
                                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                                        { ASS = AllDraw.Blitz; }
                                        if (!ASS)
                                        {//When There is Current Brown Existing Objective Thinking Movments.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //Thinking Operations of Brown Current Objects.
                                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                                            ElephantOnTable[iIndex].ElefantThinking[0].Thinking(ref ElephantOnTable[iIndex].LoseOcuuredatChiled, ref ElephantOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(ElephantOnTable[iIndex].ElefantThinking[0].Thinking));
                                            ElephantOnTable[iIndex].ElefantThinking[0].t.Start();
                                            if (ElephantOnTable[iIndex].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(ElephantOnTable[iIndex].ElefantThinking[0].t); } }*/
                                        }
                                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                                        {
                                            //Inititae Local Varibale By Global Gray Elephant Objects Varibales.
                                            //Thinking of Thinking Brown CurrentTable Objective Operations.                                                   
                                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                                            ElephantOnTable[iIndex].ElefantThinking[0].Thinking(ref ElephantOnTable[iIndex].LoseOcuuredatChiled, ref ElephantOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(ElephantOnTable[iIndex].ElefantThinking[0].Thinking));
                                            ElephantOnTable[iIndex].ElefantThinking[0].t.Start();
                                            if (ElephantOnTable[iIndex].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(ElephantOnTable[iIndex].ElefantThinking[0].t); } }*/
                                        }
                                   
                                }


                                if (KindIndex == -3)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                                        { ASS = AllDraw.Blitz; }
                                        if (!ASS)
                                        {//When There is Current Brown Existing Objective Thinking Movments.
                                         //Thinking Operations of Brown Current Objects.
                                         //HoursesOnTable[iIndex].HourseThinking[0].TableT = HoursesOnTable[iIndex].HourseThinking[0].TableT;
                                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                                            HoursesOnTable[iIndex].HourseThinking[0].Thinking(ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(HoursesOnTable[iIndex].HourseThinking[0].Thinking));
                                            HoursesOnTable[iIndex].HourseThinking[0].t.Start();
                                            if (HoursesOnTable[iIndex].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(HoursesOnTable[iIndex].HourseThinking[0].t); } }*/

                                        }
                                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                                        {
                                            //Thinking of Thinking Brown CurrentTable Objective Operations.                                          SolderesOnTable[iIndex].SoldierThinking[0].Table = SolderesOnTable[iIndex].SoldierThinking[0].TableListSolder[j];
                                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                                            HoursesOnTable[iIndex].HourseThinking[0].Thinking(ref HoursesOnTable[iIndex].LoseOcuuredatChiled, ref HoursesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(HoursesOnTable[iIndex].HourseThinking[0].Thinking));
                                            HoursesOnTable[iIndex].HourseThinking[0].t.Start();
                                            if (HoursesOnTable[iIndex].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt)
                                                    { tH.Add(HoursesOnTable[iIndex].HourseThinking[0].t); } }*/


                                        }
                                   
                                }
                                //Progressing.




                                if (KindIndex == -4)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                                        { ASS = AllDraw.Blitz; }
                                        if (!ASS)
                                        {//When There is Current Brown Existing Objective Thinking Movments.
                                         //Thinking Operations of Brown Current Objects.
                                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingBegin = true;
                                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingFinished = false;
                                            CastlesOnTable[iIndex].CastleThinking[0].Thinking(ref CastlesOnTable[iIndex].LoseOcuuredatChiled, ref CastlesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(CastlesOnTable[iIndex].CastleThinking[0].Thinking));
                                            CastlesOnTable[iIndex].CastleThinking[0].t.Start();
                                            if (CastlesOnTable[iIndex].CastleThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(CastlesOnTable[iIndex].CastleThinking[0].t); } }*/
                                        }
                                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                                        {
                                            //Thinking of Thinking Brown CurrentTable Objective Operations.        
                                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingBegin = true;
                                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingFinished = false;
                                            CastlesOnTable[iIndex].CastleThinking[0].Thinking(ref CastlesOnTable[iIndex].LoseOcuuredatChiled, ref CastlesOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(CastlesOnTable[iIndex].CastleThinking[0].Thinking));
                                            CastlesOnTable[iIndex].CastleThinking[0].t.Start();
                                            if (CastlesOnTable[iIndex].CastleThinking[0].t != null) { Object tttt = new Object(); lock (tttt)
                                                    { tH.Add(CastlesOnTable[iIndex].CastleThinking[0].t); } }*/
                                        }
                                   
                                }

                                if (KindIndex == -5)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                                        { ASS = AllDraw.Blitz; }
                                        if (!ASS)
                                        {//When There is Current Brown Existing Objective Thinking Movments.
                                         //Thinking Operations of Brown Current Objects.
                                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                                            MinisterOnTable[iIndex].MinisterThinking[0].Thinking(ref MinisterOnTable[iIndex].LoseOcuuredatChiled, ref MinisterOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(MinisterOnTable[iIndex].MinisterThinking[0].Thinking));
                                            MinisterOnTable[iIndex].MinisterThinking[0].t.Start();
                                            if (MinisterOnTable[iIndex].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt)
                                                { tH.Add(MinisterOnTable[iIndex].MinisterThinking[0].t); } }*/
                                        }
                                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                                        {
                                            //Thinking of Thinking Brown CurrentTable Objective Operations.                                          SolderesOnTable[iIndex].SoldierThinking[0].Table = SolderesOnTable[iIndex].SoldierThinking[0].TableListSolder[j];
                                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                                            MinisterOnTable[iIndex].MinisterThinking[0].Thinking(ref MinisterOnTable[iIndex].LoseOcuuredatChiled, ref MinisterOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(MinisterOnTable[iIndex].MinisterThinking[0].Thinking));
                                            MinisterOnTable[iIndex].MinisterThinking[0].t.Start();
                                            if (MinisterOnTable[iIndex].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                    { tH.Add(MinisterOnTable[iIndex].MinisterThinking[0].t); } }*/

                                        }
                                   
                                }
                                //Progressing.

                                if (KindIndex == -6)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                                        { ASS = AllDraw.Blitz; }
                                        if (!ASS)
                                        {//When There is Current Brown Existing Objective Thinking Movments.
                                         //Thinking Operations of Brown Current Objects.
                                            KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                                            KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                                            KingOnTable[iIndex].KingThinking[0].Thinking(ref KingOnTable[iIndex].LoseOcuuredatChiled, ref KingOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(KingOnTable[iIndex].KingThinking[0].Thinking));
                                            KingOnTable[iIndex].KingThinking[0].t.Start();
                                            if (KingOnTable[iIndex].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(KingOnTable[iIndex].KingThinking[0].t); } }*/

                                        }
                                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                                        {
                                            //Thinking of Thinking Brown CurrentTable Objective Operations.       
                                            KingOnTable[iIndex].KingThinking[0].TableT = KingOnTable[iIndex].KingThinking[0].TableListKing[j];
                                            KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                                            KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                                            KingOnTable[iIndex].KingThinking[0].Thinking(ref KingOnTable[iIndex].LoseOcuuredatChiled, ref KingOnTable[iIndex].WinOcuuredatChiled);/*.t = new Task(new Action(KingOnTable[iIndex].KingThinking[0].Thinking));
                                            KingOnTable[iIndex].KingThinking[0].t.Start();
                                            if (KingOnTable[iIndex].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) 
                                                { tH.Add(KingOnTable[iIndex].KingThinking[0].t); } }*/


                                        }

                                   
                                }
                                
                                    //IncreaseprogressBarRefregitzValue(THIS.progressBarVerify, increasedProgress);
                                    //THIS.progressBarVerify.Invalidate();
                                    //SetprogressBarUpdate(THIS.progressBarVerify);
                               
                            }
                        }
                        //Thread arrayT = new Thread(() => do_check(tH));
                        //rayT.Start();

                        //ile (WaitSome) { Thread.Sleep(1000); }
                        {
                            
                                /*foreach (Task ij in tH)
                                {
                                    ij.Start();
                                    //Thread.Sleep(10);
                                }
                                 */


                                Parallel.ForEach(tH, items => Task.WaitAll(items));
                           
                        }
                    }
                    //while ((ThinkingChess.BeginThread) != (ThinkingChess.EndThread))
                    //{
                }
                bool FOUND = false;
                if (KindIndex == 1 || KindIndex == -1)
                {
                    SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                    SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND, LeafAStarGreedy);
                }
                else
                    if (KindIndex == 2 || KindIndex == -2)
                {
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND, LeafAStarGreedy);
                }
                else
                        if (KindIndex == 3 || KindIndex == -3)
                {
                    HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                    HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND, LeafAStarGreedy);
                }
                else
                            if (KindIndex == 4 || KindIndex == -4)
                {
                    CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                    CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy[CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy[CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy[CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy[CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND, LeafAStarGreedy);
                }
                else
                                if (KindIndex == 5 || KindIndex == -5)
                {
                    MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                    MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND, LeafAStarGreedy);
                }
                else
                                    if (KindIndex == 6 || KindIndex == -6)
                {
                    KingOnTable[iIndex].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND, LeafAStarGreedy);
                }
                //                } 
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedytOneNode:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                return this;//.CopyRemeiningItems(Dummy, Order,false);
                            //return 
                            //>;
            }
        }
        int MaxGrayMidle()
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                int[] Tab = new int[6];
                Tab[0] = SodierMidle;
                Tab[1] = ElefantMidle;
                Tab[2] = HourseMidle;
                Tab[3] = CastleMidle;
                Tab[4] = MinisterMidle;
                Tab[5] = KingMidle;
                int Max = 0;
                for (var i = 0; i < 6; i++)
                {
                    if (Tab[i] > Max)
                        Max = Tab[i];
                }
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("MaxGrayMidle:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Max;
            }
        }
        int MaxBrownHigh()
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            Object O = new Object();
            lock (O)
            {
                int[] Tab = new int[6];
                Tab[0] = SodierHigh;
                Tab[1] = ElefantHigh;
                Tab[2] = HourseHight;
                Tab[3] = CastleHigh;
                Tab[4] = MinisterHigh;
                Tab[5] = KingHigh;
                int Max = 0;
                for (var i = 0; i < 6; i++)
                {
                    if (Tab[i] > Max)
                        Max = Tab[i];
                }
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("MaxBrownHigh:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Max;
            }
        }
        int MinBrownMidle()
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {

                int[] Tab = new int[6];
                Tab[0] = SodierHigh;
                Tab[1] = ElefantHigh;
                Tab[2] = HourseHight;
                Tab[3] = CastleHigh;
                Tab[4] = MinisterHigh;
                Tab[5] = KingHigh;
                int Min = MaxBrownHigh();
                for (var i = 0; i < 6; i++)
                {
                    if (Tab[i] < Min)
                        Min = Tab[i];
                }
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("MinBrownMidle:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Min;
            }
        }
        AllDraw InitiateAStarGreedytObjectGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy //, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                for (var i = 0; i < MaxGrayMidle(); i++)
                {
                    //Parallel.Invoke(() =>
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {
                            if (SodierMidle > i)
                            {
                                Object O = new Object();
                                lock (O)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //If Solders Not Exist Continue and Traversal Back.
                                        if (SolderesOnTable != null && SolderesOnTable[i] != null)
                                        {
                                            //Initiate of Local Variables By Global Objective Gray Current Solder.
                                            ii = (int)SolderesOnTable[i].Row;
                                            jj = (int)SolderesOnTable[i].Column;
                                            //Construction of Thinking Gray Soldier By Local Variables.
                                            //if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                            //SolderesOnTable[i] = new DrawSoldier(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                                            //If There is no Thinking Movments on Current Object  

                                            if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                            {
                                                //For All Movable Gray Solders.
                                                for (var j = 0; j < AllDraw.SodierMovments; j++)
                                                ////Parallel.For(0, AllDraw.SodierMovments, j =>
                                                {
                                                    //Thinking of Gray Solder Operation.
                                                    Object OOO = new Object();
                                                    lock (OOO)
                                                    {
                                                        SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                                        SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                                        SolderesOnTable[i].SoldierThinking[0].Kind = 1;
                                                        SolderesOnTable[i].SoldierThinking[j].Thinking(ref SolderesOnTable[i].LoseOcuuredatChiled, ref SolderesOnTable[i].WinOcuuredatChiled);/*.t = new Task(new Action(SolderesOnTable[i].SoldierThinking[j].Thinking));
                                                        SolderesOnTable[i].SoldierThinking[j].t.Start();*


                                                    }
                                                }//);
                                            }
                                        }
                                   
                                }
                            }
                        }
                    }//,
                    // () =>
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {
                            if (ElefantMidle > i)
                            {

                                Object O = new Object();
                                lock (O)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //Ignore of Non Exist Current Elephant Gray Objects.
                                        if (ElephantOnTable != null && ElephantOnTable[i] != null)
                                        {
                                            //Inititae Local Varibale By Global Gray Elephant Objects Varibales.
                                            ii = (int)ElephantOnTable[i].Row;
                                            jj = (int)ElephantOnTable[i].Column;
                                            //Construction of Thinking Objects By Local Varibales.
                                            //if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                                //ElephantOnTable[i] = new DrawElefant(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                                            //If There is Not Thinking Objetive List Elephant Gray. 
                                            if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                            {
                                                //For All Possible Movments.
                                                ////Parallel.For(0, AllDraw.ElefantMovments, j =>
                                                for (var j = 0; j < AllDraw.ElefantMovments; j++)
                                                {
                                                    //Operational Thinking Gray Elephant. 
                                                    Object OOO = new Object();
                                                    lock (OOO)
                                                    {
                                                        ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = true;
                                                        ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = false;
                                                        ElephantOnTable[i].ElefantThinking[0].Kind = 2;
                                                        ElephantOnTable[i].ElefantThinking[0].t = new Task(new Action(ElephantOnTable[i].ElefantThinking[0].Thinking));
                                                        ElephantOnTable[i].ElefantThinking[0].t.Start();


                                                    }
                                                }//);
                                            }
                                        }
                                   
                                }
                            }
                        }
                    }//,
                     //() =>
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {
                            if (HourseMidle > i)
                            {

                                Object O = new Object();
                                lock (O)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //Ignore of Non Exist Current Gray Hourse Objects.
                                        if (HoursesOnTable != null && HoursesOnTable[i] != null)
                                        {
                                            //Initiate of Local Variables By Global Gray Hourse Objectives.
                                            ii = (int)HoursesOnTable[i].Row;
                                            jj = (int)HoursesOnTable[i].Column;
                                            //Construction of Gray Hourse Thinking Objects..
                                            //if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                                //HoursesOnTable[i] = new DrawHourse(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                                            //When There is Not HourseList Count. 
                                            if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                            {
                                                //For All Possible Movments.
                                                for (var j = 0; j < AllDraw.HourseMovments; j++)
                                                ////Parallel.For(0, AllDraw.HourseMovments, j =>
                                                {
                                                    //Thinking of Gray Hourse Oprational.
                                                    Object OOO = new Object();
                                                    lock (OOO)
                                                    {
                                                        HoursesOnTable[i].HourseThinking[0].ThinkingBegin = true;
                                                        HoursesOnTable[i].HourseThinking[0].ThinkingFinished = false;
                                                        HoursesOnTable[i].HourseThinking[0].Kind = 3;
                                                        HoursesOnTable[i].HourseThinking[0].t = new Task(new Action(HoursesOnTable[i].HourseThinking[0].Thinking));
                                                        HoursesOnTable[i].HourseThinking[0].t.Start();
                                                    }
                                                }//);
                                            }
                                        }
                                   
                                }
                            }
                        }
                    }//,
                     //() =>
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {
                            if (CastleMidle > i)
                            {
                                Object O = new Object();
                                lock (O)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //When Current Castles Gray Not Exist Continue Traversal Back.
                                        if (CastlesOnTable != null && CastlesOnTable[i] != null)
                                        {
                                            //Initaiate of Local Varibales By Global Varoiables.
                                            ii = (int)CastlesOnTable[i].Row;
                                            jj = (int)CastlesOnTable[i].Column;
                                            //Construction of Thinking Variables By Local Variables.
                                            //if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count == 0)
                                                //CastlesOnTable[i] = new DrawCastle(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                                            //When Count of Table Castles of Thinking Not Exist Do Operational.
                                            if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count == 0)
                                            {
                                                //For All Possible Movments.
                                                ////Parallel.For(0, AllDraw.CastleMovments, j =>
                                                for (var j = 0; j < AllDraw.CastleMovments; j++)
                                                {
                                                    Object OOO = new Object();
                                                    lock (OOO)
                                                    {
                                                        //Thinking of Gray Castles Operational.
                                                        CastlesOnTable[i].CastleThinking[0].ThinkingBegin = true;
                                                        CastlesOnTable[i].CastleThinking[0].ThinkingFinished = false;
                                                        CastlesOnTable[i].CastleThinking[0].Kind = 4;
                                                        CastlesOnTable[i].CastleThinking[0].Thinking(ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled);/*.t = new Task(new Action(CastlesOnTable[i].CastleThinking[0].Thinking));
                                                        CastlesOnTable[i].CastleThinking[0].t.Start();*/



                                                    }
                                                }//);
                                            }
                                        }
                                   
                                }
                            }
                        }
                    }//,
                    // () =>
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {
                            if (MinisterMidle > i)
                            {

                                
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //For Each Non Exist Gray Minister Objectives.
                                        if (MinisterOnTable != null && MinisterOnTable[i] != null)
                                        {
                                            //Inititate Local Variables By Global Varibales.
                                            ii = (int)MinisterOnTable[i].Row;
                                            jj = (int)MinisterOnTable[i].Column;
                                            //Construction of Thinking Objects Gray Minister.
                                            //if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                            //MinisterOnTable[i] = new DrawMinister(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                                            //If There is Not Minister Of Gray In The Thinking Table List.   
                                            if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                            {
                                                //For All Possible Movments.
                                                for (var j = 0; j < AllDraw.MinisterMovments; j++)
                                                ////Parallel.For(0, AllDraw.MinisterMovments, j =>
                                                {
                                                    //Thinking of Gray Minister Operational.
                                                    Object OOO = new Object();
                                                    lock (OOO)
                                                    {
                                                        MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                                        MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;
                                                        MinisterOnTable[i].MinisterThinking[0].Kind = 5;
                                                        MinisterOnTable[i].MinisterThinking[0].Thinking(ref MinisterOnTable[i].LoseOcuuredatChiled, ref MinisterOnTable[i].WinOcuuredatChiled);/*.t = new Task(new Action(MinisterOnTable[i].MinisterThinking[0].Thinking));
                                                        MinisterOnTable[i].MinisterThinking[0].t.Start();*/




                                                    }
                                                }//);
                                            }
                                        }
                                    }
                               
                            }
                        }
                    }//,
                     //() =>
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {

                            if (KingMidle > i)
                            {


                                Object O = new Object();
                                lock (O)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //If There is Not Current Object Continue Traversal Back.
                                        if (KingOnTable != null && KingOnTable[i] != null)
                                        {
                                            //Initiate Local varibale By Global Objective Varibales.
                                            ii = (int)(int)KingOnTable[i].Row;
                                            jj = (int)KingOnTable[i].Column;
                                            //Construction of Gray King Thinking Objects.
                                            //if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                            //KingOnTable[i] = new DrawKing(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                                            //When There is Not Thinking Table Gray King Movments.
                                            if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                            {
                                                //For All Possible Gray King Movments.
                                                ////Parallel.For(0, AllDraw.KingMovments, j =>
                                                for (var j = 0; j < AllDraw.KingMovments; j++)
                                                {
                                                    //Thinking Of Gray King Operatins.
                                                    Object OOO = new Object();
                                                    lock (OOO)
                                                    {
                                                        KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                                        KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                                        KingOnTable[i].KingThinking[0].Kind = 6;
                                                        KingOnTable[i].KingThinking[0].Thinking(ref MinisterOnTable[i].LoseOcuuredatChiled, ref MinisterOnTable[i].WinOcuuredatChiled);/*.t = new Task(new Action(KingOnTable[i].KingThinking[0].Thinking));
                                                        KingOnTable[i].KingThinking[0].t.Start();*/

                                                    }
                                                }//);
                                            }
                                        }
                                   
                                }
                            }
                        }
                    }//);
                }//);
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedytObjectGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedytObjectBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                ////Parallel.For(MinBrownMidle(), MaxBrownHigh(), i =>
                for (var i = MinBrownMidle(); i < MaxBrownHigh(); i++)
                {

                    //Parallel.Invoke(() =>
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {
                            if (SodierMidle <= i && SodierHigh > i)
                            {
                                Object O = new Object();
                                lock (O)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //If Solders Not Exist Continue and Traversal Back.
                                        if (SolderesOnTable != null && SolderesOnTable[i] != null)
                                        {
                                            //Initiate of Local Variables By Global Objective Gray Current Solder.
                                            ii = (int)SolderesOnTable[i].Row;
                                            jj = (int)SolderesOnTable[i].Column;
                                            //Construction of Thinking Gray Soldier By Local Variables.
                                            //if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                            //SolderesOnTable[i] = new DrawSoldier(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                                            //If There is no Thinking Movments on Current Object  

                                            if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                            {
                                                //For All Movable Gray Solders.
                                                for (var j = 0; j < AllDraw.SodierMovments; j++)
                                                ////Parallel.For(0, AllDraw.SodierMovments, j =>
                                                {
                                                    //Thinking of Gray Solder Operation.
                                                    Object OOO = new Object();
                                                    lock (OOO)
                                                    {
                                                        SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                                        SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                                        SolderesOnTable[i].SoldierThinking[0].Kind = 1;
                                                        SolderesOnTable[i].SoldierThinking[0].Thinking(ref SolderesOnTable[i].LoseOcuuredatChiled, ref SolderesOnTable[i].WinOcuuredatChiled);/*.t = new Task(new Action(SolderesOnTable[i].SoldierThinking[0].Thinking));
                                                        SolderesOnTable[i].SoldierThinking[0].t.Start();*/
                                                    }
                                                }//);
                                            }
                                        }
                                   
                                }
                            }
                        }
                    }//,() =>
                    {
                        Object oooo = new Object();
                        lock (oooo)
                        {

                            if (ElefantMidle <= i && ElefantHigh > i)
                            {

                                Object O = new Object();
                                lock (O)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //Ignore of Non Exist Current Elephant Gray Objects.
                                        if (ElephantOnTable != null && ElephantOnTable[i] != null)
                                        {
                                            //Inititae Local Varibale By Global Gray Elephant Objects Varibales.
                                            ii = (int)ElephantOnTable[i].Row;
                                            jj = (int)ElephantOnTable[i].Column;
                                            //Construction of Thinking Objects By Local Varibales.
                                            //if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                            //ElephantOnTable[i] = new DrawElefant(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                                            //If There is Not Thinking Objetive List Elephant Gray. 
                                            if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                            {
                                                //For All Possible Movments.
                                                ////Parallel.For(0, AllDraw.ElefantMovments, j =>
                                                for (var j = 0; j < AllDraw.ElefantMovments; j++)
                                                {
                                                    //Operational Thinking Gray Elephant. 
                                                    Object OOO = new Object();
                                                    lock (OOO)
                                                    {
                                                        ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = true;
                                                        ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = false;
                                                        ElephantOnTable[i].ElefantThinking[0].Kind = 2;
                                                        ElephantOnTable[i].ElefantThinking[0].Thinking(ref ElephantOnTable[i].LoseOcuuredatChiled, ref ElephantOnTable[i].WinOcuuredatChiled);/*.t = new Task(new Action(ElephantOnTable[i].ElefantThinking[0].Thinking));
                                                        ElephantOnTable[i].ElefantThinking[0].t.Start();*/
                                                    }
                                                }//);
                                            }
                                        }
                                   
                                }
                            }
                        }
                    }//,() =>
                    {
                        Object oooo = new Object();
                        lock (oooo)
                        {

                            if (HourseMidle <= i && HourseHight > i)
                            {

                                Object O = new Object();
                                lock (O)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //Ignore of Non Exist Current Gray Hourse Objects.
                                        if (HoursesOnTable != null && HoursesOnTable[i] != null)
                                        {
                                            //Initiate of Local Variables By Global Gray Hourse Objectives.
                                            ii = (int)HoursesOnTable[i].Row;
                                            jj = (int)HoursesOnTable[i].Column;
                                            //Construction of Gray Hourse Thinking Objects..
                                            //if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                            //HoursesOnTable[i] = new DrawHourse(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                                            //When There is Not HourseList Count. 
                                            if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                            {
                                                //For All Possible Movments.
                                                for (var j = 0; j < AllDraw.HourseMovments; j++)
                                                ////Parallel.For(0, AllDraw.HourseMovments, j =>
                                                {
                                                    //Thinking of Gray Hourse Oprational.
                                                    Object OOO = new Object();
                                                    lock (OOO)
                                                    {
                                                        HoursesOnTable[i].HourseThinking[0].ThinkingBegin = true;
                                                        HoursesOnTable[i].HourseThinking[0].ThinkingFinished = false;
                                                        HoursesOnTable[i].HourseThinking[0].Kind = 3;
                                                        HoursesOnTable[i].HourseThinking[0].Thinking(ref HoursesOnTable[i].LoseOcuuredatChiled, ref HoursesOnTable[i].WinOcuuredatChiled);/*.t = new Task(new Action(HoursesOnTable[i].HourseThinking[0].Thinking));
                                                        HoursesOnTable[i].HourseThinking[0].t.Start();*/
                                                    }
                                                }//);
                                            }
                                        }
                                   
                                }
                            }
                        }

                    }//,() =>
                    {
                        Object oooo = new Object();
                        lock (oooo)
                        {

                            if (CastleMidle <= i && CastleHigh < i)
                            {
                                Object O = new Object();
                                lock (O)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //When Current Castles Gray Not Exist Continue Traversal Back.
                                        if (CastlesOnTable != null && CastlesOnTable[i] != null)
                                        {
                                            //Initaiate of Local Varibales By Global Varoiables.
                                            ii = (int)CastlesOnTable[i].Row;
                                            jj = (int)CastlesOnTable[i].Column;
                                            //Construction of Thinking Variables By Local Variables.
                                            //if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count == 0)
                                            //CastlesOnTable[i] = new DrawCastle(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                                            //When Count of Table Castles of Thinking Not Exist Do Operational.
                                            if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count == 0)
                                            {
                                                //For All Possible Movments.
                                                ////Parallel.For(0, AllDraw.CastleMovments, j =>
                                                for (var j = 0; j < AllDraw.CastleMovments; j++)
                                                {
                                                    Object OOO = new Object();
                                                    lock (OOO)
                                                    {
                                                        //Thinking of Gray Castles Operational.
                                                        CastlesOnTable[i].CastleThinking[0].ThinkingBegin = true;
                                                        CastlesOnTable[i].CastleThinking[0].ThinkingFinished = false;
                                                        CastlesOnTable[i].CastleThinking[0].Kind = 4;
                                                        CastlesOnTable[i].CastleThinking[0].Thinking(ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled);/*.t = new Task(new Action(HoursesOnTable[i].HourseThinking[0].Thinking));
                                                        CastlesOnTable[i].CastleThinking[0].t.Start();*/
                                                    }
                                                }//);
                                            }
                                        }
                                   
                                }
                            }
                        }
                    }//,() =>
                    {
                        Object oooo = new Object();
                        lock (oooo)
                        {

                            

                                if (MinisterMidle <= i && MinisterHigh > i)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //For Each Non Exist Gray Minister Objectives.
                                        if (MinisterOnTable != null && MinisterOnTable[i] != null)
                                        {
                                            //Inititate Local Variables By Global Varibales.
                                            ii = (int)MinisterOnTable[i].Row;
                                            jj = (int)MinisterOnTable[i].Column;
                                            //Construction of Thinking Objects Gray Minister.
                                            //if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                            //MinisterOnTable[i] = new DrawMinister(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                                            //If There is Not Minister Of Gray In The Thinking Table List.   
                                            if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                            {
                                                //For All Possible Movments.
                                                ////Parallel.For(0, AllDraw.MinisterMovments, j =>
                                                for (var j = 0; j < AllDraw.MinisterMovments; j++)
                                                {
                                                    //Thinking of Gray Minister Operational.
                                                    Object OOO = new Object();
                                                    lock (OOO)
                                                    {
                                                        MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                                        MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;
                                                        MinisterOnTable[i].MinisterThinking[0].Kind = 5;
                                                        MinisterOnTable[i].MinisterThinking[0].Thinking(ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled);/*.t = new Task(new Action(MinisterOnTable[i].MinisterThinking[0].Thinking));
                                                        MinisterOnTable[i].MinisterThinking[0].t.Start();*/
                                                    }
                                                }//);
                                            }
                                        }
                                    }
                                }
                           
                        }

                    }//,
                    // () =>
                    {
                        Object oooo = new Object();
                        lock (oooo)
                        {
                            if (KingMidle <= i && KingHigh > i)
                            {
                                Object O = new Object();
                                lock (O)
                                {
                                    
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //If There is Not Current Object Continue Traversal Back.
                                        if (KingOnTable != null && KingOnTable[i] != null)
                                        {
                                            //Initiate Local varibale By Global Objective Varibales.
                                            ii = (int)(int)KingOnTable[i].Row;
                                            jj = (int)KingOnTable[i].Column;
                                            //Construction of Gray King Thinking Objects.
                                            //if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                            //KingOnTable[i] = new DrawKing(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                                            //When There is Not Thinking Table Gray King Movments.
                                            if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                            {
                                                //For All Possible Gray King Movments.
                                                for (var j = 0; j < AllDraw.KingMovments; j++)
                                                {
                                                    //Thinking Of Gray King Operatins.
                                                    Object OOO = new Object();
                                                    lock (OOO)
                                                    {
                                                        KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                                        KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                                        KingOnTable[i].KingThinking[0].Kind = 6;
                                                        KingOnTable[i].KingThinking[0].Thinking(ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled);/*.t = new Task(new Action(KingOnTable[i].KingThinking[0].Thinking));
                                                        KingOnTable[i].KingThinking[0].t.Start();*/
                                                    }
                                                }//);
                                            }
                                        }
                                   
                                }
                            }
                        }
                    }//);

                }//);
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedytObjectBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        int FoundTableIndex(List<int[,]> T, int[,] TAab)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int C = -1;
            for (var i = 0; i < T.Count; i++)
            {
                if (TableEqual(T[i], TAab))
                    C = i;
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundTableIndex:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return C;
        }
        bool TableEqual(int[,] t1, int[,] t2)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Is = true;
            for (var i = 0; i < 8; i++)
                for (var j = 0; j < 8; j++)
                {
                    if (t1[i, j] != t2[i, j])
                        Is = false;
                }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("TableEqual:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Is;
        }
        void Serve(int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            if (Order== 1)
            {
                for (var i = 0; i < SodierMidle; i++)
                {
                    if (SolderesOnTable == null || SolderesOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 1, i);
                }
                for (var i = 0; i < ElefantMidle; i++)
                {
                    if (ElephantOnTable == null || ElephantOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 2, i);
                }
                for (var i = 0; i < HourseMidle; i++)
                {
                    if (HoursesOnTable == null || HoursesOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 3, i);
                }
                for (var i = 0; i < CastleMidle; i++)
                {
                    if (CastlesOnTable == null || CastlesOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 4, i);
                }

                for (var i = 0; i < MinisterMidle; i++)
                {
                    if (MinisterOnTable == null || MinisterOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 5, i);
                }
                for (var i = 0; i < KingMidle; i++)
                {
                    if (KingOnTable == null || KingOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 6, i);
                }

            }
            else
            {
                for (var i = SodierMidle; i < SodierHigh; i++)
                {
                    if (SolderesOnTable == null || SolderesOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 1, i);
                }
                for (var i = ElefantMidle; i < ElefantHigh; i++)
                {
                    if (ElephantOnTable == null || ElephantOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 2, i);
                }
                for (var i = HourseMidle; i < HourseHight; i++)
                {
                    if (HoursesOnTable == null || HoursesOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 3, i);
                }
                for (var i = CastleMidle; i < CastleHigh; i++)
                {
                    if (CastlesOnTable == null || CastlesOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 4, i);
                }
                for (var i = MinisterMidle; i < MinisterHigh; i++)
                {
                    if (MinisterOnTable == null || MinisterOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 5, i);
                }
                for (var i = KingMidle; i < KingHigh; i++)
                {
                    if (KingOnTable == null || KingOnTable[i] == null)
                        continue;
                    ServeISSup(Order, 6, i);
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Serve:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //Parallel.ForEach(tH, items => Task.WaitAny(items));
        void ServeISSup(int Order, int Kind,
                int ii
               )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            if (Kind == 1)
            {
                if (Order== 1)
                {
                    //if (SolderesOnTable[ii].SoldierThinking[0].IsSup[j])
                    {

                        for (var i = 0; i < SodierMidle; i++)
                        {
                            if (SolderesOnTable==null||SolderesOnTable[i] == null)
                                continue;
                            //var j = FoundTableIndex(this.SolderesOnTable[i].SoldierThinking[0].TableListSolder, SolderesOnTable[ii].SoldierThinking[0].TableConst);
                            for (var j = 0; j < SolderesOnTable[i].SoldierThinking[0].HuristicListSolder.Count; j++)
                            {
                                if (!(SolderesOnTable[i].SoldierThinking[0].IsSup[j]))
                                    continue;


                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][0] += SolderesOnTable[ii].SoldierThinking[0].HuristicAttackValueSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][1] += SolderesOnTable[ii].SoldierThinking[0].HuristicMovementValueSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][2] += SolderesOnTable[ii].SoldierThinking[0].HuristicSelfSupportedValueSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][3] += SolderesOnTable[ii].SoldierThinking[0].HuristicObjectDangourCheckMateValueSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][4] += SolderesOnTable[ii].SoldierThinking[0].HuristicKillerValueSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][5] += SolderesOnTable[ii].SoldierThinking[0].HuristicReducedAttackValueSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][6] += SolderesOnTable[ii].SoldierThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][7] += SolderesOnTable[ii].SoldierThinking[0].HeuristicKingSafeSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][8] += SolderesOnTable[ii].SoldierThinking[0].HeuristicFromCenterSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][9] += SolderesOnTable[ii].SoldierThinking[0].HeuristicKingDangourSup;
                                SolderesOnTable[i].SoldierThinking[0].IsSup[j] = false;

                                AllDraw.OutPut.Append("\r\nServed Soldeir!");
                            }
                        }
                        SolderesOnTable[ii].SoldierThinking[0].HuristicAttackValueSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HuristicMovementValueSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HuristicSelfSupportedValueSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HuristicObjectDangourCheckMateValueSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HuristicKillerValueSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HuristicReducedAttackValueSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HeuristicKingSafeSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HeuristicFromCenterSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HeuristicKingDangourSup = 0;
                    }
                }
                else
                {
                    //if (SolderesOnTable[ii].SoldierThinking[0].IsSup[j])
                    {

                        for (var i = SodierMidle; i < SodierHigh; i++)
                        {
                            if (SolderesOnTable==null||SolderesOnTable[i] == null)
                                continue;
                            //var j = FoundTableIndex(this.SolderesOnTable[i].SoldierThinking[0].TableListSolder, SolderesOnTable[ii].SoldierThinking[0].TableConst);
                            for (var j = 0; j < SolderesOnTable[i].SoldierThinking[0].HuristicListSolder.Count; j++)
                            {
                                if (!(SolderesOnTable[i].SoldierThinking[0].IsSup[j]))
                                    continue;


                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][0] += SolderesOnTable[ii].SoldierThinking[0].HuristicAttackValueSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][1] += SolderesOnTable[ii].SoldierThinking[0].HuristicMovementValueSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][2] += SolderesOnTable[ii].SoldierThinking[0].HuristicSelfSupportedValueSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][3] += SolderesOnTable[ii].SoldierThinking[0].HuristicObjectDangourCheckMateValueSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][4] += SolderesOnTable[ii].SoldierThinking[0].HuristicKillerValueSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][5] += SolderesOnTable[ii].SoldierThinking[0].HuristicReducedAttackValueSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][6] += SolderesOnTable[ii].SoldierThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][7] += SolderesOnTable[ii].SoldierThinking[0].HeuristicKingSafeSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][8] += SolderesOnTable[ii].SoldierThinking[0].HeuristicFromCenterSup;
                                this.SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][9] += SolderesOnTable[ii].SoldierThinking[0].HeuristicKingDangourSup;
                                SolderesOnTable[i].SoldierThinking[0].IsSup[j] = false;

                                AllDraw.OutPut.Append("\r\nServed Soldeir!");
                            }
                        }
                        SolderesOnTable[ii].SoldierThinking[0].HuristicAttackValueSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HuristicMovementValueSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HuristicSelfSupportedValueSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HuristicObjectDangourCheckMateValueSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HuristicKillerValueSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HuristicReducedAttackValueSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HeuristicKingSafeSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HeuristicFromCenterSup = 0;
                        SolderesOnTable[ii].SoldierThinking[0].HeuristicKingDangourSup = 0;
                    }
                }
            }
            else if (Kind == 2)
            {
                if (Order== 1)
                {
                    //if (ElephantOnTable[ii].ElefantThinking[0].IsSup[j])
                    {
                        for (var i = 0; i < ElefantMidle; i++)
                        {
                            if (ElephantOnTable==null||ElephantOnTable[i] == null)
                                continue;
                            //if (this != null && this != null)
                            {
                                //var j = FoundTableIndex(this.ElephantOnTable[i].ElefantThinking[0].TableListElefant, ElephantOnTable[ii].ElefantThinking[0].TableConst);
                                for (var j = 0; j < ElephantOnTable[i].ElefantThinking[0].HuristicListElefant.Count; j++)
                                {
                                    if (!(ElephantOnTable[i].ElefantThinking[0].IsSup[j]))
                                        continue;

                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][0] += ElephantOnTable[ii].ElefantThinking[0].HuristicAttackValueSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][1] += ElephantOnTable[ii].ElefantThinking[0].HuristicMovementValueSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][2] += ElephantOnTable[ii].ElefantThinking[0].HuristicSelfSupportedValueSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][3] += ElephantOnTable[ii].ElefantThinking[0].HuristicObjectDangourCheckMateValueSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][4] += ElephantOnTable[ii].ElefantThinking[0].HuristicKillerValueSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][5] += ElephantOnTable[ii].ElefantThinking[0].HuristicReducedAttackValueSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][6] += ElephantOnTable[ii].ElefantThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][7] += ElephantOnTable[ii].ElefantThinking[0].HeuristicKingSafeSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][8] += ElephantOnTable[ii].ElefantThinking[0].HeuristicFromCenterSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][9] += ElephantOnTable[ii].ElefantThinking[0].HeuristicKingDangourSup;
                                    ElephantOnTable[i].ElefantThinking[0].IsSup[j] = false;

                                    AllDraw.OutPut.Append("\r\nServed Elephant!");
                                }
                            }
                        }
                        ElephantOnTable[ii].ElefantThinking[0].HuristicAttackValueSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HuristicMovementValueSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HuristicSelfSupportedValueSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HuristicObjectDangourCheckMateValueSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HuristicKillerValueSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HuristicReducedAttackValueSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HeuristicKingSafeSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HeuristicFromCenterSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HeuristicKingDangourSup = 0;
                    }
                }
                else
                {

                    //if (ElephantOnTable[ii].ElefantThinking[0].IsSup[j])
                    {
                        for (var i = ElefantMidle; i < ElefantHigh; i++)
                        {
                            if (ElephantOnTable==null||ElephantOnTable[i] == null)
                                continue;
                            //if (this != null && this != null)
                            {
                                //var j = FoundTableIndex(this.ElephantOnTable[i].ElefantThinking[0].TableListElefant, ElephantOnTable[ii].ElefantThinking[0].TableConst);
                                for (var j = 0; j < ElephantOnTable[i].ElefantThinking[0].HuristicListElefant.Count; j++)
                                {
                                    if (!(ElephantOnTable[i].ElefantThinking[0].IsSup[j]))
                                        continue;


                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][0] += ElephantOnTable[ii].ElefantThinking[0].HuristicAttackValueSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][1] += ElephantOnTable[ii].ElefantThinking[0].HuristicMovementValueSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][2] += ElephantOnTable[ii].ElefantThinking[0].HuristicSelfSupportedValueSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][3] += ElephantOnTable[ii].ElefantThinking[0].HuristicObjectDangourCheckMateValueSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][4] += ElephantOnTable[ii].ElefantThinking[0].HuristicKillerValueSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][5] += ElephantOnTable[ii].ElefantThinking[0].HuristicReducedAttackValueSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][6] += ElephantOnTable[ii].ElefantThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][7] += ElephantOnTable[ii].ElefantThinking[0].HeuristicKingSafeSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][8] += ElephantOnTable[ii].ElefantThinking[0].HeuristicFromCenterSup;
                                    this.ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][9] += ElephantOnTable[ii].ElefantThinking[0].HeuristicKingDangourSup;
                                    ElephantOnTable[i].ElefantThinking[0].IsSup[j] = false;

                                    AllDraw.OutPut.Append("\r\nServed Elephant!");
                                }
                            }
                        }
                        ElephantOnTable[ii].ElefantThinking[0].HuristicAttackValueSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HuristicMovementValueSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HuristicSelfSupportedValueSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HuristicObjectDangourCheckMateValueSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HuristicKillerValueSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HuristicReducedAttackValueSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HeuristicKingSafeSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HeuristicFromCenterSup = 0;
                        ElephantOnTable[ii].ElefantThinking[0].HeuristicKingDangourSup = 0;
                    }
                }
            }
            else if (Kind == 3)
            {
                if (Order== 1)
                {
                    //if (HoursesOnTable[ii].HourseThinking[0].IsSup[j])
                    {
                        for (var i = 0; i < HourseMidle; i++)
                        {
                            if (HoursesOnTable==null||HoursesOnTable[i] == null)
                                continue;
                            //var j = FoundTableIndex(this.HoursesOnTable[i].HourseThinking[0].TableListHourse, HoursesOnTable[ii].HourseThinking[0].TableConst);
                            for (var j = 0; j < HoursesOnTable[i].HourseThinking[0].HuristicListHourse.Count; j++)
                            {
                                if (!(HoursesOnTable[i].HourseThinking[0].IsSup[j]))
                                    continue;

                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][0] += HoursesOnTable[ii].HourseThinking[0].HuristicAttackValueSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][1] += HoursesOnTable[ii].HourseThinking[0].HuristicMovementValueSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][2] += HoursesOnTable[ii].HourseThinking[0].HuristicSelfSupportedValueSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][3] += HoursesOnTable[ii].HourseThinking[0].HuristicObjectDangourCheckMateValueSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][4] += HoursesOnTable[ii].HourseThinking[0].HuristicKillerValueSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][5] += HoursesOnTable[ii].HourseThinking[0].HuristicReducedAttackValueSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][6] += HoursesOnTable[ii].HourseThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][7] += HoursesOnTable[ii].HourseThinking[0].HeuristicKingSafeSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][8] += HoursesOnTable[ii].HourseThinking[0].HeuristicFromCenterSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][9] += HoursesOnTable[ii].HourseThinking[0].HeuristicKingDangourSup;
                                HoursesOnTable[i].HourseThinking[0].IsSup[j] = false;

                                AllDraw.OutPut.Append("\r\nServed Hourse!");
                            }
                        }
                        HoursesOnTable[ii].HourseThinking[0].HuristicAttackValueSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HuristicMovementValueSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HuristicSelfSupportedValueSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HuristicObjectDangourCheckMateValueSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HuristicKillerValueSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HuristicReducedAttackValueSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HeuristicKingSafeSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HeuristicFromCenterSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HeuristicKingDangourSup = 0;
                    }

                }
                else
                {
                    //if (HoursesOnTable[ii].HourseThinking[0].IsSup[j])
                    {
                        for (var i = HourseMidle; i < HourseHight; i++)
                        {
                            if (HoursesOnTable==null||HoursesOnTable[i] == null)
                                continue;
                            //var j = FoundTableIndex(this.HoursesOnTable[i].HourseThinking[0].TableListHourse, HoursesOnTable[ii].HourseThinking[0].TableConst);
                            for (var j = 0; j < HoursesOnTable[i].HourseThinking[0].HuristicListHourse.Count; j++)
                            {
                                if (!(HoursesOnTable[i].HourseThinking[0].IsSup[j]))
                                    continue;

                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][0] += HoursesOnTable[ii].HourseThinking[0].HuristicAttackValueSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][1] += HoursesOnTable[ii].HourseThinking[0].HuristicMovementValueSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][2] += HoursesOnTable[ii].HourseThinking[0].HuristicSelfSupportedValueSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][3] += HoursesOnTable[ii].HourseThinking[0].HuristicObjectDangourCheckMateValueSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][4] += HoursesOnTable[ii].HourseThinking[0].HuristicKillerValueSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][5] += HoursesOnTable[ii].HourseThinking[0].HuristicReducedAttackValueSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][6] += HoursesOnTable[ii].HourseThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][7] += HoursesOnTable[ii].HourseThinking[0].HeuristicKingSafeSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][8] += HoursesOnTable[ii].HourseThinking[0].HeuristicFromCenterSup;
                                this.HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][9] += HoursesOnTable[ii].HourseThinking[0].HeuristicKingDangourSup;
                                HoursesOnTable[i].HourseThinking[0].IsSup[j] = false;

                                AllDraw.OutPut.Append("\r\nServed Hourse!");
                            }
                        }
                        HoursesOnTable[ii].HourseThinking[0].HuristicAttackValueSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HuristicMovementValueSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HuristicSelfSupportedValueSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HuristicObjectDangourCheckMateValueSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HuristicKillerValueSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HuristicReducedAttackValueSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HeuristicKingSafeSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HeuristicFromCenterSup = 0;
                        HoursesOnTable[ii].HourseThinking[0].HeuristicKingDangourSup = 0;
                    }
                }
            }
            else if (Kind == 4)
            {
                if (Order== 1)
                {
                    //if (CastlesOnTable[ii].CastleThinking[0].IsSup[j])
                    {
                        for (var i = 0; i < CastleMidle; i++)
                        {
                            if (CastlesOnTable==null||CastlesOnTable[i] == null)
                                continue;
                            //var j = FoundTableIndex(this.CastlesOnTable[i].CastleThinking[0].TableListCastle, CastlesOnTable[ii].CastleThinking[0].TableConst);
                            for (var j = 0; j < CastlesOnTable[i].CastleThinking[0].HuristicListCastle.Count; j++)
                            {
                                if (!(CastlesOnTable[i].CastleThinking[0].IsSup[j]))
                                    continue;

                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][0] += CastlesOnTable[ii].CastleThinking[0].HuristicAttackValueSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][1] += CastlesOnTable[ii].CastleThinking[0].HuristicMovementValueSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][2] += CastlesOnTable[ii].CastleThinking[0].HuristicSelfSupportedValueSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][3] += CastlesOnTable[ii].CastleThinking[0].HuristicObjectDangourCheckMateValueSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][4] += CastlesOnTable[ii].CastleThinking[0].HuristicKillerValueSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][5] += CastlesOnTable[ii].CastleThinking[0].HuristicReducedAttackValueSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][6] += CastlesOnTable[ii].CastleThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][7] += CastlesOnTable[ii].CastleThinking[0].HeuristicKingSafeSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][8] += CastlesOnTable[ii].CastleThinking[0].HeuristicFromCenterSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][9] += CastlesOnTable[ii].CastleThinking[0].HeuristicKingDangourSup;
                                CastlesOnTable[i].CastleThinking[0].IsSup[j] = false;

                                AllDraw.OutPut.Append("\r\nServed Castle!");
                            }
                        }
                        CastlesOnTable[ii].CastleThinking[0].HuristicAttackValueSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HuristicMovementValueSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HuristicSelfSupportedValueSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HuristicObjectDangourCheckMateValueSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HuristicKillerValueSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HuristicReducedAttackValueSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HeuristicKingSafeSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HeuristicFromCenterSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HeuristicKingDangourSup = 0;
                    }
                }
                else
                {
                    //if (CastlesOnTable[ii].CastleThinking[0].IsSup[j])
                    {
                        for (var i = CastleMidle; i < CastleHigh; i++)
                        {
                            if (CastlesOnTable==null||CastlesOnTable[i] == null)
                                continue;
                            //var j = FoundTableIndex(this.CastlesOnTable[i].CastleThinking[0].TableListCastle, CastlesOnTable[ii].CastleThinking[0].TableConst);
                            for (var j = 0; j < CastlesOnTable[i].CastleThinking[0].HuristicListCastle.Count; j++)
                            {
                                if (!(CastlesOnTable[i].CastleThinking[0].IsSup[j]))
                                    continue;


                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][0] += CastlesOnTable[ii].CastleThinking[0].HuristicAttackValueSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][1] += CastlesOnTable[ii].CastleThinking[0].HuristicMovementValueSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][2] += CastlesOnTable[ii].CastleThinking[0].HuristicSelfSupportedValueSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][3] += CastlesOnTable[ii].CastleThinking[0].HuristicObjectDangourCheckMateValueSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][4] += CastlesOnTable[ii].CastleThinking[0].HuristicKillerValueSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][5] += CastlesOnTable[ii].CastleThinking[0].HuristicReducedAttackValueSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][6] += CastlesOnTable[ii].CastleThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][7] += CastlesOnTable[ii].CastleThinking[0].HeuristicKingSafeSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][8] += CastlesOnTable[ii].CastleThinking[0].HeuristicFromCenterSup;
                                this.CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][9] += CastlesOnTable[ii].CastleThinking[0].HeuristicKingDangourSup;
                                CastlesOnTable[i].CastleThinking[0].IsSup[j] = false;

                                AllDraw.OutPut.Append("\r\nServed Castle!");
                            }
                        }
                        CastlesOnTable[ii].CastleThinking[0].HuristicAttackValueSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HuristicMovementValueSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HuristicSelfSupportedValueSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HuristicObjectDangourCheckMateValueSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HuristicKillerValueSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HuristicReducedAttackValueSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HeuristicKingSafeSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HeuristicFromCenterSup = 0;
                        CastlesOnTable[ii].CastleThinking[0].HeuristicKingDangourSup = 0;
                    }
                }
            }
            else
            if (Kind == 5)
            {
                if (Order== 1)
                {
                    //if (MinisterOnTable[ii].MinisterThinking[0].IsSup[j])
                    {
                        for (var i = 0; i < MinisterMidle; i++)
                        {
                            if (MinisterOnTable==null||MinisterOnTable[i] == null)
                                continue;
                            //var j = FoundTableIndex(this.MinisterOnTable[i].MinisterThinking[0].TableListMinister, MinisterOnTable[ii].MinisterThinking[0].TableConst);
                            for (var j = 0; j < MinisterOnTable[i].MinisterThinking[0].HuristicListMinister.Count; j++)
                            {
                                if (!(MinisterOnTable[i].MinisterThinking[0].IsSup[j]))
                                    continue;

                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][0] += MinisterOnTable[ii].MinisterThinking[0].HuristicAttackValueSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][1] += MinisterOnTable[ii].MinisterThinking[0].HuristicMovementValueSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][2] += MinisterOnTable[ii].MinisterThinking[0].HuristicSelfSupportedValueSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][3] += MinisterOnTable[ii].MinisterThinking[0].HuristicObjectDangourCheckMateValueSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][4] += MinisterOnTable[ii].MinisterThinking[0].HuristicKillerValueSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][5] += MinisterOnTable[ii].MinisterThinking[0].HuristicReducedAttackValueSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][6] += MinisterOnTable[ii].MinisterThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][7] += MinisterOnTable[ii].MinisterThinking[0].HeuristicKingSafeSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][8] += MinisterOnTable[ii].MinisterThinking[0].HeuristicFromCenterSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][9] += MinisterOnTable[ii].MinisterThinking[0].HeuristicKingDangourSup;
                                MinisterOnTable[i].MinisterThinking[0].IsSup[j] = false;


                                AllDraw.OutPut.Append("\r\nServed Minister!");
                            }
                        }
                        MinisterOnTable[ii].MinisterThinking[0].HuristicAttackValueSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HuristicMovementValueSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HuristicSelfSupportedValueSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HuristicObjectDangourCheckMateValueSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HuristicKillerValueSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HuristicReducedAttackValueSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HeuristicKingSafeSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HeuristicFromCenterSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HeuristicKingDangourSup = 0;
                    }
                }
                else
                {
                    //if (MinisterOnTable[ii].MinisterThinking[0].IsSup[j])
                    {
                        for (var i = MinisterMidle; i < MinisterHigh; i++)
                        {
                            if (MinisterOnTable==null||MinisterOnTable[i] == null)
                                continue;
                            //var j = FoundTableIndex(this.MinisterOnTable[i].MinisterThinking[0].TableListMinister, MinisterOnTable[ii].MinisterThinking[0].TableConst);
                            for (var j = 0; j < MinisterOnTable[i].MinisterThinking[0].HuristicListMinister.Count; j++)
                            {
                                if (!(MinisterOnTable[i].MinisterThinking[0].IsSup[j]))
                                    continue;


                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][0] += MinisterOnTable[ii].MinisterThinking[0].HuristicAttackValueSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][1] += MinisterOnTable[ii].MinisterThinking[0].HuristicMovementValueSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][2] += MinisterOnTable[ii].MinisterThinking[0].HuristicSelfSupportedValueSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][3] += MinisterOnTable[ii].MinisterThinking[0].HuristicObjectDangourCheckMateValueSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][4] += MinisterOnTable[ii].MinisterThinking[0].HuristicKillerValueSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][5] += MinisterOnTable[ii].MinisterThinking[0].HuristicReducedAttackValueSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][6] += MinisterOnTable[ii].MinisterThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][7] += MinisterOnTable[ii].MinisterThinking[0].HeuristicKingSafeSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][8] += MinisterOnTable[ii].MinisterThinking[0].HeuristicFromCenterSup;
                                this.MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][9] += MinisterOnTable[ii].MinisterThinking[0].HeuristicKingDangourSup;
                                MinisterOnTable[i].MinisterThinking[0].IsSup[j] = false;

                                AllDraw.OutPut.Append("\r\nServed Minister!");
                            }
                        }
                        MinisterOnTable[ii].MinisterThinking[0].HuristicAttackValueSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HuristicMovementValueSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HuristicSelfSupportedValueSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HuristicObjectDangourCheckMateValueSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HuristicKillerValueSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HuristicReducedAttackValueSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HeuristicKingSafeSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HeuristicFromCenterSup = 0;
                        MinisterOnTable[ii].MinisterThinking[0].HeuristicKingDangourSup = 0;
                    }
                }
            }
            else
            if (Kind == 6)
            {
                if (Order== 1)
                {
                    //if (KingOnTable[ii].KingThinking[0].IsSup[j])
                    {
                        for (var i = 0; i < KingMidle; i++)
                        {
                            if (KingOnTable==null||KingOnTable[i] == null)
                                continue;
                            //var j = FoundTableIndex(this.KingOnTable[i].KingThinking[0].TableListKing, KingOnTable[ii].KingThinking[0].TableConst);
                            for (var j = 0; j < KingOnTable[i].KingThinking[0].HuristicListKing.Count; j++)
                            {
                                if (!(KingOnTable[i].KingThinking[0].IsSup[j]))
                                    continue;

                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][0] += KingOnTable[ii].KingThinking[0].HuristicAttackValueSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][1] += KingOnTable[ii].KingThinking[0].HuristicMovementValueSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][2] += KingOnTable[ii].KingThinking[0].HuristicSelfSupportedValueSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][3] += KingOnTable[ii].KingThinking[0].HuristicObjectDangourCheckMateValueSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][4] += KingOnTable[ii].KingThinking[0].HuristicKillerValueSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][5] += KingOnTable[ii].KingThinking[0].HuristicReducedAttackValueSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][6] += KingOnTable[ii].KingThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][7] += KingOnTable[ii].KingThinking[0].HeuristicKingSafeSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][8] += KingOnTable[ii].KingThinking[0].HeuristicFromCenterSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][9] += KingOnTable[ii].KingThinking[0].HeuristicKingDangourSup;
                                KingOnTable[i].KingThinking[0].IsSup[j] = false;


                                AllDraw.OutPut.Append("\r\nServed King!");
                            }
                        }
                        KingOnTable[ii].KingThinking[0].HuristicAttackValueSup = 0;
                        KingOnTable[ii].KingThinking[0].HuristicMovementValueSup = 0;
                        KingOnTable[ii].KingThinking[0].HuristicSelfSupportedValueSup = 0;
                        KingOnTable[ii].KingThinking[0].HuristicObjectDangourCheckMateValueSup = 0;
                        KingOnTable[ii].KingThinking[0].HuristicKillerValueSup = 0;
                        KingOnTable[ii].KingThinking[0].HuristicReducedAttackValueSup = 0;
                        KingOnTable[ii].KingThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        KingOnTable[ii].KingThinking[0].HeuristicKingSafeSup = 0;
                        KingOnTable[ii].KingThinking[0].HeuristicFromCenterSup = 0;
                        KingOnTable[ii].KingThinking[0].HeuristicKingDangourSup = 0;

                    }
                }
                else
                {
                    //if (KingOnTable[ii].KingThinking[0].IsSup[j])
                    {
                        for (var i = KingMidle; i < KingHigh; i++)
                        {
                            if (KingOnTable==null||KingOnTable[i] == null)
                                continue;
                            //var j = FoundTableIndex(this.KingOnTable[i].KingThinking[0].TableListKing, KingOnTable[ii].KingThinking[0].TableConst);
                            for (var j = 0; j < KingOnTable[i].KingThinking[0].HuristicListKing.Count; j++)
                            {
                                if (!(KingOnTable[i].KingThinking[0].IsSup[j]))
                                    continue;


                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][0] += KingOnTable[ii].KingThinking[0].HuristicAttackValueSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][1] += KingOnTable[ii].KingThinking[0].HuristicMovementValueSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][2] += KingOnTable[ii].KingThinking[0].HuristicSelfSupportedValueSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][3] += KingOnTable[ii].KingThinking[0].HuristicObjectDangourCheckMateValueSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][4] += KingOnTable[ii].KingThinking[0].HuristicKillerValueSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][5] += KingOnTable[ii].KingThinking[0].HuristicReducedAttackValueSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][6] += KingOnTable[ii].KingThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][7] += KingOnTable[ii].KingThinking[0].HeuristicKingSafeSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][8] += KingOnTable[ii].KingThinking[0].HeuristicFromCenterSup;
                                this.KingOnTable[i].KingThinking[0].HuristicListKing[j][9] += KingOnTable[ii].KingThinking[0].HeuristicKingDangourSup;
                                KingOnTable[i].KingThinking[0].IsSup[j] = false;


                                AllDraw.OutPut.Append("\r\nServed King!");
                            }
                        }
                        KingOnTable[ii].KingThinking[0].HuristicAttackValueSup = 0;
                        KingOnTable[ii].KingThinking[0].HuristicMovementValueSup = 0;
                        KingOnTable[ii].KingThinking[0].HuristicSelfSupportedValueSup = 0;
                        KingOnTable[ii].KingThinking[0].HuristicObjectDangourCheckMateValueSup = 0;
                        KingOnTable[ii].KingThinking[0].HuristicKillerValueSup = 0;
                        KingOnTable[ii].KingThinking[0].HuristicReducedAttackValueSup = 0;
                        KingOnTable[ii].KingThinking[0].HeuristicDistabceOfCurrentMoveFromEnemyKingValueSup = 0;
                        KingOnTable[ii].KingThinking[0].HeuristicKingSafeSup = 0;
                        KingOnTable[ii].KingThinking[0].HeuristicFromCenterSup = 0;
                        KingOnTable[ii].KingThinking[0].HeuristicKingDangourSup = 0;

                    }
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ServeISSup:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }

        AllDraw InitiateAStarGreedytSodlerGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                List<Task> tH = new List<Task>();

                //For Gray Soldeirs Objects. 
                Parallel.For(0, SodierMidle, i =>
                //for (var i = 0; i < SodierMidle; i++)
                {
                    Object O = new Object();
                    lock (O)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        //If Solders Not Exist Continue and Traversal Back.
                        if (SolderesOnTable != null && SolderesOnTable[i] != null)
                        {
                            //Initiate of Local Variables By Global Objective Gray Current Solder.
                            ii = (int)SolderesOnTable[i].Row;
                            jj = (int)SolderesOnTable[i].Column;
                            //Construction of Thinking Gray Soldier By Local Variables.
                            if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                SolderesOnTable[i] = new DrawSoldier(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                            //If There is no Thinking Movments on Current Object  

                            if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                            {
                                //For All Movable Gray Solders.
                                ////Parallel.For(0, AllDraw.SodierMovments, j =>
                                {
                                    //Thinking of Gray Solder Operation.
                                    Object OOO = new Object();
                                    lock (OOO)
                                    {
                                        SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                        SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                        var array = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[0].Thinking(ref SolderesOnTable[i].LoseOcuuredatChiled, ref SolderesOnTable[i].WinOcuuredatChiled));
                                        tH.Add(array);
                                        //ServeISSup(Order,1, i);
                                    }

                                }//);
                            }
                        }

                    }
                });
                Parallel.ForEach(tH, items => Task.WaitAny(items));

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedytSodlerGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedytElephantGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                List<Task> tH = new List<Task>();
                Parallel.For(0, ElefantMidle, i =>
                //for (var i = 0; i < ElefantMidle; i++)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        
                            Order = DummyOrder;
                            ChessRules.CurrentOrder = DummyCurrentOrder;
                            //Ignore of Non Exist Current Elephant Gray Objects.
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)
                            {
                                //Inititae Local Varibale By Global Gray Elephant Objects Varibales.
                                ii = (int)ElephantOnTable[i].Row;
                                jj = (int)ElephantOnTable[i].Column;
                                //Construction of Thinking Objects By Local Varibales.
                                if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                    ElephantOnTable[i] = new DrawElefant(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                                //If There is Not Thinking Objetive List Elephant Gray. 
                                if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                {
                                    //For All Possible Movments.
                                    ////Parallel.For(0, AllDraw.ElefantMovments, j =>
                                    {
                                        //Operational Thinking Gray Elephant. 
                                        Object OOO = new Object();
                                        lock (OOO)
                                        {
                                            ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = true;
                                            ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = false;

                                        var array = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].Thinking(ref ElephantOnTable[i].LoseOcuuredatChiled, ref ElephantOnTable[i].WinOcuuredatChiled));
                                        tH.Add(array);
                                        //ServeISSup(Order,2, i);

                                    }
                                }//);
                                }
                            }
                       
                    }
                });
                Parallel.ForEach(tH, items => Task.WaitAny(items));
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedytElephantGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            
            return this;
        }
        AllDraw InitiateAStarGreedythHourseGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                List<Task> tH = new List<Task>();
                //For All Gray Hourse Objects.
                Parallel.For(0, HourseMidle, i =>
                //for (var i = 0; i < HourseMidle; i++)
                {
                    Object O = new Object();
                    lock (O)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        //Ignore of Non Exist Current Gray Hourse Objects.
                        if (HoursesOnTable != null && HoursesOnTable[i] != null)
                        {
                            //Initiate of Local Variables By Global Gray Hourse Objectives.
                            ii = (int)HoursesOnTable[i].Row;
                            jj = (int)HoursesOnTable[i].Column;
                            //Construction of Gray Hourse Thinking Objects..
                            if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                HoursesOnTable[i] = new DrawHourse(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                            //When There is Not HourseList Count. 
                            if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                            {
                                //For All Possible Movments.
                                ////Parallel.For(0, AllDraw.HourseMovments, j =>
                                {
                                    //Thinking of Gray Hourse Oprational.
                                    Object OOO = new Object();
                                    lock (OOO)
                                    {
                                        HoursesOnTable[i].HourseThinking[0].ThinkingBegin = true;
                                        HoursesOnTable[i].HourseThinking[0].ThinkingFinished = false;
                                        var array = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].Thinking(ref HoursesOnTable[i].LoseOcuuredatChiled, ref HoursesOnTable[i].WinOcuuredatChiled));
                                        tH.Add(array);

                                        //ServeISSup(Order,3, i);



                                    }
                                }//);
                            }
                        }

                    }
                });
                Parallel.ForEach(tH, items => Task.WaitAny(items));

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedythHourseGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedythCastleGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                List<Task> tH = new List<Task>();
                //For All Possible Gray Castles Objects.
                Parallel.For(0, CastleMidle, i =>
                //for (var i = 0; i < CastleMidle; i++)
                {
                    Object O = new Object();
                    lock (O)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        //When Current Castles Gray Not Exist Continue Traversal Back.
                        if (CastlesOnTable != null && CastlesOnTable[i] != null)
                        {
                            //Initaiate of Local Varibales By Global Varoiables.
                            ii = (int)CastlesOnTable[i].Row;
                            jj = (int)CastlesOnTable[i].Column;
                            //Construction of Thinking Variables By Local Variables.
                            if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count == 0)
                                CastlesOnTable[i] = new DrawCastle(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                            //When Count of Table Castles of Thinking Not Exist Do Operational.
                            if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count == 0)
                            {
                                //For All Possible Movments.
                                ////Parallel.For(0, AllDraw.CastleMovments, j =>
                                {
                                    Object OOO = new Object();
                                    lock (OOO)
                                    {
                                        //Thinking of Gray Castles Operational.
                                        CastlesOnTable[i].CastleThinking[0].ThinkingBegin = true;
                                        CastlesOnTable[i].CastleThinking[0].ThinkingFinished = false;

                                        var array = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].Thinking(ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled));
                                        tH.Add(array);
                                        //ServeISSup(Order,4, i);

                                    }
                                }//);

                            }
                        }

                    }
                });
                Parallel.ForEach(tH, items => Task.WaitAny(items));

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedythCastleGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedythMinisterGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                List<Task> tH = new List<Task>();
                //For All Possible Gray Minister Movments.
                Parallel.For(0, MinisterMidle, i =>
                //for (var i = 0; i < MinisterMidle; i++)
                {

                    Object O = new Object();
                    lock (O)
                    {
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        //For Each Non Exist Gray Minister Objectives.
                        if (MinisterOnTable != null && MinisterOnTable[i] != null)
                        {
                            //Inititate Local Variables By Global Varibales.
                            ii = (int)MinisterOnTable[i].Row;
                            jj = (int)MinisterOnTable[i].Column;
                            //Construction of Thinking Objects Gray Minister.
                            if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                MinisterOnTable[i] = new DrawMinister(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                            //If There is Not Minister Of Gray In The Thinking Table List.   
                            if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                            {
                                //For All Possible Movments.
                                // //Parallel.For(0, AllDraw.MinisterMovments, j =>
                                {
                                    //Thinking of Gray Minister Operational.
                                    Object OOO = new Object();
                                    lock (OOO)
                                    {
                                        MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                        MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;

                                        var array = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].Thinking(ref MinisterOnTable[i].LoseOcuuredatChiled, ref MinisterOnTable[i].WinOcuuredatChiled));
                                        tH.Add(array);
                                        //ServeISSup(Order,5, i);

                                    }
                                }//);

                            }
                        }
                    }

                });
                Parallel.ForEach(tH, items => Task.WaitAny(items));
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedythMinisterGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedythKingGray(int iii, int jjjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                List<Task> tH = new List<Task>();
                //For All Possible Gray King Objects.
                Parallel.For(0, KingMidle, i =>
                //for (var i = 0; i < KingMidle; i++)
                {
                    Object O = new Object();
                    lock (O)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        //If There is Not Current Object Continue Traversal Back.
                        if (KingOnTable != null && KingOnTable[i] != null)
                        {
                            //Initiate Local varibale By Global Objective Varibales.
                            ii = (int)(int)KingOnTable[i].Row;
                            jj = (int)KingOnTable[i].Column;
                            //Construction of Gray King Thinking Objects.
                            if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                KingOnTable[i] = new DrawKing(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                            //When There is Not Thinking Table Gray King Movments.
                            if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                            {
                                //For All Possible Gray King Movments.
                                ////Parallel.For(0, AllDraw.KingMovments, j =>
                                {
                                    //Thinking Of Gray King Operatins.
                                    Object OOO = new Object();
                                    lock (OOO)
                                    {
                                        KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                        KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                        ; var array = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].Thinking(ref KingOnTable[i].LoseOcuuredatChiled, ref KingOnTable[i].WinOcuuredatChiled));
                                        tH.Add(array);

                                        //ServeISSup(Order,6, i);
                                    }
                                }//);
                            }
                        }

                    }
                });
                Parallel.ForEach(tH, items => Task.WaitAny(items));
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedythKingGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedythSoldierBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                List<Task> tH = new List<Task>();
                //For Each Objects of Brown Sodiers.
                Parallel.For(SodierMidle, SodierHigh, i =>
                //for (var i = SodierMidle; i < SodierHigh; i++)
                {
                    Object O = new Object();
                    lock (O)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        //Wheen Brown King Object There is Not Continue Traversal Back.
                        if (SolderesOnTable != null && SolderesOnTable[i] != null)
                        {
                            //Initiate Local varibale By Global Objective Varibales.
                            ii = (int)SolderesOnTable[i].Row;
                            jj = (int)SolderesOnTable[i].Column;
                            //Construction of Thinking Brown Current Objects.
                            if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                SolderesOnTable[i] = new DrawSoldier(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                            {
                                //When There is Current Brown Object Table List Thinking Objective Movments.
                                if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                {
                                    //For Each Brown Possible Movments. 
                                    ////Parallel.For(0, AllDraw.SodierMovments, j =>
                                    {
                                        //Thinking Operations of Brown Current Objects.
                                        Object OOO = new Object();
                                        lock (OOO)
                                        {
                                            SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                            SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                            var array = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[0].Thinking(ref SolderesOnTable[i].LoseOcuuredatChiled, ref SolderesOnTable[i].WinOcuuredatChiled));
                                            tH.Add(array);
                                            //ServeISSup(Order,1, i);
                                        }
                                    }//);

                                }

                            }
                        }

                    }
                });
                Parallel.ForEach(tH, items => Task.WaitAny(items));

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedythSoldierBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedythElephantBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                List<Task> tH = new List<Task>();
               Parallel.For(ElefantMidle, ElefantHigh, i =>
               //for (var i = ElefantMidle; i < ElefantHigh; i++)
               {
                   Object O = new Object();
                    lock (O)
                    {
                        
                            Order = DummyOrder;
                            ChessRules.CurrentOrder = DummyCurrentOrder;
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)
                            {
                                //Initiate Local varibale By Global Objective Varibales.
                                ii = (int)ElephantOnTable[i].Row;
                                jj = (int)ElephantOnTable[i].Column;
                                //Construction of Thinking Brown Current Objects.
                                if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                    ElephantOnTable[i] = new DrawElefant(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);
                                {
                                    //When There is Current Brown Object Table List Thinking Objective Movments.
                                    if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                    {
                                        //For Each Brown Possible Movments. 
                                        ////Parallel.For(0, AllDraw.ElefantMovments, j =>
                                        {
                                            Object OOO = new Object();
                                            lock (OOO)
                                            {
                                                //Thinking Operations of Brown Current Objects.
                                                ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = true;
                                                ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = false;
                                           var array = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].Thinking(ref ElephantOnTable[i].LoseOcuuredatChiled, ref ElephantOnTable[i].WinOcuuredatChiled));
                                           tH.Add(array);

                                           //ServeISSup(Order,2, i);
                                       }
                                   }//);
                                    }

                                }
                            }
                       
                    }
                });
                Parallel.ForEach(tH, items => Task.WaitAny(items));

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedythElephantBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedythHourseBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                List<Task> tH = new List<Task>();
               Parallel.For(HourseMidle, HourseHight, i =>
               //for (var i = HourseMidle; i < HourseHight; i++)
               {
                   Object O = new Object();
                    lock (O)
                    {
                        
                            Order = DummyOrder;
                            ChessRules.CurrentOrder = DummyCurrentOrder;
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)
                            {
                                //Initiate Local varibale By Global Objective Varibales.
                                ii = (int)HoursesOnTable[i].Row;
                                jj = (int)HoursesOnTable[i].Column;
                                //Construction of Thinking Brown Current Objects.
                                if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                    HoursesOnTable[i] = new DrawHourse(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);

                                {
                                    //When There is Current Brown Object Table List Thinking Objective Movments.
                                    if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                    {
                                        //For Each Brown Possible Movments. 
                                        ////Parallel.For(0, AllDraw.HourseMovments, j =>
                                        {
                                            Object OOO = new Object();
                                            lock (OOO)
                                            {
                                                //Thinking Operations of Brown Current Objects.
                                                //HoursesOnTable[i].HourseThinking[0].TableT = HoursesOnTable[i].HourseThinking[0].TableT;
                                                HoursesOnTable[i].HourseThinking[0].ThinkingBegin = true;
                                                HoursesOnTable[i].HourseThinking[0].ThinkingFinished = false;
                                                ;
                                           var array = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].Thinking(ref HoursesOnTable[i].LoseOcuuredatChiled, ref HoursesOnTable[i].WinOcuuredatChiled));
                                           tH.Add(array);
                                           //ServeISSup(Order,3, i);
                                       }
                                   }//);

                                    }
                                }
                            }
                       
                    }
                });
                Parallel.ForEach(tH, items => Task.WaitAny(items));

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedythHourseBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedythCastleBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                List<Task> tH = new List<Task>();
                Parallel.For(CastleMidle, CastleHigh, i =>
                //for (var i = CastleMidle; i < CastleHigh; i++)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        
                            Order = DummyOrder;
                            ChessRules.CurrentOrder = DummyCurrentOrder;
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)

                            {
                                //Initiate Local varibale By Global Objective Varibales.
                                ii = (int)CastlesOnTable[i].Row;
                                jj = (int)CastlesOnTable[i].Column;
                                //Construction of Thinking Brown Current Objects.
                                if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count == 0)
                                    CastlesOnTable[i] = new DrawCastle(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);

                                {
                                    //When There is Current Brown Object Table List Thinking Objective Movments.
                                    if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count == 0)
                                    {
                                        //For Each Brown Possible Movments. 
                                        ////Parallel.For(0, AllDraw.CastleMovments, j =>
                                        {
                                            Object OOO = new Object();
                                            lock (OOO)
                                            {
                                                //Thinking Operations of Brown Current Objects.
                                                CastlesOnTable[i].CastleThinking[0].ThinkingBegin = true;
                                                CastlesOnTable[i].CastleThinking[0].ThinkingFinished = false;
                                            var array = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].Thinking(ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled));
                                            tH.Add(array);;
                                                //ServeISSup(Order,4, i);
                                            }
                                        }//);

                                    }
                                }
                            }
                       
                    }
                });
                Parallel.ForEach(tH, items => Task.WaitAny(items));

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedythCastleBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return this;
        }
        AllDraw InitiateAStarGreedythMinisterBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                List<Task> tH = new List<Task>();
                Parallel.For(MinisterMidle, MinisterHigh, i =>
                //for (var i = MinisterMidle; i < MinisterHigh; i++)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        
                            Order = DummyOrder;
                            ChessRules.CurrentOrder = DummyCurrentOrder;
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)
                            {
                                //Initiate Local varibale By Global Objective Varibales.
                                ii = (int)MinisterOnTable[i].Row;
                                jj = (int)MinisterOnTable[i].Column;
                                //Construction of Thinking Brown Current Objects.
                                if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                    MinisterOnTable[i] = new DrawMinister(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);

                                //When There is Current Brown Object Table List Thinking Objective Movments.
                                if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                {
                                    //For Each Brown Possible Movments. 
                                    ////Parallel.For(0, AllDraw.MinisterMovments, j =>
                                    {
                                        Object OOO = new Object();
                                        lock (OOO)
                                        {
                                            //Thinking Operations of Brown Current Objects.
                                            MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                            MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;
                                        var array = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].Thinking(ref MinisterOnTable[i].LoseOcuuredatChiled, ref MinisterOnTable[i].WinOcuuredatChiled));
                                        tH.Add(array); 

                                        
                                            //ServeISSup(Order,5, i);
                                        }
                                    }//);
                                }
                            }
                       
                    }
                });
                Parallel.ForEach(tH, items => Task.WaitAny(items));
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedythMinisterBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
           
            return this;
        }
        AllDraw InitiateAStarGreedythKingBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object oo = new Object();
            lock (oo)
            {
                List<Task> tH = new List<Task>();
                Parallel.For(KingMidle, KingHigh, i =>
                //for (var i = KingMidle; i < KingHigh; i++)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        
                            Order = DummyOrder;
                            ChessRules.CurrentOrder = DummyCurrentOrder;
                            if (KingOnTable != null && KingOnTable[i] != null)
                            {
                                //Initiate Local varibale By Global Objective Varibales.
                                ii = (int)KingOnTable[i].Row;
                                jj = (int)KingOnTable[i].Column;
                                //Construction of Thinking Brown Current Objects.
                                if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                    KingOnTable[i] = new DrawKing(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, CloneATable(Table), Order, false, i);

                                //When There is Current Brown Object Table List Thinking Objective Movments.
                                if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                {
                                    //For Each Brown Possible Movments. 
                                    ////Parallel.For(0, AllDraw.KingMovments, j =>
                                    {
                                        Object OOO = new Object();
                                        lock (OOO)
                                        {
                                            //Thinking Operations of Brown Current Objects.
                                            KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                            KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                        var array = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].Thinking(ref KingOnTable[i].LoseOcuuredatChiled, ref KingOnTable[i].WinOcuuredatChiled));
                                        tH.Add(array);
                                        ;
                                            //ServeISSup(Order,6, i);
                                        }
                                    }//);

                                }
                            }
                       
                    }
                });
                Parallel.ForEach(tH, items => Task.WaitAny(items));
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedythKingBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            
            return this;
        }

        bool FullBoundryConditions(int Current, int Order, int iAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //if (TimerEnded)
            //return true;

            bool IS = false;
            ////if (iAStarGreedy < 0)
            //    IS = true;
            if (Order== 1)
            {
                for (int ikk = 0; ikk < SodierMidle; ikk++)
                {
                    if (SolderesOnTable==null||SolderesOnTable[ikk] == null)
                        continue;
                    if (SolderesOnTable[ikk].LoseOcuuredatChiled < -1)
                    {
                        OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                        IS = true;
                    }
                }
                for (int ikk = 0; ikk < ElefantMidle; ikk++)
                {
                    if (ElephantOnTable==null||ElephantOnTable[ikk] == null)
                        continue;
                    if (ElephantOnTable[ikk].LoseOcuuredatChiled < -1)
                    {
                        OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                        IS = true;
                    }
                }
                for (int ikk = 0; ikk < HourseMidle; ikk++)
                {
                    if (HoursesOnTable==null||HoursesOnTable[ikk] == null)
                        continue;
                    if (HoursesOnTable[ikk].LoseOcuuredatChiled < -1)
                    {
                        OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                        IS = true;
                    }
                }
                for (int ikk = 0; ikk < CastleMidle; ikk++)
                {
                    if (CastlesOnTable==null||CastlesOnTable[ikk] == null)
                        continue;
                    if (CastlesOnTable[ikk].LoseOcuuredatChiled < -1)
                    {
                        OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                        IS = true;
                    }
                }
                for (int ikk = 0; ikk < MinisterMidle; ikk++)
                {
                    if (MinisterOnTable==null||MinisterOnTable[ikk] == null)
                        continue;
                    if (MinisterOnTable[ikk].LoseOcuuredatChiled < -1)
                    {
                        OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                        IS = true;
                    }
                }
                for (int ikk = 0; ikk < KingMidle; ikk++)
                {
                    if (KingOnTable==null||KingOnTable[ikk] == null)
                        continue;
                    if (KingOnTable[ikk].LoseOcuuredatChiled < -1)
                    {
                        OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                        IS = true;
                    }
                }
                if ((ThinkingChess.FoundFirstMating > (MaxAStarGreedy))) //|| (SetDeptIgnore))
                {
                    OutPut.Append("\r\nCheckedMate Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstMating.ToString());
                    IS = true;
                }
                //else
                //if (iAStarGreedy < 0)
                /*{
                    iAStarGreedy = MaxAStarGreedy;
                    OutPut.Append("\r\nLevel Boundry Conditon for iAStarGreedy is Set To " + iAStarGreedy.ToString() + "MaxAStarGreedy";
                }*/
            }
            else
            {
                for (int ikk = SodierMidle; ikk < SodierHigh; ikk++)
                {
                    if (SolderesOnTable[ikk] == null)
                        continue;
                    if (SolderesOnTable[ikk].LoseOcuuredatChiled < -1)
                    {
                        OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                        IS = true;
                    }
                }
                for (int ikk = ElefantMidle; ikk < ElefantHigh; ikk++)
                {
                    if (ElephantOnTable[ikk] == null)
                        continue;
                    if (ElephantOnTable[ikk].LoseOcuuredatChiled < -1)
                    {
                        OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                        IS = true;
                    }
                }
                for (int ikk = HourseMidle; ikk < HourseHight; ikk++)
                {
                    if (HoursesOnTable[ikk] == null)
                        continue;
                    if (HoursesOnTable[ikk].LoseOcuuredatChiled < -1)
                    {
                        OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                        IS = true;
                    }
                }
                for (int ikk = CastleMidle; ikk < CastleHigh; ikk++)
                {
                    if (CastlesOnTable[ikk] == null)
                        continue;
                    if (CastlesOnTable[ikk].LoseOcuuredatChiled < -1)
                    {
                        OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                        IS = true;
                    }
                }
                for (int ikk = MinisterMidle; ikk < MinisterHigh; ikk++)
                {
                    if (MinisterOnTable[ikk] == null)
                        continue;
                    if (MinisterOnTable[ikk].LoseOcuuredatChiled < -1)
                    {
                        OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                        IS = true;
                    }
                }
                for (int ikk = KingMidle; ikk < KingHigh; ikk++)
                {
                    if (KingOnTable[ikk] == null)
                        continue;
                    if (KingOnTable[ikk].LoseOcuuredatChiled < -1)
                    {
                        OutPut.Append("\r\nCheckedMate SELF Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstSelfMating.ToString());
                        IS = true;
                    }
                }
                if ((ThinkingChess.FoundFirstMating > (MaxAStarGreedy))) //|| (SetDeptIgnore))
                {
                    OutPut.Append("\r\nCheckedMate Boundry Conditon in Leafs found at  " + ThinkingChess.FoundFirstMating.ToString());
                    IS = true;
                }
               /* else
                //if (iAStarGreedy < 0)
                {
                    iAStarGreedy = MaxAStarGreedy;
                    OutPut.Append("\r\nLevel Boundry Conditon for iAStarGreedy is Set To " + iAStarGreedy.ToString() + "MaxAStarGreedy";
                }*/
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullBoundryConditions:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return IS;
        } //AStarGreedy First Initiat Thinking Main Method.
        void AstarGreedyThinking(int Order, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int i, int j, int ii, int jj, int[,] Table, Color a, bool TB, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object o = new Object();
            lock (o)
            {

                //If Order is Gray.
                if (Order== 1)
                {
                    int i1 = i, j1 = j;
                    int[,] Tab = CloneATable(Table);
                    int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                    bool TB1 = TB;
                    Color aa = a;

                    var output = Task.Factory.StartNew(() =>
                    Parallel.Invoke(() =>
                    {
                        //For All Gray Soldier Objects.
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedytSodlerGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    }
                    ,
                    () =>
                    {
                        //For All Gray Elephant Objects.
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedytElephantGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    }
                    , () =>
                    {
                        //For All Gray Hourse Objects.
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedythHourseGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    }
                    ,
                    () =>
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedythCastleGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    }
                    , () =>
                    {

                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedythMinisterGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }

                    }
                    , () =>
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedythKingGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    })
                    );
                }
                else//Brown Order Considarations.
                {
                    int i1 = i, j1 = j;
                    int[,] Tab = CloneATable(Table);
                    int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                    bool TB1 = TB;
                    Color aa = a;
                    //If Order is Gray.

                    var output = Task.Factory.StartNew(() =>
                      Parallel.Invoke(() =>
                      {
                          //For All Gray Soldier Objects.
                          Object O = new Object();
                          lock (O)
                          {
                              this.InitiateAStarGreedythSoldierBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                          }
                      }
                      ,
                      () =>
                      {
                          //For All Gray Elephant Objects.
                          Object O = new Object();
                          lock (O)
                          {
                              this.InitiateAStarGreedythElephantBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                          }
                      }
                      , () =>
                      {
                          //For All Gray Hourse Objects.
                          Object O = new Object();
                          lock (O)
                          {
                              this.InitiateAStarGreedythHourseBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                          }
                      }
                      ,
                      () =>
                      {
                          Object O = new Object();
                          lock (O)
                          {
                              this.InitiateAStarGreedythCastleBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                          }
                      }
                      , () =>
                      {

                          Object O = new Object();
                          lock (O)
                          {
                              this.InitiateAStarGreedythMinisterBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                          }

                      }
                      , () =>
                      {
                          Object O = new Object();
                          lock (O)
                          {
                              this.InitiateAStarGreedythKingBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                          }
                      })
                     );
                    output.Wait();
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("AstarGreedyThinking:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        public bool InitiateAStarGreedytCreationThinking(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object o = new Object();
            lock (o)
            {
                int DummyOrder = new int();
                DummyOrder = Order;
                int DummyCurrentOrder = new int();
                DummyCurrentOrder = ChessRules.CurrentOrder;
#pragma warning disable CS0219 // The variable 'ik' is assigned but its value is never used
                int i = 0, ik = 0;
#pragma warning restore CS0219 // The variable 'ik' is assigned but its value is never used
                var j = 0;

                int[,] Table = new int[8, 8];
                for (var iii = 0; iii < 8; iii++)
                    for (var jjj = 0; jjj < 8; jjj++)
                        Table[iii, jjj] = Tab[iii, jjj];

                //If Order is Gray.
                if (Order== 1)
                {
                    int i1 = i, j1 = j;
                    int[,] Tabl = CloneATable(Table);
                    int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                    bool TB1 = TB;
                    Color aa = a;


                    var output = Task.Factory.StartNew(() =>
                    Parallel.Invoke(() =>
                    {
                        //For All Gray Soldier Objects.
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedytSodlerGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    }
                    ,
                    () =>
                    {
                        //For All Gray Elephant Objects.
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedytElephantGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    }
                    , () =>
                    {
                        //For All Gray Hourse Objects.
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedythHourseGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    }
                    ,
                    () =>
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedythCastleGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    }
                    , () =>
                    {

                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedythMinisterGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }

                    }
                    , () =>
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedythKingGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    })
                    );
                    output.Wait();
                }
                else//Brown Order Considarations.
                {
                    int i1 = i, j1 = j;
                    int[,] Tabl = CloneATable(Table);
                    int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                    bool TB1 = TB;
                    Color aa = a;
                    //If Order is Gray.


                    var output = Task.Factory.StartNew(() =>
                    Parallel.Invoke(() =>
                    {
                        //For All Gray Soldier Objects.
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedythSoldierBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    }
                    ,
                    () =>
                    {
                        //For All Gray Elephant Objects.
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedythElephantBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    }
                    , () =>
                    {
                        //For All Gray Hourse Objects.
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedythHourseBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    }
                    ,
                    () =>
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedythCastleBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    }
                    , () =>
                    {

                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedythMinisterBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }

                    }
                    , () =>
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            this.InitiateAStarGreedythKingBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tabl, Ord1, TB1, FOUND, LeafAStarGreedy);
                        }
                    })
                );
                    output.Wait();

                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedytCreationThinking:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return true;
        }

        public AllDraw InitiateAStarGreedyt(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            OrderP = Order;
                SetObjectNumbers(Tab);

                int[,] Table = new int[8, 8];
                for (var iii = 0; iii < 8; iii++)
                    for (var jjj = 0; jjj < 8; jjj++)
                        Table[iii, jjj] = Tab[iii, jjj];

                Object oo = new Object();
                lock (oo)
                {
                    ThinkingChess.BeginThread = 0;
                    ThinkingChess.EndThread = 0;
                }
                //Initiate of global Variables Byte Local Variables.
                int DummyOrder = new int();
                DummyOrder = Order;
                int DummyCurrentOrder = new int();
                DummyCurrentOrder = ChessRules.CurrentOrder;
#pragma warning disable CS0219 // The variable 'i' is assigned but its value is never used
                int i = 0, ik = 0;
#pragma warning restore CS0219 // The variable 'i' is assigned but its value is never used
                int[,] TablInit = new int[8, 8];
                if (Order== 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                var j = 0;
              
                //Fairness conditions for perposive astar greedy search.
                Object Omm = new Object();
            lock (Omm)
            {
                Object OOOO = new Object();
                lock (OOOO)
                {

                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return null;

                }
                CurrentAStarGredyMax = AStarGreedyiLevelMax - iAStarGreedy;
                iAStarGreedy--;
            }
                bool Do = false;
            if (iAStarGreedy >= 0 && iAStarGreedy < MaxDuringLevelThinkingCreation)
            {
                MaxDuringLevelThinkingCreation = iAStarGreedy;
                Object O = new Object();
                DepthIterative++;
                lock (O)
                {
                    OutPut.Append("\r\nMinimum Level During Thinking Tree Creation is " + MaxDuringLevelThinkingCreation.ToString() + "at Iterative " + DepthIterative.ToString());
                }
            }

                


                if (!FOUND)
                {
                    //Initiate Of Local Variables.
                    Object o = new Object();
                    lock (o)
                    {


                        InitiateAStarGreedytCreationThinking(iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);

                    }

                    /*

                    if (!FOUND)
                    {
                        //Initiate Of Local Variables.


                        Object o = new Object();
                        lock (o)
                        {

                            //If Order is Gray.
                            if (Order== 1)
                            {
                                int i1 = i, j1 = j;
                                int[,] Tabl = CloneATable(Table);
                                int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                                bool TB1 = TB;
                                Color aa = a;


                                //Parallel.Invoke(() =>
                                {
                                    //For All Gray Soldier Objects.
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        this.InitiateAStarGreedytSodlerGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                    }
                                }
                                //,
                               // () =>
                                {
                                    //For All Gray Elephant Objects.
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        this.InitiateAStarGreedytElephantGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                    }
                                }
                                //, () =>
                                {
                                    //For All Gray Hourse Objects.
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        this.InitiateAStarGreedythHourseGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                    }
                                }
                               // ,
                               // () =>
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        this.InitiateAStarGreedythCastleGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                    }
                                }
                               // , () =>
                                {

                                    Object O = new Object();
                                    lock (O)
                                    {
                                        this.InitiateAStarGreedythMinisterGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                    }

                                }
                                //, () =>
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        this.InitiateAStarGreedythKingGray(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                    }
                                }
                               // );
                            }
                            else//Brown Order Considarations.
                            {
                                int i1 = i, j1 = j;
                                int[,] Tabl = CloneATable(Table);
                                int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                                bool TB1 = TB;
                                Color aa = a;
                                //If Order is Gray.


                                //Parallel.Invoke(() =>
                                {
                                    //For All Gray Soldier Objects.
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        this.InitiateAStarGreedythSoldierBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                    }
                                }
                               // ,
                               // () =>
                                {
                                    //For All Gray Elephant Objects.
                                    Object O = new Object();
                                   lock (O)
                                    {
                                        this.InitiateAStarGreedythElephantBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                    }
                                }
                                //, () =>
                                {
                                    //For All Gray Hourse Objects.
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        this.InitiateAStarGreedythHourseBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                    }
                                }
                               // ,
                                //() =>
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        this.InitiateAStarGreedythCastleBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                    }
                                }
                                //, () =>
                                {

                                    Object O = new Object();
                                    lock (O)
                                    {
                                        this.InitiateAStarGreedythMinisterBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                    }

                                }
                                //, () =>
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        this.InitiateAStarGreedythKingBrown(i1, j1, Tabl, DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, Tab, Ord1, TB1, FOUND, LeafAStarGreedy);
                                    }
                                }
                               // );
                            }
                        }
                    }
                    */

                }
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;

                    Serve(Order);

                    if (FOUND)
                    {
                        Object O = new Object();
                        lock (O)
                        {
                            Tabl = CloneATable(Table);
                            FoundOfLeafDepenOfKindFullGame(Tabl, Order, iAStarGreedy, ii, jj, ik, j, FOUND, LeafAStarGreedy);
                            /*tFoundOfLeafDepenOfKindFullGame = new Task(new Action(() => FoundOfLeafDepenOfKindFullGame(Tabl, Order, iAStarGreedy, ii, jj, ik, j, FOUND, LeafAStarGreedy)));
                            tFoundOfLeafDepenOfKindFullGame.Start();
                            T.Add(tFoundOfLeafDepenOfKindFullGame);*/
                        }
                    }
                    else
                    {
                        Object O = new Object();
                    lock (O)
                    {
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        int Ord = Order, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, ik1 = ik, j1 = j;
                        //System.Threading.Thread.Sleep(2);
                        //Parallel.Invoke(() =>
                        {
                            Do = this.FullGameThinkingTree(Ord, iAStarGreedy1, ii1, jj1, ik1, j1, false, LeafAStarGreedy);
                            /*tFullGameThinkingTree = new Task(new Action(() => Do = this.FullGameThinkingTree(Ord, iAStarGreedy1, ii1, jj1, ik1, j1, false, LeafAStarGreedy)));
                            tFullGameThinkingTree.Start();
                            T.Add(tFullGameThinkingTree);*/


                        }//);
                    }


                        Object Om = new Object();
                        lock (Om)
                        {
                            if (!Do)
                                if (iAStarGreedy < MinThinkingTreeDepth)
                                    MinThinkingTreeDepth = iAStarGreedy;
                        }

                    }

            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedyt:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            //Parallel.ForEach(T, items => Task.WaitAny(items));
            return this;
           
        }
        public AllDraw InitiateAStarGreedytObject(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            {

                OrderP = Order;
                SetObjectNumbers(Tab);

                int[,] Table = new int[8, 8];
                for (var iii = 0; iii < 8; iii++)
                    for (var jjj = 0; jjj < 8; jjj++)
                        Table[iii, jjj] = Tab[iii, jjj];
                Object oo = new Object();
                lock (oo)
                {
                    ThinkingChess.BeginThread = 0;
                    ThinkingChess.EndThread = 0;
                }
                //Initiate of global Variables Byte Local Variables.
                int DummyOrder = new int();
                DummyOrder = Order;
                int DummyCurrentOrder = new int();
                DummyCurrentOrder = ChessRules.CurrentOrder;
                List<Task> ThB = new List<Task>();

                int i = 0, ik = 0;
                int[,] TablInit = new int[8, 8];
                if (Order== 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                var j = 0;
                //if (iAStarGreedy>=0)
                //return null;
                Object OOOO = new Object();
                lock (OOOO)
                {
                    //if (iAStarGreedy < 0)
                    {
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return null;


                    }

                }

                CurrentAStarGredyMax = AStarGreedyiLevelMax - iAStarGreedy;
                iAStarGreedy--;

                if (iAStarGreedy >= 0 && iAStarGreedy < MaxDuringLevelThinkingCreation)
                {
                    MaxDuringLevelThinkingCreation = iAStarGreedy;
                    Object O = new Object();
                    DepthIterative++;
                    lock (O)
                    {
                        OutPut.Append("\r\nMinimum Level During Thinking Tree Creation is " + MaxDuringLevelThinkingCreation.ToString() + "at Iterative " + DepthIterative.ToString());
                    }
                    //THIS.RefreshBoxText();

                }




                if (!FOUND)
                {
                    Object o = new Object();
                    lock (o)
                    {
                        if (Order== 1)
                            this.InitiateAStarGreedytObjectGray(i, j, CloneATable(Table), DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        else
                            this.InitiateAStarGreedytObjectBrown(i, j, CloneATable(Table), DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                    }
                }

                if (FOUND)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        Tabl = CloneATable(Table);
                        FoundOfLeafDepenOfKindFullGame(Tabl, Order, iAStarGreedy, ii, jj, ik, j, FOUND, LeafAStarGreedy);
                    }
                }
                else
                {
                    Object O = new Object();
                    lock (O)
                    {
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        int Ord = Order, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, ik1 = ik, j1 = j;
                        //int Ord = Order, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, ik1 = ik, j1 = j;
                        //System.Threading.Thread.Sleep(2);
                        //Parallel.Invoke(() =>
                        {
                            Do |= this.FullGameThinkingTree(Ord, iAStarGreedy1, ii1, jj1, ik1, j1, false, LeafAStarGreedy);
                        }//);
                    }

                }
                Object Om = new Object();
                lock (Om)
                {
                    if (!Do)
                        if (iAStarGreedy < MinThinkingTreeDepth)
                            MinThinkingTreeDepth = iAStarGreedy;
                }
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("InitiateAStarGreedytObject:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return this;
            }
        }
        bool KingDan(int[,] Tab, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool IsDang = false;
            RefrigtzDLL.ChessRules A = new RefrigtzDLL.ChessRules(0, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Order);
            IsDang = A.ObjectDangourKingMove(Order, Tab);
            if (Order == 1 && (IsDang))
            {
                if (A.CheckBrownObjectDangour && ((!A.CheckGrayObjectDangour)))
                    IsDang = false;
            }
            if (Order == -1 && (IsDang))
            {
                if (A.CheckGrayObjectDangour && ((!A.CheckBrownObjectDangour)))
                    IsDang = false;
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("KingDan:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return IsDang;

        }
        void ClearAStarGreadyWhenListsAreEmpy(int Kind, int i)
        {
            if (Kind == 1 && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > 0)
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Clear();
            else
if (Kind == 2 && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > 0)
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Clear();
            else
                if (Kind == 3 && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > 0)
                HoursesOnTable[i].HourseThinking[0].AStarGreedy.Clear();
            else
                if (Kind == 4 && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > 0)
                CastlesOnTable[i].CastleThinking[0].AStarGreedy.Clear();
            else
                if (Kind == 5 && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > 0)
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Clear();

            else
                if (Kind == 6 && KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count > 0)
                KingOnTable[i].KingThinking[0].AStarGreedy.Clear();

        }
        bool IsThereCalculatedAStarGreedyNode()
        {
            bool Is = false;
            for (int i = 0; i < SodierHigh; i++)
            {
                if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null)
                {
                    if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                    {
                        Is = true;
                        break;
                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(1, i);
                    /*else {
                        Object O = new Object();
                        lock (O)
                        {
                            Tabl = CloneATable(Tabl);
                            FoundOfLeafDepenOfKindFullGame(Tabl, OrderP, 0, i, j, -1, -1, true, true);
                            
                        }
                    }*/
                }
            }
            if (!Is)
            {
                for (int i = 0; i < ElefantHigh; i++)
                {
                    if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null)
                    {
                        if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(2, i);
                        /*else
                          {
                              Object O = new Object();
                              lock (O)
                              {
                                  Tabl = CloneATable(Tabl);
                                  FoundOfLeafDepenOfKindFullGame(Tabl, OrderP, 0, i, j, -1, -1, true, true);

                              }
                          }*/
                    }
                }
            }
            if (!Is)
            {
                for (int i = 0; i < HourseHight; i++)
                {
                    if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null)
                    {
                        if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(3, i);

                        /*else
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                Tabl = CloneATable(Tabl);
                                FoundOfLeafDepenOfKindFullGame(Tabl, OrderP, 0, i, j, -1, -1, true, true);
                             }
                        }*/
                    }
                }
            }
            if (!Is)
            {
                for (int i = 0; i < CastleHigh; i++)
                {
                    if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null)
                    {
                        if (CastlesOnTable[i].CastleThinking[0].TableListHourse.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(4, i);

                        /* else
                         {
                             Object O = new Object();
                             lock (O)
                             {
                                 Tabl = CloneATable(Tabl);
                                 FoundOfLeafDepenOfKindFullGame(Tabl, OrderP, 0, i, j, -1, -1, true, true);
                               }
                         }*/
                    }
                }
            }
            if (!Is)
            {
                for (int i = 0; i < MinisterHigh; i++)
                {
                    if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null)
                    {
                        if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(5, i);

                        /* else
                         {
                             Object O = new Object();
                             lock (O)
                             {
                                 Tabl = CloneATable(Tabl);
                                 FoundOfLeafDepenOfKindFullGame(Tabl, OrderP, 0, i, j, -1, -1, true, true);
                                }
                         }*/
                    }
                }
            }
            if (!Is)
            {
                for (int i = 0; i < KingHigh; i++)
                {
                    if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null)
                    {
                        if (KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(6, i);

                        /* else
                         {
                             Object O = new Object();
                             lock (O)
                             {
                                 Tabl = CloneATable(Tabl);
                                 FoundOfLeafDepenOfKindFullGame(Tabl, OrderP, 0, i, j, -1, -1, true, true);
                              }
                         }*/
                    }
                }
            }
            return Is;
        }
        bool IsThereNotAllOfEmptyOrNonCalculatedAStarGreedyNode(int Order, int Kind, int i)
        {
            bool Is = true;
            if (Kind == 1)
            {
                if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null&&SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; j++)
                        Is = Is && SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            else
                if (Kind == 2)
            {
                if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null&&ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; j++)
                        Is = Is && ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            else
                if (Kind == 3)
            {
                if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null&& HoursesOnTable[i].HourseThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; j++)
                        Is = Is && HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();

                }
            }
            else
                if (Kind == 4)
            {
                if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null&& CastlesOnTable[i].CastleThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; j++)
                        Is = Is && CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            else
                if (Kind == 5)
            {
                if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null&& MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null) {
                    for (int j = 0; j < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; j++)
                        Is = Is && MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            else
            if (Kind == 6)
            {
                if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null&& KingOnTable[i].KingThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < KingOnTable[i].KingThinking[0].AStarGreedy.Count; j++)
                        Is = Is && KingOnTable[i].KingThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            return Is;
        }
        bool IsThereEmptyOrNonCalculatedAStarGreedyNode(int Order, int Kind, int i, int j)
        {
            bool Is = false;
            if (!IsThereNotAllOfEmptyOrNonCalculatedAStarGreedyNode(Order, Kind, i))
            {
                if (Kind == 1)
                {
                    if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j)
                        Is = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
                else
                    if (Kind == 2)
                {
                    if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j)
                        Is = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
                else
                    if (Kind == 3)
                {
                    if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j)
                        Is = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();

                }
                else
                    if (Kind == 4)
                {
                    if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j)
                        Is = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();

                }
                else
                    if (Kind == 5)
                {
                    if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j)
                        Is = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();

                }
                else
                if (Kind == 6)
                {
                    if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count > j)
                        Is = KingOnTable[i].KingThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();

                }
            }
            return (!Is);
        }
        void BlitzGameThinkingTreeSolderGray(ref int PreviousLessS, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Soldeir
            for (ik = 0; ik < SodierMidle; ik++)
            {
                if (SolderesOnTable == null || SolderesOnTable[ik] == null || SolderesOnTable[ik].SoldierThinking == null || SolderesOnTable[ik].SoldierThinking[0] == null || SolderesOnTable[ik].SoldierThinking[0].HuristicListSolder == null
                    )
                    continue;
                for (j = 0; j < SolderesOnTable[ik].SoldierThinking[0].HuristicListSolder.Count; j++)
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].IsSupHu[j]
                      )
                        continue;

                    Object O = new Object();
                    lock (O)
                    {
                        if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 1, ik, j))
                            continue;
                        if (CheckeHuristci(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j], Order, ik, j, 0))
                            continue;

                        if (AllDraw.OrderPlate == Order)
                        {
                            if (SolderesOnTable[ik].SoldierThinking[0].ReturnHuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessS || (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {

                            }

                            else
                            {
                                PreviousLessS = SolderesOnTable[ik].SoldierThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                                Index[0] = ik;
                                jIndex[0] = j;
                            }
                        }
                        else
                        {
                            if (SolderesOnTable[ik].SoldierThinking[0].ReturnHuristic(-1, j, Order, false, ref HaveKilled) > PreviousLessS || (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {

                            }

                            else
                            {
                                PreviousLessS = SolderesOnTable[ik].SoldierThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                                Index[0] = ik;
                                jIndex[0] = j;
                            }
                        }

                    }
                }

                //Elephant
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameThinkingTreeSolderGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzGameThinkingTreeElephantGray(ref int PreviousLessE, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Elephant
            for (ik = 0; ik < ElefantMidle; ik++)
            {
                if (ElephantOnTable == null || ElephantOnTable[ik] == null || ElephantOnTable[ik].ElefantThinking == null || ElephantOnTable[ik].ElefantThinking[0] == null || ElephantOnTable[ik].ElefantThinking[0].HuristicListElefant == null
                    )
                    continue;
                for (j = 0; j < ElephantOnTable[ik].ElefantThinking[0].HuristicListElefant.Count; j++)
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].IsSupHu[j]
               )
                        continue;
                    Object O = new Object();
                    lock (O)
                    {
                        if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 2, ik, j))
                            continue;

                        if (CheckeHuristci(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j], Order, ik, j, 0))
                            continue;


                        if (AllDraw.OrderPlate == Order)
                        {
                            if (ElephantOnTable[ik].ElefantThinking[0].ReturnHuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessE || (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                                //ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = null;
                                //ElephantOnTable[ik] = null;
                                //continue;
                            }

                            else
                            {
                                PreviousLessE = ElephantOnTable[ik].ElefantThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                                Index[1] = ik;
                                jIndex[1] = j;
                            }
                        }
                        else
                        {
                            if (ElephantOnTable[ik].ElefantThinking[0].ReturnHuristic(-1, j, Order, false, ref HaveKilled) > PreviousLessE || (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                                //ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = null;
                                //ElephantOnTable[ik] = null;
                                //continue;
                            }

                            else
                            {
                                PreviousLessE = ElephantOnTable[ik].ElefantThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                                Index[1] = ik;
                                jIndex[1] = j;
                            }
                        }

                    }
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameThinkingTreeElephantGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzGameThinkingTreeHourseGray(ref int PreviousLessH, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Hourse.
            for (ik = 0; ik < HourseMidle; ik++)
            {
                if (HoursesOnTable == null || HoursesOnTable[ik] == null || HoursesOnTable[ik].HourseThinking == null || HoursesOnTable[ik].HourseThinking[0] == null || HoursesOnTable[ik].HourseThinking[0].HuristicListHourse == null
                    )
                    continue;
                for (j = 0; j < HoursesOnTable[ik].HourseThinking[0].HuristicListHourse.Count; j++)
                {
                    if (HoursesOnTable[ik].HourseThinking[0].IsSupHu[j]
                  )
                        continue;
                    Object O = new Object();
                    lock (O)
                    {
                        if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order,3, ik, j))
                            continue;

                        if (CheckeHuristci(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j], Order, ik, j, 0))
                            continue;

                        if (AllDraw.OrderPlate == Order)
                        {
                            if (HoursesOnTable[ik].HourseThinking[0].ReturnHuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessH || (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                                //HoursesOnTable[ik].HourseThinking[0].AStarGreedy = null;
                                //continue;
                            }

                            else
                            {
                                PreviousLessH = HoursesOnTable[ik].HourseThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                                Index[2] = ik;
                                jIndex[2] = j;
                            }
                        }
                        else
                        {

                            if (HoursesOnTable[ik].HourseThinking[0].ReturnHuristic(-1, j, Order, false, ref HaveKilled) > PreviousLessH || (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                                //HoursesOnTable[ik].HourseThinking[0].AStarGreedy = null;
                                //continue;
                            }

                            else
                            {
                                PreviousLessH = HoursesOnTable[ik].HourseThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                                Index[2] = ik;
                                jIndex[2] = j;
                            }
                        }

                    }
                }

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameThinkingTreeHourseGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzGameThinkingTreeCastleGray(ref int PreviousLessB, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Castle.
            for (ik = 0; ik < CastleMidle; ik++)
            {
                if (CastlesOnTable == null || CastlesOnTable[ik] == null || CastlesOnTable[ik].CastleThinking == null || CastlesOnTable[ik].CastleThinking[0] == null || CastlesOnTable[ik].CastleThinking[0].HuristicListCastle == null
                    )
                    continue;
                for (j = 0; j < CastlesOnTable[ik].CastleThinking[0].HuristicListCastle.Count; j++)
                {
                    if (CastlesOnTable[ik].CastleThinking[0].IsSupHu[j]
                 )
                        continue;
                    Object O = new Object();
                    lock (O)
                    {
                        if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 4, ik, j))
                            continue;

                        if (CheckeHuristci(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j], Order, ik, j, 0))
                            continue;

                        if (AllDraw.OrderPlate == Order)
                        {
                            if (CastlesOnTable[ik].CastleThinking[0].ReturnHuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessB || (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {

                                //CastlesOnTable[ik].CastleThinking[0].AStarGreedy = null;
                                //CastlesOnTable[ik] = null;
                                //continue;
                            }

                            else
                            {
                                PreviousLessB = CastlesOnTable[ik].CastleThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                                Index[3] = ik;
                                jIndex[3] = j;
                            }
                        }
                        else
                        {
                            if (CastlesOnTable[ik].CastleThinking[0].ReturnHuristic(-1, j, Order, false, ref HaveKilled) > PreviousLessB || (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {

                                //CastlesOnTable[ik].CastleThinking[0].AStarGreedy = null;
                                //CastlesOnTable[ik] = null;
                                //continue;
                            }

                            else
                            {
                                PreviousLessB = CastlesOnTable[ik].CastleThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                                Index[3] = ik;
                                jIndex[3] = j;
                            }
                        }
                    }
                }

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameThinkingTreeCastleGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzGameThinkingTreeMinisterGray(ref int PreviousLessM, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Minister.
            for (ik = 0; ik < MinisterMidle; ik++)
            {
                if (MinisterOnTable == null || MinisterOnTable[ik] == null || MinisterOnTable[ik].MinisterThinking == null || MinisterOnTable[ik].MinisterThinking[0] == null || MinisterOnTable[ik].MinisterThinking[0].HuristicListMinister == null
                    )
                    continue;
                for (j = 0; j < MinisterOnTable[ik].MinisterThinking[0].HuristicListMinister.Count; j++)
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].IsSupHu[j]
                      )
                        continue;

                    if (CheckeHuristci(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order, ik, j, 0))
                        continue;


                    Object O = new Object();
                    lock (O)
                    {
                        if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 5, ik, j))
                            continue;

                        if (AllDraw.OrderPlate == Order)
                        {
                            if (MinisterOnTable[ik].MinisterThinking[0].ReturnHuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessM || (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                                //MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = null;
                                // MinisterOnTable[ik] = null;

                                // continue;
                            }

                            else
                            {
                                Index[4] = ik;
                                jIndex[4] = j;
                                PreviousLessM = MinisterOnTable[ik].MinisterThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                            }
                        }
                        else
                        {
                            if (MinisterOnTable[ik].MinisterThinking[0].ReturnHuristic(-1, j, Order, false, ref HaveKilled) > PreviousLessM || (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                                //MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = null;
                                // MinisterOnTable[ik] = null;

                                // continue;
                            }

                            else
                            {
                                Index[4] = ik;
                                jIndex[4] = j;
                                PreviousLessM = MinisterOnTable[ik].MinisterThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                            }
                        }

                    }
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameThinkingTreeMinisterGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzGameThinkingTreeKingGray(ref int PreviousLessK, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //King.
            for (ik = 0; ik < KingMidle; ik++)
            {
                if (KingOnTable == null || KingOnTable[ik] == null || KingOnTable[ik].KingThinking == null || KingOnTable[ik].KingThinking[0] == null || KingOnTable[ik].KingThinking[0].HuristicListKing == null
                    )
                    continue;
                for (j = 0; j < KingOnTable[ik].KingThinking[0].HuristicListKing.Count; j++)
                {
                    if (KingOnTable[ik].KingThinking[0].IsSupHu[j]
                      )
                        continue;

                    Object O = new Object();
                    lock (O)
                    {
                        if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 6, ik, j))
                            continue;

                        if (CheckeHuristci(KingOnTable[ik].KingThinking[0].TableListKing[j], Order, ik, j, 0))
                            continue;

                        if (AllDraw.OrderPlate == Order)
                        {
                            if (KingOnTable[ik].KingThinking[0].ReturnHuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessK || (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                                //KingOnTable[ik].KingThinking[0].AStarGreedy = null;
                                //KingOnTable[ik] = null;
                                //continue;
                            }

                            else
                            {
                                Index[5] = ik;
                                jIndex[5] = j;
                                PreviousLessK = KingOnTable[ik].KingThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                            }
                        }
                        else
                        {
                            if (KingOnTable[ik].KingThinking[0].ReturnHuristic(-1, j, Order, false, ref HaveKilled) > PreviousLessK || (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                                //KingOnTable[ik].KingThinking[0].AStarGreedy = null;
                                //KingOnTable[ik] = null;
                                //continue;
                            }

                            else
                            {
                                Index[5] = ik;
                                jIndex[5] = j;
                                PreviousLessK = KingOnTable[ik].KingThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                            }
                        }

                    }
                }

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameThinkingTreeKingGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzGameTreeCreationThinkingTreeSolder(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {

                if (Index[0] != -1)
                {
                    if (SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count == 0)
                        SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                    SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Add(SolderesOnTable[Index[0]].SoldierThinking[0].TableListSolder[jIndex[0]]);
                    SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, SolderesOnTable[Index[0]].SoldierThinking[0].RowColumnSoldier[jIndex[0]][0], SolderesOnTable[Index[0]].SoldierThinking[0].RowColumnSoldier[jIndex[0]][1], a, SolderesOnTable[Index[0]].SoldierThinking[0].TableListSolder[jIndex[0]], Order, false, FOUND, LeafAStarGreedy);
                    //ParameterizedThreadStart start = new ParameterizedThreadStart(SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                    //var array = Task.Factory.StartNew(() => SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, SolderesOnTable[Index[0]].SoldierThinking[0].RowColumnSoldier[jIndex[0]][0], SolderesOnTable[Index[0]].SoldierThinking[0].RowColumnSoldier[jIndex[0]][1], a, SolderesOnTable[Index[0]].SoldierThinking[0].TableListSolder[jIndex[0]], Order, false, FOUND, LeafAStarGreedy));
                    //Object ttttt = new Object(); lock (ttttt) { tHA.Add(array); }
                    //array.Wait();
                    //array.Name = "S" + i.ToString();
                    //array.Start();

                }
            }
            //Parallel.ForEach(tHA, items => Task.WaitAny(items));

            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameTreeCreationThinkingTreeSolder:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzGameTreeCreationThinkingTreeElephant(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {
                if (Index[1] != -1)
                {
                    if (ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count == 0)
                        ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                    ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Add(ElephantOnTable[Index[1]].ElefantThinking[0].TableListElefant[jIndex[1]]);
                    ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ElephantOnTable[Index[1]].ElefantThinking[0].RowColumnElefant[jIndex[1]][0], ElephantOnTable[Index[1]].ElefantThinking[0].RowColumnElefant[jIndex[1]][1], a, ElephantOnTable[Index[1]].ElefantThinking[0].TableListElefant[jIndex[1]], Order, false, FOUND, LeafAStarGreedy);
                    //ParameterizedThreadStart start = new ParameterizedThreadStart(ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                    //var array = Task.Factory.StartNew(() => ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ElephantOnTable[Index[1]].ElefantThinking[0].RowColumnElefant[jIndex[1]][0], ElephantOnTable[Index[1]].ElefantThinking[0].RowColumnElefant[jIndex[1]][1], a, ElephantOnTable[Index[1]].ElefantThinking[0].TableListElefant[jIndex[1]], Order, false, FOUND, LeafAStarGreedy));
                    // Object ttttt = new Object(); lock (ttttt) { tHA.Add(array); }
                    //array.Name = "E" + i.ToString();
                    //array.Start();
                    //array.Wait();

                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameTreeCreationThinkingTreeElephant:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            //Parallel.ForEach(tHA, items => Task.WaitAny(items));
        }
        void BlitzGameTreeCreationThinkingTreeHourse(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {
                if (Index[2] != -1)
                {
                    if (HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count == 0)
                        HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                    HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].TableList.Add(HoursesOnTable[Index[2]].HourseThinking[0].TableListHourse[jIndex[2]]);
                    HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, HoursesOnTable[Index[2]].HourseThinking[0].RowColumnHourse[jIndex[2]][0], HoursesOnTable[Index[2]].HourseThinking[0].RowColumnHourse[jIndex[2]][1], a, HoursesOnTable[Index[2]].HourseThinking[0].TableListHourse[jIndex[2]], Order, false, FOUND, LeafAStarGreedy);
                    //ParameterizedThreadStart start = new ParameterizedThreadStart(HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                    //Object ttttt = new Object(); lock (ttttt) { tHA.Add(array); }
                    //array.Name = "H" + i.ToString();
                    //array.Start();
                    //array.Wait();

                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameTreeCreationThinkingTreeHourse:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            //Parallel.ForEach(tHA, items => Task.WaitAny(items));
        }
        void BlitzGameTreeCreationThinkingTreeCastle(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {
                if (Index[3] != -1)
                {
                    if (CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count == 0)
                        CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                    CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].TableList.Add(CastlesOnTable[Index[3]].CastleThinking[0].TableListCastle[jIndex[3]]);
                    CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, CastlesOnTable[Index[3]].CastleThinking[0].RowColumnCastle[jIndex[3]][0], CastlesOnTable[Index[3]].CastleThinking[0].RowColumnCastle[jIndex[3]][1], a, CastlesOnTable[Index[3]].CastleThinking[0].TableListCastle[jIndex[3]], Order, false, FOUND, LeafAStarGreedy);
                    //ParameterizedThreadStart start = new ParameterizedThreadStart(CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                    //var array = Task.Factory.StartNew(() => CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, CastlesOnTable[Index[3]].CastleThinking[0].RowColumnCastle[jIndex[3]][0], CastlesOnTable[Index[3]].CastleThinking[0].RowColumnCastle[jIndex[3]][1], a, CastlesOnTable[Index[3]].CastleThinking[0].TableListCastle[jIndex[3]], Order, false, FOUND, LeafAStarGreedy));
                    //array.Wait();
                    //Object ttttt = new Object(); lock (ttttt) { tHA.Add(array); }
                    //array.Name = "B" + i.ToString();
                    //array.Start();

                }
                //Parallel.ForEach(tHA, items => Task.WaitAny(items));
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameTreeCreationThinkingTreeCastle:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzGameTreeCreationThinkingTreeMinister(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {
                if (Index[4] != -1)
                {
                    if (MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count == 0)
                        MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                    MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(MinisterOnTable[Index[4]].MinisterThinking[0].TableListMinister[jIndex[4]]);
                    MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, MinisterOnTable[Index[4]].MinisterThinking[0].RowColumnMinister[jIndex[4]][0], MinisterOnTable[Index[4]].MinisterThinking[0].RowColumnMinister[jIndex[4]][1], a, MinisterOnTable[Index[4]].MinisterThinking[0].TableListMinister[jIndex[4]], Order, false, FOUND, LeafAStarGreedy);
                    //ParameterizedThreadStart start = new ParameterizedThreadStart(MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                    //var array = Task.Factory.StartNew(() => MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, MinisterOnTable[Index[4]].MinisterThinking[0].RowColumnMinister[jIndex[4]][0], MinisterOnTable[Index[4]].MinisterThinking[0].RowColumnMinister[jIndex[4]][1], a, MinisterOnTable[Index[4]].MinisterThinking[0].TableListMinister[jIndex[4]], Order, false, FOUND, LeafAStarGreedy));
                    //Object ttttt = new Object(); lock (ttttt) { tHA.Add(array); }
                    //array.Name = "M" + i.ToString();
                    //array.Start();
                    //array.Wait();

                }
                //Parallel.ForEach(tHA, items => Task.WaitAny(items));
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameTreeCreationThinkingTreeMinister:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzGameTreeCreationThinkingTreeKing(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {
                if (Index[5] != -1)
                {
                    if (KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count == 0)
                        KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                    KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].TableList.Add(KingOnTable[Index[5]].KingThinking[0].TableListKing[jIndex[5]]);
                    KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, KingOnTable[Index[5]].KingThinking[0].RowColumnKing[jIndex[5]][0], KingOnTable[Index[5]].KingThinking[0].RowColumnKing[jIndex[5]][1], a, KingOnTable[Index[5]].KingThinking[0].TableListKing[jIndex[5]], Order, false, FOUND, LeafAStarGreedy);
                    //ParameterizedThreadStart start = new ParameterizedThreadStart(KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                    //var array = Task.Factory.StartNew(() => KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, KingOnTable[Index[5]].KingThinking[0].RowColumnKing[jIndex[5]][0], KingOnTable[Index[5]].KingThinking[0].RowColumnKing[jIndex[5]][1], a, KingOnTable[Index[5]].KingThinking[0].TableListKing[jIndex[5]], Order, false, FOUND, LeafAStarGreedy));
                    //Object ttttt = new Object(); lock (ttttt) { tHA.Add(array); }
                    //array.Name = "K" + i.ToString();
                    //array.Start();
                    //array.Wait();

                }
                //Parallel.ForEach(tHA, items => Task.WaitAny(items));
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameTreeCreationThinkingTreeKing:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzGameThinkingTreeSolderBrown(ref int PreviousLessS, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            for (ik = SodierMidle; ik < SodierHigh; ik++)
            {
                if (SolderesOnTable == null || SolderesOnTable[ik] == null || SolderesOnTable[ik].SoldierThinking == null || SolderesOnTable[ik].SoldierThinking[0] == null || SolderesOnTable[ik].SoldierThinking[0].HuristicListSolder == null
                    )
                    continue;
                //Soldier.
                for (j = 0; j < SolderesOnTable[ik].SoldierThinking[0].HuristicListSolder.Count; j++)
                {
                    if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 1, ik, j))
                        continue;

                    if (SolderesOnTable[ik].SoldierThinking[0].IsSupHu[j]
                   )
                        continue;

                    if (CheckeHuristci(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j], Order, ik, j, 0))
                        continue;


                    if (AllDraw.OrderPlate == Order)
                    {
                        if (SolderesOnTable[ik].SoldierThinking[0].ReturnHuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessS || (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                            //SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = null;
                            //SolderesOnTable[ik] = null;
                            //continue;
                        }

                        else
                        {
                            Index[0] = ik;
                            jIndex[0] = j;
                            PreviousLessS = SolderesOnTable[ik].SoldierThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                        }
                    }
                    else
                    {
                        if (SolderesOnTable[ik].SoldierThinking[0].ReturnHuristic(-1, j, Order, false, ref HaveKilled) > PreviousLessS || (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                            //SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = null;
                            //SolderesOnTable[ik] = null;
                            //continue;
                        }

                        else
                        {
                            Index[0] = ik;
                            jIndex[0] = j;
                            PreviousLessS = SolderesOnTable[ik].SoldierThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                        }
                    }
                }

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameThinkingTreeSolderBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzGameThinkingTreeElephantBrown(ref int PreviousLessE, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Elephant
            for (ik = ElefantMidle; ik < ElefantHigh; ik++)
            {
                if (ElephantOnTable == null || ElephantOnTable[ik] == null || ElephantOnTable[ik].ElefantThinking == null || ElephantOnTable[ik].ElefantThinking[0] == null || ElephantOnTable[ik].ElefantThinking[0] .HuristicListElefant== null
                    )
                    continue;
                for (j = 0; j < ElephantOnTable[ik].ElefantThinking[0].HuristicListElefant.Count; j++)
                {
                    if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 2, ik, j))
                        continue;

                    if (ElephantOnTable[ik].ElefantThinking[0].IsSupHu[j]
                 )
                        continue;
                
                    if (CheckeHuristci(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j], Order, ik, j, 0))
                        continue;

                    if (AllDraw.OrderPlate == Order)
                    {
                        if (ElephantOnTable[ik].ElefantThinking[0].ReturnHuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessE || (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))

                        {
                            //ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = null;
                            //ElephantOnTable[ik] = null;
                            //continue;
                        }

                        else
                        {
                            Index[1] = ik;
                            jIndex[1] = j;
                            PreviousLessE = ElephantOnTable[ik].ElefantThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                        }
                    }
                    else
                    {
                        if (ElephantOnTable[ik].ElefantThinking[0].ReturnHuristic(-1, j, Order, false, ref HaveKilled) > PreviousLessE || (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))

                        {
                            //ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = null;
                            //ElephantOnTable[ik] = null;
                            //continue;
                        }

                        else
                        {
                            Index[1] = ik;
                            jIndex[1] = j;
                            PreviousLessE = ElephantOnTable[ik].ElefantThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                        }
                    }


                }

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameThinkingTreeElephantBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzGameThinkingTreeHourseBrown(ref int PreviousLessH, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Hourse.
            for (ik = HourseMidle; ik < HourseHight; ik++)
            {
                if (HoursesOnTable == null || HoursesOnTable[ik] == null || HoursesOnTable[ik].HourseThinking == null || HoursesOnTable[ik].HourseThinking[0] == null || HoursesOnTable[ik].HourseThinking[0].HuristicListHourse == null
                    )
                    continue;
                for (j = 0; j < HoursesOnTable[ik].HourseThinking[0].HuristicListHourse.Count; j++)
                {
                    if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 3, ik, j))
                        continue;

                    if (HoursesOnTable[ik].HourseThinking[0].IsSupHu[j]
                    )
                        continue;
                    if (CheckeHuristci(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j], Order, ik, j, 0))
                        continue;

                    if (AllDraw.OrderPlate == Order)
                    {
                        if (HoursesOnTable[ik].HourseThinking[0].ReturnHuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessH || (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))

                        {
                            //HoursesOnTable[ik].HourseThinking[0].AStarGreedy = null;
                            //HoursesOnTable[ik] = null;
                            //continue;
                        }

                        else
                        {
                            Index[2] = ik;
                            jIndex[2] = j;
                            PreviousLessH = HoursesOnTable[ik].HourseThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                        }

                    }
                    else
                    {
                        if (HoursesOnTable[ik].HourseThinking[0].ReturnHuristic(-1, j, Order, false, ref HaveKilled) > PreviousLessH || (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))

                        {
                            //HoursesOnTable[ik].HourseThinking[0].AStarGreedy = null;
                            //HoursesOnTable[ik] = null;
                            //continue;
                        }

                        else
                        {
                            Index[2] = ik;
                            jIndex[2] = j;
                            PreviousLessH = HoursesOnTable[ik].HourseThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                        }
                    }

                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameThinkingTreeHourseBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        int FullGameMakimgBlitz(ref int[] Index, ref int[] jIndex, int Order, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int Kind = -1;
            int PS = Int32.MinValue, PE = Int32.MinValue, PH = Int32.MinValue, PB = Int32.MinValue, PM = Int32.MinValue, PK = Int32.MinValue;
            if (Order != AllDraw.OrderPlate)
            {
                PS = Int32.MaxValue;
                PE = Int32.MaxValue;
                PH = Int32.MaxValue;
                PB = Int32.MaxValue;
                PM = Int32.MaxValue;
                PK = Int32.MaxValue;

            }

            int[] index = { -1, -1, -1, -1, -1, -1 };
            int[] jindex = { -1, -1, -1, -1, -1, -1 };
            if (Order== 1)
            {
                Object O = new Object();
                lock (O)
                {
                    BlitzGameThinkingTreeSolderGray(ref PS, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeElephantGray(ref PE, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeHourseGray(ref PH, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeCastleGray(ref PB, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeMinisterGray(ref PM, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeKingGray(ref PK, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                }

            }
            else
            {
                Object O = new Object();
                lock (O)
                {
                    BlitzGameThinkingTreeSolderBrown(ref PS, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeElephantBrown(ref PE, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeHourseBrown(ref PH, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeCastleBrown(ref PB, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeMinisterBrown(ref PM, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeKingBrown(ref PK, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                }
            }
            int JI = -1;
            Object O1 = new Object();
            lock (O1)
            {

                if (Order == OrderPlate)
                    JI = MaxOfSixHuristic(PS, PE, PH, PB, PM, PK);
                else
                    JI = MinOfSixHuristic(PS, PE, PH, PB, PM, PK);
            }
            if (JI != -1)
            {
                Kind = JI;
                for (var i = 0; i < 6; i++)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        Index[i] = index[i];
                        jIndex[i] = jindex[i];
                    }
                }

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameMakimgBlitz:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return System.Math.Abs(Kind);
        }
        void BlitzGameThinkingTreeCastleBrown(ref int PreviousLessB, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Castles.
            for (ik = CastleMidle; ik < CastleHigh; ik++)
            {
                if (CastlesOnTable == null || CastlesOnTable[ik] == null || CastlesOnTable[ik].CastleThinking == null || CastlesOnTable[ik].CastleThinking[0] == null || CastlesOnTable[ik].CastleThinking[0].HuristicListCastle == null
                    )
                    continue;
                for (j = 0; j < CastlesOnTable[ik].CastleThinking[0].HuristicListCastle.Count; j++)
                {
                    if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 4, ik, j))
                        continue;

                    if (CastlesOnTable[ik].CastleThinking[0].IsSupHu[j]
                    )
                        continue;

                    if (CheckeHuristci(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j], Order, ik, j, 0))
                        continue;


                    if (AllDraw.OrderPlate == Order)
                    {
                        if (CastlesOnTable[ik].CastleThinking[0].ReturnHuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessB || (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))

                        {
                            //CastlesOnTable[ik].CastleThinking[0].AStarGreedy = null;
                            //CastlesOnTable[ik] = null;
                            //continue;
                        }


                        else
                        {
                            Index[3] = ik;
                            jIndex[3] = j;
                            PreviousLessB = CastlesOnTable[ik].CastleThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                        }

                    }
                    else
                    {
                        if (CastlesOnTable[ik].CastleThinking[0].ReturnHuristic(-1, j, Order, false, ref HaveKilled) > PreviousLessB || (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))

                        {
                            //CastlesOnTable[ik].CastleThinking[0].AStarGreedy = null;
                            //CastlesOnTable[ik] = null;
                            //continue;
                        }


                        else
                        {
                            Index[3] = ik;
                            jIndex[3] = j;
                            PreviousLessB = CastlesOnTable[ik].CastleThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                        }
                    }

                }

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameThinkingTreeCastleBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzGameThinkingTreeMinisterBrown(ref int PreviousLessM, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Minister.
            for (ik = MinisterMidle; ik < MinisterHigh; ik++)
            {
                if (MinisterOnTable == null || MinisterOnTable[ik] == null || MinisterOnTable[ik].MinisterThinking == null || MinisterOnTable[ik].MinisterThinking[0] == null || MinisterOnTable[ik].MinisterThinking[0].HuristicListMinister == null
                    )
                    continue;
                for (j = 0; j < MinisterOnTable[ik].MinisterThinking[0].HuristicListMinister.Count; j++)
                {
                    if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 5, ik, j))
                        continue;

                    if (MinisterOnTable[ik].MinisterThinking[0].IsSupHu[j]
                      )
                        continue;

                    if (CheckeHuristci(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order, ik, j, 0))
                        continue;

                    if (AllDraw.OrderPlate == Order)
                    {
                        if (MinisterOnTable[ik].MinisterThinking[0].ReturnHuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessM || (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))

                        {
                            //MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = null;
                            //MinisterOnTable[ik] = null;
                            //continue;
                        }
                        else
                        //if (KingDan(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order))
                        {
                            Index[4] = ik;
                            jIndex[4] = j;
                            PreviousLessM = MinisterOnTable[ik].MinisterThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                        }
                    }
                    else
                    {
                        if (MinisterOnTable[ik].MinisterThinking[0].ReturnHuristic(-1, j, Order, false, ref HaveKilled) > PreviousLessM || (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                            //MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = null;
                            //MinisterOnTable[ik] = null;
                            //continue;
                        }
                        else
                        //if (KingDan(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order))
                        {
                            Index[4] = ik;
                            jIndex[4] = j;
                            PreviousLessM = MinisterOnTable[ik].MinisterThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                        }
                    }
                }

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameThinkingTreeMinisterBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzGameThinkingTreeKingBrown(ref int PreviousLessK, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //King.
            for (ik = KingMidle; ik < KingHigh; ik++)
            {
                if (KingOnTable == null || KingOnTable[ik] == null || KingOnTable[ik].KingThinking == null || KingOnTable[ik].KingThinking[0] == null || KingOnTable[ik].KingThinking[0].HuristicListKing == null
                    )
                    continue;
                for (j = 0; j < KingOnTable[ik].KingThinking[0].HuristicListKing.Count; j++)
                {
                    if (!IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 6, ik, j))
                        continue;

                    if (KingOnTable[ik].KingThinking[0].IsSupHu[j]
                     )
                        continue;

                    if (CheckeHuristci(KingOnTable[ik].KingThinking[0].TableListKing[j], Order, ik, j, 0))
                        continue;

                    if (AllDraw.OrderPlate == Order)
                    {
                        if (KingOnTable[ik].KingThinking[0].ReturnHuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessK || (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                            //KingOnTable[ik].KingThinking[0].AStarGreedy = null;
                            //KingOnTable[ik] = null;
                            //continue;
                        }

                        else
                        {
                            Index[5] = ik;
                            jIndex[5] = j;
                            PreviousLessK = KingOnTable[ik].KingThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                        }
                    }
                    else
                    {
                        if (KingOnTable[ik].KingThinking[0].ReturnHuristic(-1, j, Order, false, ref HaveKilled) > PreviousLessK || (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                            //KingOnTable[ik].KingThinking[0].AStarGreedy = null;
                            //KingOnTable[ik] = null;
                            //continue;
                        }

                        else
                        {
                            Index[5] = ik;
                            jIndex[5] = j;
                            PreviousLessK = KingOnTable[ik].KingThinking[0].ReturnHuristic(-1, j, Order, false,ref HaveKilled);
                        }
                    }


                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameThinkingTreeKingBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }

        void BlitzGameThinkingTree(int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Initiatye Variables.
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;

            Color a;
            if (Order== 1)
                a = Color.Gray;
            else
                a = Color.Brown;
            //Order *= -1;
            //ChessRules.CurrentOrder *= -1;
            int[] Index = new int[6];

            int[] jIndex = new int[6];
            int PreviousLessS = Int32.MinValue, PreviousLessE = Int32.MinValue, PreviousLessH = Int32.MinValue, PreviousLessB = Int32.MinValue, PreviousLessM = Int32.MinValue, PreviousLessK = Int32.MinValue;
            if (Order != OrderPlate)
            {
                PreviousLessS = Int32.MaxValue;
                PreviousLessE = Int32.MaxValue;
                PreviousLessH = Int32.MaxValue;
                PreviousLessB = Int32.MaxValue;
                PreviousLessM = Int32.MaxValue;
                PreviousLessK = Int32.MaxValue;

            }
            //For Gray Order calculating foreach Objects Maximum total Huristic Count Incl;usively.
            if (Order== 1)
            {
                Object O1 = new Object();
                lock (O1)
                {
                    Index[0] = -1;
                    BlitzGameThinkingTreeSolderGray(ref PreviousLessS, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[1] = -1;
                    BlitzGameThinkingTreeElephantGray(ref PreviousLessE, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[2] = -1;
                    BlitzGameThinkingTreeHourseGray(ref PreviousLessH, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[3] = -1;
                    BlitzGameThinkingTreeCastleGray(ref PreviousLessB, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[4] = -1;
                    BlitzGameThinkingTreeMinisterGray(ref PreviousLessM, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[5] = -1;
                    BlitzGameThinkingTreeKingGray(ref PreviousLessK, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                }
                int JI = -1;
                Object O2 = new Object();
                lock (O2)
                {

                    JI = MaxOfSixHuristic(PreviousLessS, PreviousLessE, PreviousLessH, PreviousLessB, PreviousLessM, PreviousLessK);
                }

                Object O3 = new Object();
                lock (O3)
                {
                    if (JI != -1)
                    {
                        if (JI == 0)
                            BlitzGameTreeCreationThinkingTreeSolder(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 1)

                            BlitzGameTreeCreationThinkingTreeElephant(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 2)

                            BlitzGameTreeCreationThinkingTreeHourse(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 3)
                            BlitzGameTreeCreationThinkingTreeCastle(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 4)
                            BlitzGameTreeCreationThinkingTreeMinister(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 5)
                            BlitzGameTreeCreationThinkingTreeKing(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                    }
                }
            }
            //For Brown Order Blitz Game Calculate Maximum Huristic Inclusive AStarGreedy First Game Search.
            else
            {
                Object O1 = new Object();
                lock (O1)
                {
                    Index[0] = -1;
                    BlitzGameThinkingTreeSolderBrown(ref PreviousLessS, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[1] = -1;
                    BlitzGameThinkingTreeElephantBrown(ref PreviousLessE, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[2] = -1;
                    BlitzGameThinkingTreeHourseBrown(ref PreviousLessH, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[3] = -1;
                    BlitzGameThinkingTreeCastleBrown(ref PreviousLessB, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[4] = -1;
                    BlitzGameThinkingTreeMinisterBrown(ref PreviousLessM, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[5] = -1;
                    BlitzGameThinkingTreeKingBrown(ref PreviousLessK, ref Index, ref jIndex, Order, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                }
                int JI = -1;
                Object O2 = new Object();
                lock (O2)
                {
                    JI = MaxOfSixHuristic(PreviousLessS, PreviousLessE, PreviousLessH, PreviousLessB, PreviousLessM, PreviousLessK);
                }
                Object O3 = new Object();
                lock (O3)
                {
                    if (JI != -1)
                    {
                        BlitzGameTreeCreationThinkingTreeSolder(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        //if (JI == 1)

                        BlitzGameTreeCreationThinkingTreeElephant(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 2)

                            BlitzGameTreeCreationThinkingTreeHourse(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 3)
                            BlitzGameTreeCreationThinkingTreeCastle(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 4)
                            BlitzGameTreeCreationThinkingTreeMinister(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;


                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        if (JI == 5)
                            BlitzGameTreeCreationThinkingTreeKing(a, Index, jIndex, Order * -1, iAStarGreedy, ik, j, FOUND, LeafAStarGreedy);


                    }
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzGameThinkingTree:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        String Alphabet(int RowRealesed)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            String A = "";
            if (RowRealesed == 0)
                A = "a";
            else
                if (RowRealesed == 1)
                A = "b";
            else
                    if (RowRealesed == 2)
                A = "c";
            else
                        if (RowRealesed == 3)
                A = "d";
            else
                            if (RowRealesed == 4)
                A = "e";
            else
                                if (RowRealesed == 5)
                A = "f";
            else
                                    if (RowRealesed == 6)
                A = "g";
            else
                                        if (RowRealesed == 7)
                A = "h";
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Alphabet:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return A;




        }
        String Number(int ColumnRealeased)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            String A = "";
            if (ColumnRealeased == 7)
                A = "0";
            else
                if (ColumnRealeased == 6)
                A = "1";
            else
                    if (ColumnRealeased == 5)
                A = "2";
            else
                        if (ColumnRealeased == 4)
                A = "3";
            else
                            if (ColumnRealeased == 3)
                A = "4";
            else
                                if (ColumnRealeased == 2)
                A = "5";
            else
                                    if (ColumnRealeased == 1)
                A = "6";
            else
                                        if (ColumnRealeased == 0)
                A = "7";
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Number:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return A;




        }
        int SumOfObjects(AllDraw A, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int Sum = 0;
            if (A == null)
                return Sum;
            if (Order== 1)
            {
                for (var i = 0; i < A.SodierMidle; i++)
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                        Sum += A.SolderesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.ElefantMidle; i++)
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                        Sum += A.ElephantOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.HourseMidle; i++)
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                        Sum += A.HoursesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.CastleMidle; i++)
                {
                    if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                        Sum += A.CastlesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.MinisterMidle; i++)
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                        Sum += A.MinisterOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.KingMidle; i++)
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null)
                        Sum += A.KingOnTable[i].WinOcuuredatChiled;
                }

            }
            else
            {
                for (var i = A.SodierMidle; i < A.SodierHigh; i++)
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                        Sum += A.SolderesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = A.ElefantMidle; i < A.ElefantHigh; i++)
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                        Sum += A.ElephantOnTable[i].WinOcuuredatChiled;
                }
                for (var i = A.HourseMidle; i < A.HourseHight; i++)
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                        Sum += A.HoursesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = A.CastleMidle; i < A.CastleHigh; i++)
                {
                    if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                        Sum += A.CastlesOnTable[i].WinOcuuredatChiled;
                }

                for (var i = A.MinisterMidle; i < A.MinisterHigh; i++)
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                        Sum += A.MinisterOnTable[i].WinOcuuredatChiled;
                }
                for (var i = A.KingMidle; i < A.KingHigh; i++)
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null)
                        Sum += A.KingOnTable[i].WinOcuuredatChiled;
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SumOfObjects:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Sum;
        }
        int SumMinusOfObjects(AllDraw A, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int Sum = 0;
            if (A == null)
                return Sum;
            if (Order == 1)
            {
                for (var i = 0; i < A.SodierMidle; i++)
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                        Sum += A.SolderesOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = 0; i < A.ElefantMidle; i++)
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                        Sum += A.ElephantOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = 0; i < A.HourseMidle; i++)
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                        Sum += A.HoursesOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = 0; i < A.CastleMidle; i++)
                {
                    if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                        Sum += A.CastlesOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = 0; i < A.MinisterMidle; i++)
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                        Sum += A.MinisterOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = 0; i < A.KingMidle; i++)
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null)
                        Sum += A.KingOnTable[i].LoseOcuuredatChiled;
                }

            }
            else
            {
                for (var i = A.SodierMidle; i < A.SodierHigh; i++)
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                        Sum += A.SolderesOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = A.ElefantMidle; i < A.ElefantHigh; i++)
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                        Sum += A.ElephantOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = A.HourseMidle; i < A.HourseHight; i++)
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                        Sum += A.HoursesOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = A.CastleMidle; i < A.CastleHigh; i++)
                {
                    if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                        Sum += A.CastlesOnTable[i].LoseOcuuredatChiled;
                }

                for (var i = A.MinisterMidle; i < A.MinisterHigh; i++)
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                        Sum += A.MinisterOnTable[i].LoseOcuuredatChiled;
                }
                for (var i = A.KingMidle; i < A.KingHigh; i++)
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null)
                        Sum += A.KingOnTable[i].LoseOcuuredatChiled;
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SumMinusOfObjects:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Sum;
        }
        bool ReturnFullGameThinkingTreeSemaphore(int ik, int kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            if (kind == 1)
            {
                if (SolderesOnTable[ik].SoldierThinking[0].ThinkingBegin && (!SolderesOnTable[ik].SoldierThinking[0].ThinkingFinished))
                    return true;
            }
            else
                if (kind == 2)
            {
                if (ElephantOnTable[ik].ElefantThinking[0].ThinkingBegin && (!ElephantOnTable[ik].ElefantThinking[0].ThinkingFinished))
                    return true;
            }
            else if (kind == 3)
            {
                if (HoursesOnTable[ik].HourseThinking[0].ThinkingBegin && (!HoursesOnTable[ik].HourseThinking[0].ThinkingFinished))
                    return true;
            }
            else if (kind == 4)
            {
                if (CastlesOnTable[ik].CastleThinking[0].ThinkingBegin && (!CastlesOnTable[ik].CastleThinking[0].ThinkingFinished))
                    return true;
            }
            else
                if (kind == 5)
            {
                if (MinisterOnTable[ik].MinisterThinking[0].ThinkingBegin && (!MinisterOnTable[ik].MinisterThinking[0].ThinkingFinished))
                    return true;
            }
            else if (kind == 6)
            {
                if (KingOnTable[ik].KingThinking[0].ThinkingBegin && (!KingOnTable[ik].KingThinking[0].ThinkingFinished))
                    return true;
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ReturnFullGameThinkingTreeSemaphore:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return false;
        }

        bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(int ik, int kind, bool Penalty, int j)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            if (Penalty)
            {
                if (kind == 1)
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else
                                if (kind == 2)
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 3)
                {
                    if (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 4)
                {
                    if (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else
                    if (kind == 5)
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 6)
                {
                    if (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
            }
            else 
            {
                if (kind == 1)
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else
                         if (kind == 2)
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 3)
                {
                    if (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 4)
                {
                    if (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else
                    if (kind == 5)
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 6)
                {
                    if (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return false;
        }
        void BlitzNotValidFullGameThinkingTreePartOne(int ik, int Order, int kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            if (kind == 1)
            {
                if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy == null)
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 2)
            {
                if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy == null)
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = new List<AllDraw>();
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 3)
            {
                if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy == null)
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 4)
            {
                if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy == null)
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 5)
            {
                if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy == null)
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 6)
            {
                if (KingOnTable[ik].KingThinking[0].AStarGreedy == null)
                    KingOnTable[ik].KingThinking[0].AStarGreedy = new List<AllDraw>();
                KingOnTable[ik].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzNotValidFullGameThinkingTreePartOne:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzNotValidFullGameThinkingTreePartTow(int ik, int Order, int kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            if (kind == 1)
            {
                if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy == null)
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 2)
            {
                if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy == null)
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = new List<AllDraw>();
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 3)
            {
                if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy == null)
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 4)
            {
                if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy == null)
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 5)
            {
                if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy == null)
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 6)
            {
                if (KingOnTable[ik].KingThinking[0].AStarGreedy == null)
                    KingOnTable[ik].KingThinking[0].AStarGreedy = new List<AllDraw>();
                KingOnTable[ik].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzNotValidFullGameThinkingTreePartTow:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void BlitzNotValidFullGameThinkingTreePartThree(int ik, int Order, int kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            if (kind == 1)
            {
                if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy == null)
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;

            }
            else if (kind == 2)
            {
                if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy == null)
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = new List<AllDraw>();
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 3)
            {
                if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy == null)
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 4)
            {
                if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy == null)
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 5)
            {
                if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy == null)
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 6)
            {
                if (KingOnTable[ik].KingThinking[0].AStarGreedy == null)
                    KingOnTable[ik].KingThinking[0].AStarGreedy = new List<AllDraw>();
                KingOnTable[ik].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("BlitzNotValidFullGameThinkingTreePartThree:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void FullGameThinkingTreeInitialization(int ik, int j, int Order, int kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            if (kind == 1)
            {
                if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy == null)
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]));
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].SetRowColumnFinishedWait();
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                     }
            else if (kind == 2)
            {
                if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy == null)
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = new List<AllDraw>();
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]));
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].SetRowColumnFinishedWait();
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    }
            else if (kind == 3)
            {
                if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy == null)
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]));
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].SetRowColumnFinishedWait();
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    }
            else if (kind == 4)
            {
                if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy == null)
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j]));
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].SetRowColumnFinishedWait();
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    }
            else if (kind == 5)
            {
                if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy == null)
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]));
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumnFinishedWait();
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            else if (kind == 6)
            {
                if (KingOnTable[ik].KingThinking[0].AStarGreedy == null)
                    KingOnTable[ik].KingThinking[0].AStarGreedy = new List<AllDraw>();
                KingOnTable[ik].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1 , MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]));
                KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].SetRowColumnFinishedWait();
                KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeInitialization:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void OpOfFullGameThinkingTree(int ik, int j, int Order, int iAStarGreedy, int ii, int jj, Color a, int kind,bool FOUND,int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            if (kind == 1)
            {
                OutPutAction = " " + Alphabet(SolderesOnTable[ik].SoldierThinking[0].Row) + Number(SolderesOnTable[ik].SoldierThinking[0].Column) + Alphabet(SolderesOnTable[ik].SoldierThinking[0].RowColumnSoldier[j][0]) + Number(SolderesOnTable[ik].SoldierThinking[0].RowColumnSoldier[j][1]);
                if (Order== 1)
                    OutPut.Append("\r\nPerception Soldier AstarGreedy By Bob at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);
                else
                    OutPut.Append("\r\nPerception Soldier AstarGreedy By Alice at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);

                PerceptionCount++;
                var iii = SolderesOnTable[ik].SoldierThinking[0].RowColumnSoldier[j][0];
                var jjj = SolderesOnTable[ik].SoldierThinking[0].RowColumnSoldier[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]);
                int Ord = Order;
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]), Ord * -1, false, FOUND, LeafAStarGreedy);

                //var array = Task.Factory.StartNew(() => SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]), Order, false, FOUND, LeafAStarGreedy));

                //SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, iii, jjj, aa, Tab, Ord*-1, false, FOUND, LeafAStarGreedy);
                //array.Start();
                /*bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA) { ASS = AllDraw.Blitz; }  if (!ASS)
                {
                    Object ttttt = new Object(); lock (ttttt) { tHA.Add(array); }
                }
                else
                {
                    Object ttttt = new Object(); lock (ttttt) { array.Wait(); }
                }
                */
                //array.Name = "S" + i.ToString();
            }
            else if (kind == 2)
            {
                OutPutAction = " " + Alphabet(ElephantOnTable[ik].ElefantThinking[0].Row) + Number(ElephantOnTable[ik].ElefantThinking[0].Column) + Alphabet(ElephantOnTable[ik].ElefantThinking[0].RowColumnElefant[j][0]) + Number(ElephantOnTable[ik].ElefantThinking[0].RowColumnElefant[j][1]);
                if (Order== 1)
                    OutPut.Append("\r\nPerception Elephant AstarGreedy By Bob at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);
                else
                    OutPut.Append("\r\nPerception Elephant AstarGreedy By Alice at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);

                PerceptionCount++;
                var iii = ElephantOnTable[ik].ElefantThinking[0].RowColumnElefant[j][0];
                var jjj = ElephantOnTable[ik].ElefantThinking[0].RowColumnElefant[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]);
                int Ord = Order;
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;

                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, iii, jjj, aa, Tab, Ord * -1, false, FOUND, LeafAStarGreedy);
                //var array = Task.Factory.StartNew(() => ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]), Order, false, FOUND, LeafAStarGreedy));

                //array.Start();
                /*bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA) { ASS = AllDraw.Blitz; }  if (!ASS)
                {
                    Object ttttt = new Object(); lock (ttttt) { tHA.Add(array); }
                }
                else
                {
                    Object ttttt = new Object(); lock (ttttt) { array.Wait(); }
                }*/
                //array.Name = "E" + i.ToString();
            }
            else if (kind == 3)
            {
                OutPutAction = " " + Alphabet(HoursesOnTable[ik].HourseThinking[0].Row) + Number(HoursesOnTable[ik].HourseThinking[0].Column) + Alphabet(HoursesOnTable[ik].HourseThinking[0].RowColumnHourse[j][0]) + Number(HoursesOnTable[ik].HourseThinking[0].RowColumnHourse[j][1]);
                if (Order== 1)
                    OutPut.Append("\r\nPerception Hourse AstarGreedy By Bob at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);
                else
                    OutPut.Append("\r\nPerception Hourse AstarGreedy By Alice at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);

                PerceptionCount++;
                var iii = HoursesOnTable[ik].HourseThinking[0].RowColumnHourse[j][0];
                var jjj = HoursesOnTable[ik].HourseThinking[0].RowColumnHourse[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]);
                int Ord = Order;
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, iii, jjj, aa, Tab, Ord * -1, false, FOUND, LeafAStarGreedy);

                //var array = Task.Factory.StartNew(() => HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]), Order, false, FOUND, LeafAStarGreedy));

                //array.Start();
                /*bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA) { ASS = AllDraw.Blitz; }  if (!ASS)
               {
                   Object ttttt = new Object(); lock (ttttt) { tHA.Add(array); }
               }
               else
               {
                   Object ttttt = new Object(); lock (ttttt) { array.Wait(); }
               }
               */
                //array.Name = "H" + i.ToString();
            }
            else if (kind == 4)
            {
                OutPutAction = " " + Alphabet(CastlesOnTable[ik].CastleThinking[0].Row) + Number(CastlesOnTable[ik].CastleThinking[0].Column) + Alphabet(CastlesOnTable[ik].CastleThinking[0].RowColumnCastle[j][0]) + Number(CastlesOnTable[ik].CastleThinking[0].RowColumnCastle[j][1]);
                if (Order== 1)
                    OutPut.Append("\r\nPerception Castle AstarGreedy By Bob at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);
                else
                    OutPut.Append("\r\nPerception Castle AstarGreedy By Alice at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);

                PerceptionCount++;
                var iii = CastlesOnTable[ik].CastleThinking[0].RowColumnCastle[j][0];
                var jjj = CastlesOnTable[ik].CastleThinking[0].RowColumnCastle[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j]);
                int Ord = Order;
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                //var array = Task.Factory.StartNew(() => CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j]), Order, false, FOUND, LeafAStarGreedy));
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, iii, jjj, aa, Tab, Ord * -1, false, FOUND, LeafAStarGreedy);
                //array.Start();
                /*bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA) { ASS = AllDraw.Blitz; }  if (!ASS)
                {
                    Object ttttt = new Object(); lock (ttttt) { tHA.Add(array); }
                }
                else
                {
                    Object ttttt = new Object(); lock (ttttt) { array.Wait(); }
                }
                */
                //array.Name = "B" + i.ToString();
            }
            else if (kind == 5)
            {
                OutPutAction = " " + Alphabet(MinisterOnTable[ik].MinisterThinking[0].Row) + Number(MinisterOnTable[ik].MinisterThinking[0].Column) + Alphabet(MinisterOnTable[ik].MinisterThinking[0].RowColumnMinister[j][0]) + Number(MinisterOnTable[ik].MinisterThinking[0].RowColumnMinister[j][1]);
                if (Order== 1)
                    OutPut.Append("\r\nPerception Minister AstarGreedy By Bob at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);
                else
                    OutPut.Append("\r\nPerception Minister AstarGreedy By Alice at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);

                PerceptionCount++;
                var iii = MinisterOnTable[ik].MinisterThinking[0].RowColumnMinister[j][0];
                var jjj = MinisterOnTable[ik].MinisterThinking[0].RowColumnMinister[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]);
                int Ord = Order;
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;

                //var array = Task.Factory.StartNew(() => MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]), Order, false, FOUND, LeafAStarGreedy));
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, iii, jjj, aa, Tab, Ord * -1, false, FOUND, LeafAStarGreedy);
                //array.Start();
                /*bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA) { ASS = AllDraw.Blitz; }  if (!ASS)
                {
                    Object ttttt = new Object(); lock (ttttt) { tHA.Add(array); }
                }
                else
                {
                    Object ttttt = new Object(); lock (ttttt) { array.Wait(); }
                }*/
                //array.Name = "M" + i.ToString();
            }
            else if (kind == 6)
            {
                OutPutAction = " " + Alphabet(KingOnTable[ik].KingThinking[0].Row) + Number(KingOnTable[ik].KingThinking[0].Column) + Alphabet(KingOnTable[ik].KingThinking[0].RowColumnKing[j][0]) + Number(KingOnTable[ik].KingThinking[0].RowColumnKing[j][1]);
                if (Order== 1)
                    OutPut.Append("\r\nPerception King AstarGreedy By Bob at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);
                else
                    OutPut.Append("\r\nPerception King AstarGreedy By Alice at Level " + iAStarGreedy.ToString() + " By " + PerceptionCount.ToString() + "th Perception String " + OutPutAction);

                PerceptionCount++;

                var iii = KingOnTable[ik].KingThinking[0].RowColumnKing[j][0];
                var jjj = KingOnTable[ik].KingThinking[0].RowColumnKing[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]);
                int Ord = Order;
                KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;

                //var array = Task.Factory.StartNew(() => KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]), Order, false, FOUND, LeafAStarGreedy));
                KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, iii, jjj, aa, Tab, Ord * -1, false, FOUND, LeafAStarGreedy);


                //array.Start();
                /*bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA) { ASS = AllDraw.Blitz; }  if (!ASS)
                {
                    Object ttttt = new Object(); lock (ttttt) { tHA.Add(array); }
                }
                else
                {
                    Object ttttt = new Object(); lock (ttttt) { array.Wait(); }
                }*/
                //array.Name = "K" + i.ToString();
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("OpOfFullGameThinkingTree:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void ReturnFullGameThinkingTreeSemaphoreAs(int ik,int Kind)
        {
            Object OO1 = new Object();
            lock (OO1)
            {
                TaskBegin++;
                
                    //int S = 0;
                    while (ReturnFullGameThinkingTreeSemaphore(ik, Kind))
                    {
                        System.Threading.Thread.Sleep(2);
                    }
                

            }
        }
            bool FullGameThinkingTreeSoldier(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(ik, 1));
                array.Wait();

                Object OOOO = new Object();
                lock (OOOO)
                {
                    //if (iAStarGreedy < 0)
                    {
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;
                    }
                }

                //Parallel.For(0, SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count, j =>
                for (var j = 0; j < SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count; j++)
                {
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        if (CheckeHuristci(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j], Order, ik, j, 0))
                            continue;

                        if (SolderesOnTable[ik].SoldierThinking[0].IsSupHu[j])
                            continue;
                        
                            if (AllDraw.OrderPlate == Order)
                            {
                                if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 1, true, j)
                                )
                                {
                                    if (AllDraw.Blitz)
                                    {
                                        if (Index[0] != -1)
                                        {
                                            if (ik != Index[0])
                                            {
                                                BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);
                                                continue;
                                            }
                                            else
                                            if (j != jindex[0])
                                            {
                                                BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 1);
                                                continue;
                                            }
                                        }
                                        else
                                        {
                                            BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 1);
                                            continue;
                                        }
                                    }
                                    Object O3 = new Object();
                                    lock (O3)
                                    {
                                        FullGameThinkingTreeInitialization(ik, j, Order, 1);
                                    }
                                    //SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j], Order, false,ref HaveKilled);
                                    //ParameterizedThreadStart start = new ParameterizedThreadStart(SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                    if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count > 0)
                                    {
                                        Object O = new Object();

                                        lock (O)
                                        {
                                            OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 1,FOUND,LeafAStarGreedy);

                                            Do = true;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 1, false, j)

                                )
                                {
                                    //if (JI == 0)
                                    // if (Index[0] != -1)
                                    {
                                        if (Index[0] != -1)
                                        {
                                            if (ik != Index[0])
                                            {
                                                BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);
                                                continue;
                                            }
                                            else
                                            if (j != jindex[0])
                                            {
                                                BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 1);
                                                continue;
                                            }
                                        }
                                        else
                                        {
                                            BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 1);
                                            continue;
                                        }
                                        Object O3 = new Object();
                                        lock (O3)
                                        {
                                            FullGameThinkingTreeInitialization(ik, j, Order, 1);
                                        }
                                        //SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j], Order, false,ref HaveKilled);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Object O = new Object();

                                            lock (O)
                                            {
                                                OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 1,FOUND,LeafAStarGreedy);

                                                Do = true;
                                            }
                                        }

                                    }
                                }
                            }
                       
                    }
                }//);
                /*if (tHA.Count > 1)
                {
                    var array = Task.Factory.StartNew(() => Parallel.ForEach(tHA, items => Task.WaitAny(items)));
                    //array.Start();
                    Task.WaitAll(array);
                }
    */
                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }
            for (int h = 0; h < SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[ik].SoldierThinking[0].AStarGreedy != null; h++)
                SolderesOnTable[ik].WinOcuuredatChiled += SumOfObjects(SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[h], Order);
            for (int h = 0; h < SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[ik].SoldierThinking[0].AStarGreedy != null; h++)
                SolderesOnTable[ik].LoseOcuuredatChiled += SumMinusOfObjects(SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[h], Order);
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeSoldier:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
            //Elephant
        }
        bool FullGameThinkingTreeSoldierGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                
                    ////Parallel.For(0, SodierMidle, ik =>
                    for (var ik = 0; ik < SodierMidle; ik++)
                    {
                        if (SolderesOnTable != null && SolderesOnTable[ik] != null && SolderesOnTable[ik].SoldierThinking != null && SolderesOnTable[ik].SoldierThinking[0] != null
                            )
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                Do = FullGameThinkingTreeSoldier(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy);
                            }
                        }
                    }//);
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeSoldierGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeElephant(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(ik, 2));
                array.Wait();

                Object OOOO = new Object();
                lock (OOOO)
                {
                    //if (iAStarGreedy < 0)
                    {

                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;


                    }
                }
              
                ////Parallel.For(0, ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count, j =>
                for (var j = 0; j < ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count; j++)
                {
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        if (CheckeHuristci(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j], Order, ik, j, 0))
                            continue;

                        if (ElephantOnTable[ik].ElefantThinking[0].IsSupHu[j])
                            continue;
                        
                            if (AllDraw.OrderPlate == Order)
                            {
                                if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 2, true, j)
                                )
                                {

                                        if (AllDraw.Blitz)
                                        {
                                            if (Index[1] != -1)
                                            {

                                                if (ik != Index[1])
                                                {
                                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);
                                                    continue;
                                                }
                                                else
                                                    if (j != jindex[1])
                                                {
                                                    BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 2);
                                                    continue;
                                                }
                                            }
                                            else
                                            {
                                                BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 2);
                                                continue;
                                            }
                                        }
                                        Object O3 = new Object();
                                        lock (O3)
                                        {
                                            FullGameThinkingTreeInitialization(ik, j, Order, 2);

                                            //ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j], Order, false,ref HaveKilled);
                                            //ParameterizedThreadStart start = new ParameterizedThreadStart(ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                            if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count > 0)
                                            {
                                                Object O = new Object();
                                                lock (O)
                                                {
                                                    OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 2,FOUND,LeafAStarGreedy);
                                                    Do = true;
                                                }
                                            }
                                        }                                    
                                }
                            }
                            else
                            {
                                if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 2, false, j)

                                )
                                {
                                   
                                        if (AllDraw.Blitz)
                                        {
                                            if (Index[1] != -1)
                                            {

                                                if (ik != Index[1])
                                                {
                                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);
                                                    continue;
                                                }
                                                else
                                                    if (j != jindex[1])
                                                {
                                                    BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 2);
                                                    continue;
                                                }
                                            }
                                            else
                                            {
                                                BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 2);
                                                continue;
                                            }
                                        }
                                        Object O3 = new Object();
                                        lock (O3)
                                        {
                                            FullGameThinkingTreeInitialization(ik, j, Order, 2);

                                            //ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j], Order, false,ref HaveKilled);
                                            //ParameterizedThreadStart start = new ParameterizedThreadStart(ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                            if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count > 0)
                                            {
                                                Object O = new Object();
                                                lock (O)
                                                {
                                                    OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 2, FOUND, LeafAStarGreedy);
                                                    Do = true;
                                                }
                                            }                                       

                                    }
                                }
                            }
                       
                    }
                }//);
                /*if (tHA.Count > 1)
                {
                    var array = Task.Factory.StartNew(() => Parallel.ForEach(tHA, items => Task.WaitAny(items)));
                    //array.Start();
                    Task.WaitAll(array);
                }
                */
                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }
            for (int h = 0; h < ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[ik].ElefantThinking[0].AStarGreedy != null; h++)
                ElephantOnTable[ik].WinOcuuredatChiled += SumOfObjects(ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[h], Order);
            for (int h = 0; h < ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[ik].ElefantThinking[0].AStarGreedy != null; h++)
                ElephantOnTable[ik].LoseOcuuredatChiled += SumMinusOfObjects(ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[h], Order);
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeElephant:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeElephantGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {

                //Elephant
                
                    ////Parallel.For(0, ElefantMidle, ik =>
                    for (var ik = 0; ik < ElefantMidle; ik++)
                    {
                        if (ElephantOnTable != null && ElephantOnTable[ik] != null && ElephantOnTable[ik].ElefantThinking != null && ElephantOnTable[ik].ElefantThinking[0] != null
                            )
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                Do = FullGameThinkingTreeElephant(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy);
                            }
                        }
                    }//);
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeElephantGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeHourse(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(ik, 3));
                array.Wait();


                Object OOOO = new Object();
                lock (OOOO)
                {
                    //if (iAStarGreedy < 0)
                    {

                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;

                    }
                }
          
                ////Parallel.For(0, HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count, j =>
                for (var j = 0; j < HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count; j++)
                {
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        if (CheckeHuristci(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j], Order, ik, j, 0))
                            continue;

                        if (HoursesOnTable[ik].HourseThinking[0].IsSupHu[j])
                            continue;

                        
                            if (AllDraw.OrderPlate == Order)
                            {
                                if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 3, true, j)
                                )
                                {
                                    
                                        if (AllDraw.Blitz)
                                        {
                                            if (Index[2] != -1)
                                            {

                                                if (ik != Index[2])
                                                {
                                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);
                                                    continue;
                                                }
                                                else
                                                    if (j != jindex[2])
                                                {
                                                    BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 3);
                                                    continue;
                                                }
                                            }
                                            else
                                            {
                                                BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 3);
                                                continue;
                                            }
                                        }

                                        Object O3 = new Object();
                                        lock (O3)
                                        {
                                            FullGameThinkingTreeInitialization(ik, j, Order, 3);
                                        }
                                        //HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, HoursesOnTable[ik].HourseThinking[0].TableListHourse[j], Order, false,ref HaveKilled);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 3, FOUND, LeafAStarGreedy);
                                                Do = true;
                                            }
                                        }
                                    
                                }
                                else
                                {
                                    if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 3, false, j)

                                    )
                                    {
                                        
                                            if (AllDraw.Blitz)
                                            {
                                                if (Index[2] != -1)
                                                {

                                                    if (ik != Index[2])
                                                    {
                                                        BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);
                                                        continue;
                                                    }
                                                    else
                                                        if (j != jindex[2])
                                                    {
                                                        BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 3);
                                                        continue;
                                                    }
                                                }
                                                else
                                                {
                                                    BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 3);
                                                    continue;
                                                }
                                            }

                                            Object O3 = new Object();
                                            lock (O3)
                                            {
                                                FullGameThinkingTreeInitialization(ik, j, Order, 3);
                                            }
                                            //HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, HoursesOnTable[ik].HourseThinking[0].TableListHourse[j], Order, false,ref HaveKilled);
                                            //ParameterizedThreadStart start = new ParameterizedThreadStart(HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                            if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count > 0)
                                            {
                                                Object O = new Object();
                                                lock (O)
                                                {
                                                    OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 3, FOUND, LeafAStarGreedy);
                                                    Do = true;
                                                }
                                            }                                        

                                    }
                                }
                            }
                       
                    }
                }//);
                /*if (tHA.Count > 1)
                {
                    var array = Task.Factory.StartNew(() => Parallel.ForEach(tHA, items => Task.WaitAny(items)));
                    //array.Start();
                    Task.WaitAll(array);
                }
                */
                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }
            for (int h = 0; h < HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[ik].HourseThinking[0].AStarGreedy != null; h++)
                HoursesOnTable[ik].WinOcuuredatChiled += SumOfObjects(HoursesOnTable[ik].HourseThinking[0].AStarGreedy[h], Order);
            for (int h = 0; h < HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[ik].HourseThinking[0].AStarGreedy != null; h++)
                HoursesOnTable[ik].LoseOcuuredatChiled += SumMinusOfObjects(HoursesOnTable[ik].HourseThinking[0].AStarGreedy[h], Order);
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeHourse:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeHourseGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {

                //Hourse.
                
                    ////Parallel.For(0, HourseMidle, ik =>
                    for (var ik = 0; ik < HourseMidle; ik++)
                    {
                        if (HoursesOnTable != null && HoursesOnTable[ik] != null && HoursesOnTable[ik].HourseThinking != null && HoursesOnTable[ik].HourseThinking[0] != null
                            )
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                Do = FullGameThinkingTreeHourse(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy);
                            }
                        }
                    }//);
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeHourseGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeCastle(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(ik, 4));
                array.Wait();

                Object OOOO = new Object();
                lock (OOOO)
                {
                    //if (iAStarGreedy < 0)
                    {

                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;

                    }
                }
             
                ////Parallel.For(0, CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count, j =>
                for (var j = 0; j < CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count; j++)
                {
                    if (CheckeHuristci(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j], Order, ik, j, 0))
                        continue;

                    if (CastlesOnTable[ik].CastleThinking[0].IsSupHu[j])
                        continue;
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        
                            if (AllDraw.OrderPlate == Order)
                            {
                                if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 4, true, j)
                                )
                                {
                                    
                                        if (AllDraw.Blitz)
                                        {
                                            if (Index[3] != -1)
                                            {
                                                if (ik != Index[3])
                                                {
                                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);
                                                    continue;
                                                }
                                                else
                                                    if (j != jindex[0])
                                                {
                                                    BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 4);
                                                    continue;
                                                }
                                            }
                                            else
                                            {
                                                BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 4);
                                                continue;
                                            }
                                        }
                                        Object O3 = new Object();
                                        lock (O3)
                                        {
                                            FullGameThinkingTreeInitialization(ik, j, Order, 4);
                                        }
                                        //CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CastlesOnTable[ik].CastleThinking[0].TableListCastle[j], Order, false,ref HaveKilled);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 4, FOUND, LeafAStarGreedy);
                                                Do = true;
                                            }
                                        }
                                    }                               
                            }
                            else
                            {
                                if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 4, false, j)

                                )
                                {
                                    
                                        if (AllDraw.Blitz)
                                        {
                                            if (Index[3] != -1)
                                            {
                                                if (ik != Index[3])
                                                {
                                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);
                                                    continue;
                                                }
                                                else
                                                    if (j != jindex[0])
                                                {
                                                    BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 4);
                                                    continue;
                                                }
                                            }
                                            else
                                            {
                                                BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 4);
                                                continue;
                                            }
                                        }
                                        Object O3 = new Object();
                                        lock (O3)
                                        {
                                            FullGameThinkingTreeInitialization(ik, j, Order, 4);
                                        }
                                        //CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CastlesOnTable[ik].CastleThinking[0].TableListCastle[j], Order, false,ref HaveKilled);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 4, FOUND, LeafAStarGreedy);
                                                Do = true;
                                            }
                                        }
                                    
                                }
                            }
                       
                    }
                }//);
                /*if (tHA.Count > 1)
                {
                    var array = Task.Factory.StartNew(() => Parallel.ForEach(tHA, items => Task.WaitAny(items)));
                    //array.Start();
                    Task.WaitAll(array);
                }*/
                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }
            for (int h = 0; h < CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[ik].CastleThinking[0].AStarGreedy != null; h++)
                CastlesOnTable[ik].WinOcuuredatChiled += SumOfObjects(CastlesOnTable[ik].CastleThinking[0].AStarGreedy[h], Order);
            for (int h = 0; h < CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[ik].CastleThinking[0].AStarGreedy != null; h++)
                CastlesOnTable[ik].LoseOcuuredatChiled += SumMinusOfObjects(CastlesOnTable[ik].CastleThinking[0].AStarGreedy[h], Order);
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeCastle:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeCastleGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {

                //Castle.
                
                    ////Parallel.For(0, CastleMidle, ik =>
                    for (var ik = 0; ik < CastleMidle; ik++)
                    {
                        if (CastlesOnTable != null && CastlesOnTable[ik] != null && CastlesOnTable[ik].CastleThinking != null && CastlesOnTable[ik].CastleThinking[0] != null
                            )
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                Do = FullGameThinkingTreeCastle(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy);
                            }
                        }
                    }//);
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeCastleGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeMinister(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(ik, 5));
                array.Wait();


                Object OOOO = new Object();
                lock (OOOO)
                {
                    //if (iAStarGreedy < 0)
                    {

                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;


                    }
                }
              
                ////Parallel.For(0, MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count, j =>
                for (var j = 0; j < MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count; j++)
                {
                    if (CheckeHuristci(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order, ik, j, 0))
                        continue;

                    if (MinisterOnTable[ik].MinisterThinking[0].IsSupHu[j])
                        continue;

                    Object ooo = new Object();
                    lock (ooo)
                    {

                        
                            if (AllDraw.OrderPlate == Order)
                            {
                                if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 5, true, j)
                                )
                                {
                                    
                                        if (AllDraw.Blitz)
                                        {
                                            if (Index[4] != -1)
                                            {
                                                if (ik != Index[4])
                                                {
                                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);
                                                    continue;
                                                }
                                                else
                                                     if (j != jindex[4])

                                                {
                                                    BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 5);
                                                    continue;
                                                }
                                            }
                                            else
                                            {
                                                BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 5);
                                                continue;
                                            }
                                        }
                                        Object O3 = new Object();
                                        lock (O3)
                                        {
                                            FullGameThinkingTreeInitialization(ik, j, Order, 5);
                                        }
                                        //MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order, false,ref HaveKilled);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 5, FOUND, LeafAStarGreedy);
                                                Do = true;

                                            }

                                        }                                   
                                }
                            }
                            else
                            {
                                if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 5, false, j)

                                )
                                {
                                    
                                        if (AllDraw.Blitz)
                                        {
                                            if (Index[4] != -1)
                                            {
                                                if (ik != Index[4])
                                                {
                                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);
                                                    continue;
                                                }
                                                else
                                                     if (j != jindex[4])

                                                {
                                                    BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 5);
                                                    continue;
                                                }
                                            }
                                            else
                                            {
                                                BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 5);
                                                continue;
                                            }
                                        }
                                        Object O3 = new Object();
                                        lock (O3)
                                        {
                                            FullGameThinkingTreeInitialization(ik, j, Order, 5);
                                        }
                                        //MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order, false,ref HaveKilled);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Object O = new Object();
                                            lock (O)
                                            {
                                                OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 5, FOUND, LeafAStarGreedy);
                                                Do = true;

                                            }

                                        }
                                    
                                }
                            }
                       
                    }
                }//);
                /*if (tHA.Count > 1)
                {
                    var array = Task.Factory.StartNew(() => Parallel.ForEach(tHA, items => Task.WaitAny(items)));
                    Task.WaitAll(array);
                    //array.Start();
                }
                */
                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }
            for (int h = 0; h < MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[ik].MinisterThinking[0].AStarGreedy != null; h++)
                MinisterOnTable[ik].WinOcuuredatChiled += SumOfObjects(MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[h], Order);
            for (int h = 0; h < MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[ik].MinisterThinking[0].AStarGreedy != null; h++)
                MinisterOnTable[ik].LoseOcuuredatChiled += SumMinusOfObjects(MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[h], Order);
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeMinister:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeMinisterGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {

                //Minister.
                
                    ////Parallel.For(0, MinisterMidle, ik =>
                    for (var ik = 0; ik < MinisterMidle; ik++)
                    {
                        if (MinisterOnTable != null && MinisterOnTable[ik] != null && MinisterOnTable[ik].MinisterThinking != null && MinisterOnTable[ik].MinisterThinking[0] != null
                            )
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                Do = FullGameThinkingTreeMinister(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy);
                            }
                        }
                    }//);
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeMinisterGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeKing(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(ik, 6));
                array.Wait();


                Object OOOO = new Object();
                lock (OOOO)
                {
                    //if (iAStarGreedy < 0)
                    {

                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;


                    }

                }
               
                if (KingOnTable[ik].KingThinking[0].TableListKing.Count == 0)
                    return Do;
                // //Parallel.For(0, KingOnTable[ik].KingThinking[0].TableListKing.Count, j =>
                for (var j = 0; j < KingOnTable[ik].KingThinking[0].TableListKing.Count; j++)
                {
                    if (CheckeHuristci(KingOnTable[ik].KingThinking[0].TableListKing[j], Order, ik, j, 0))
                        continue;

                    if (KingOnTable[ik].KingThinking[0].IsSupHu[j])
                        continue;

                    Object ooo = new Object();
                    lock (ooo)
                    {

                        
                            if (AllDraw.OrderPlate == Order)
                            {
                                if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 6, true, j)
                                )
                                {
                                    if (AllDraw.Blitz)
                                    {
                                        if (Index[5] != -1)
                                        {
                                            if (ik != Index[5])
                                            {
                                                BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);
                                                continue;
                                            }
                                            else
                                                 if (j != jindex[5])
                                            {
                                                BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 6);
                                                continue;
                                            }
                                        }
                                        else
                                        {
                                            BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 6);
                                            continue;
                                        }

                                    }
                                    Object O3 = new Object();
                                    lock (O3)
                                    {
                                        FullGameThinkingTreeInitialization(ik, j, Order, 6);
                                    }
                                    //KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, KingOnTable[ik].KingThinking[0].TableListKing[j], Order, false,ref HaveKilled);
                                    //ParameterizedThreadStart start = new ParameterizedThreadStart(KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                    if (KingOnTable[ik].KingThinking[0].AStarGreedy.Count > 0)
                                    {
                                        Object O = new Object();
                                        lock (O)
                                        {
                                            OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 6, FOUND, LeafAStarGreedy);
                                            Do = true;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 6, false, j)

                                )
                                {
                                    if (AllDraw.Blitz)
                                    {
                                        if (Index[5] != -1)
                                        {
                                            if (ik != Index[5])
                                            {
                                                BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);
                                                continue;
                                            }
                                            else
                                                 if (j != jindex[5])
                                            {
                                                BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 6);
                                                continue;
                                            }
                                        }
                                        else
                                        {
                                            BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 6);
                                            continue;
                                        }

                                    }
                                    Object O3 = new Object();
                                    lock (O3)
                                    {
                                        FullGameThinkingTreeInitialization(ik, j, Order, 6);
                                    }
                                    //KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, KingOnTable[ik].KingThinking[0].TableListKing[j], Order, false,ref HaveKilled);
                                    //ParameterizedThreadStart start = new ParameterizedThreadStart(KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                    if (KingOnTable[ik].KingThinking[0].AStarGreedy.Count > 0)
                                    {
                                        Object O = new Object();
                                        lock (O)
                                        {
                                            OpOfFullGameThinkingTree(ik, j, Order, iAStarGreedy, ii, jj, a, 6, FOUND, LeafAStarGreedy);
                                            Do = true;
                                        }
                                    }
                                }
                            }
                       
                    }
                }//);
                /*if (tHA.Count > 1)
                {
                    var array = Task.Factory.StartNew(() => Parallel.ForEach(tHA, items => Task.WaitAny(items)));
                    Task.WaitAll(array);
                    //array.Start();
                }*/
                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }
            for (int h = 0; h < KingOnTable[ik].KingThinking[0].AStarGreedy.Count && KingOnTable[ik].KingThinking[0].AStarGreedy != null; h++)
                KingOnTable[ik].WinOcuuredatChiled += SumOfObjects(KingOnTable[ik].KingThinking[0].AStarGreedy[h], Order);
            for (int h = 0; h < KingOnTable[ik].KingThinking[0].AStarGreedy.Count && KingOnTable[ik].KingThinking[0].AStarGreedy != null; h++)
                KingOnTable[ik].LoseOcuuredatChiled += SumMinusOfObjects(KingOnTable[ik].KingThinking[0].AStarGreedy[h], Order);
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeKing:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeKingGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                //int ik;
                //King.
                
                    ////Parallel.For(0, KingMidle, ik =>
                    for (var ik = 0; ik < KingMidle; ik++)
                    {
                        if (KingOnTable != null && KingOnTable[ik] != null && KingOnTable[ik].KingThinking != null && KingOnTable[ik].KingThinking[0] != null
                            )
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                Do = FullGameThinkingTreeKing(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy);
                            }
                        }
                    }//);
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeKingGray:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeSoldierBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {

                
                    ////Parallel.For(SodierMidle, SodierHigh, ik =>
                    for (var ik = SodierMidle; ik < SodierHigh; ik++)
                    {
                        if (SolderesOnTable != null && SolderesOnTable[ik] != null && SolderesOnTable[ik].SoldierThinking != null && SolderesOnTable[ik].SoldierThinking[0] != null
                            )
                        {
                            //Soldier.
                            Object O = new Object();
                            lock (O)
                            {
                                Do = FullGameThinkingTreeSoldier(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy);
                            }
                        }
                    }//);
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeSoldierBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeElephantBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {

                //Elephant
                
                    ////Parallel.For(ElefantMidle, ElefantHigh, ik =>
                    for (var ik = ElefantMidle; ik < ElefantHigh; ik++)
                    {
                        if (ElephantOnTable != null && ElephantOnTable[ik] != null && ElephantOnTable[ik].ElefantThinking != null && ElephantOnTable[ik].ElefantThinking[0] != null
                            )
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                Do = FullGameThinkingTreeElephant(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy);
                            }
                        }
                    }//);
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeElephantBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeHourseBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                //Hourse.
                
                    ////Parallel.For(HourseMidle, HourseHight, ik =>
                    for (var ik = HourseMidle; ik < HourseHight; ik++)
                    {
                        if (HoursesOnTable != null && HoursesOnTable[ik] != null && HoursesOnTable[ik].HourseThinking != null && HoursesOnTable[ik].HourseThinking[0] != null
                            )
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                Do = FullGameThinkingTreeHourse(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy);
                            }
                        }
                    }//);
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeHourseBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeCastleBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                //Castles.
                
                    ////Parallel.For(CastleMidle, CastleHigh, ik =>
                    for (var ik = CastleMidle; ik < CastleHigh; ik++)
                    {
                        if (CastlesOnTable != null && CastlesOnTable[ik] != null && CastlesOnTable[ik].CastleThinking != null && CastlesOnTable[ik].CastleThinking[0] != null
                            )
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                Do = FullGameThinkingTreeCastle(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy);
                            }
                        }
                    }//);
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeCastleBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeMinisterBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {

                //Minister.
                
                    ////Parallel.For(MinisterMidle, MinisterHigh, ik =>
                    for (var ik = MinisterMidle; ik < MinisterHigh; ik++)
                    {
                        if (MinisterOnTable != null && MinisterOnTable[ik] != null && MinisterOnTable[ik].MinisterThinking != null && MinisterOnTable[ik].MinisterThinking[0] != null
                            )
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                Do = FullGameThinkingTreeMinister(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy);
                            }
                        }
                    }//);
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeMinisterBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeKingBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                //King.
                
                    ////Parallel.For(KingMidle, KingHigh, ik =>
                    for (var ik = KingMidle; ik < KingHigh; ik++)
                    {

                        if (KingOnTable != null && KingOnTable[ik] != null && KingOnTable[ik].KingThinking != null && KingOnTable[ik].KingThinking[0] != null
                            )
                        {
                            Object O = new Object();
                            lock (O)
                            {
                                Do = FullGameThinkingTreeKing(ik, a, Order, iAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy);
                            }
                        }

                    }//);
               
                {
                    //if (JI == 0)
                    //if (JI == 1)
                    //if (JI == 2)
                    //if (JI == 3)
                    //if (JI == 4)
                    //if (JI == 5)
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeKingBrown:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTree(int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //List<Task> tH = new List<Task>();
            bool Do = false;
            //Initiatye Variables.
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;

            Color a;
            if (Order== 1)
                a = Color.Gray;
            else
                a = Color.Brown;
            ////Order *= -1;
            //Index = -1;
            //jindex = -1;
            //Kind =
            Object O = new Object();
            lock (O)
            {
                if (AllDraw.Blitz)
                    FullGameMakimgBlitz(ref Index, ref jindex, Order, LeafAStarGreedy);
            }
            /*Object OO = new Object();
            lock (OO)
            {

                if (Order == -1)
                {
                    //Index[0] = -1;
                    //Soldeir
                    //Initiatye Variables.
                    int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
                    int Ord1 = OrderP;
                    Color a1 = a;
                    int iAStarGreedy1 = iAStarGreedy;
                    var array1 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeSoldierGray(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND));
                    //array1.Start();
                    //Object tttt1 = new Object(); lock (tttt1) { TH.Add(array1); }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;

                    int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
                    int Ord2 = Order;
                    Color a2 = a;
                    int iAStarGreedy2 = iAStarGreedy;
                    var array2 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeElephantGray(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND));
                    //array2.Start();
                   //Object tttt2 = new Object(); lock (tttt2) { TH.Add(array2); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;

                    int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
                    int Ord3 = Order;
                    Color a3 = a;
                    int iAStarGreedy3 = iAStarGreedy;
                    var array3 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeHourseGray(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND));
                    ///array3.Start();
                    //Object tttt3 = new Object(); lock (tttt3) { TH.Add(array3); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;

                    int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
                    int Ord4 = Order;
                    Color a4 = a;
                    int iAStarGreedy4 = iAStarGreedy;
                    var array4 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeCastleGray(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND));
                    //array4.Start();
                    //Object tttt4 = new Object(); lock (tttt4) { TH.Add(array4); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;
                    int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
                    int Ord5 = Order;
                    Color a5 = a;
                    int iAStarGreedy5 = iAStarGreedy;
                    var array5 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeMinisterGray(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND));
                    //array5.Start();
                    //Object tttt5 = new Object(); lock (tttt5) { TH.Add(array5); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;
                    int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
                    int Ord6 = Order;
                    Color a6 = a;
                    int iAStarGreedy6 = iAStarGreedy;
                    var array6 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeKingGray(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND));
                    //array6.Start();
                    //Object tttt6 = new Object(); lock (tttt6) { TH.Add(array6); }

                }
                //For Brown Order Blitz Game Calculate Maximum Table Inclusive AStarGreedy First Game Search.
                else
                {
                    int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
                    int Ord1 = OrderP;
                    Color a1 = a;
                    int iAStarGreedy1 = iAStarGreedy;
                    var array1 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeSoldierBrown(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND));
                    //array1.Start();
                    //Object tttt1 = new Object(); lock (tttt1) { TH.Add(array1); }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;

                    int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
                    int Ord2 = Order;
                    Color a2 = a;
                    int iAStarGreedy2 = iAStarGreedy;
                    var array2 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeElephantBrown(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND));
                    //array2.Start();
                   //Object tttt2 = new Object(); lock (tttt2) { TH.Add(array2); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;

                    int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
                    int Ord3 = Order;
                    Color a3 = a;
                    int iAStarGreedy3 = iAStarGreedy;
                    var array3 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeHourseBrown(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND));
                    ///array3.Start();
                    //Object tttt3 = new Object(); lock (tttt3) { TH.Add(array3); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;

                    int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
                    int Ord4 = Order;
                    Color a4 = a;
                    int iAStarGreedy4 = iAStarGreedy;
                    var array4 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeCastleBrown(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND));
                    //array4.Start();
                    //Object tttt4 = new Object(); lock (tttt4) { TH.Add(array4); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;
                    int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
                    int Ord5 = Order;
                    Color a5 = a;
                    int iAStarGreedy5 = iAStarGreedy;
                    var array5 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeMinisterBrown(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND));
                    //array5.Start();
                    //Object tttt5 = new Object(); lock (tttt5) { TH.Add(array5); }

                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order== 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    //Order *= -1;
                    //ChessRules.CurrentOrder *= -1;
                    int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
                    int Ord6 = Order;
                    Color a6 = a;
                    int iAStarGreedy6 = iAStarGreedy;
                    var array6 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeKingBrown(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND));
                    //array6.Start();
                    //Object tttt6 = new Object(); lock (tttt6) { TH.Add(array6); }
                }
                Parallel.ForEach(TH, items => Task.WaitAny(items));
            }
            */
            if (Order== 1)
            {
                //Index[0] = -1;
                //Soldeir
                //Initiatye Variables.               

                var output = Task.Factory.StartNew(() =>
                 Parallel.Invoke(() =>

                 {
                     Object O1 = new Object();
                     lock (O1)
                     {
                         if (Order== 1)
                             a = Color.Gray;
                         else
                             a = Color.Brown;
                         int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
                         int Ord1 = OrderP;
                         Color a1 = a;
                         int iAStarGreedy1 = iAStarGreedy;
                         Do |= this.FullGameThinkingTreeSoldierGray(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy);
                         //var array1 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeSoldierGray(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND));
                         //array1.Start();
                         //Object tttt1 = new Object(); lock (tttt1) { TH.Add(array1); }

                         Order = DummyOrder;
                         ChessRules.CurrentOrder = DummyCurrentOrder;
                     }
                 }, () =>
                 {
                     Object O1 = new Object();
                     lock (O1)
                     {
                         if (Order== 1)
                             a = Color.Gray;
                         else
                             a = Color.Brown;
                         //Order *= -1;
                         //ChessRules.CurrentOrder *= -1;

                         int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
                         int Ord2 = Order;
                         Color a2 = a;
                         int iAStarGreedy2 = iAStarGreedy;
                         Do |= this.FullGameThinkingTreeElephantGray(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy);
                         //var array2 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeElephantGray(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND));
                         //array2.Start();
                         //Object tttt2 = new Object(); lock (tttt2) { TH.Add(array2); }

                         //Initiatye Variables.
                         Order = DummyOrder;
                         ChessRules.CurrentOrder = DummyCurrentOrder;
                     }

                 }, () =>
                 {
                     Object O1 = new Object();
                     lock (O1)
                     {
                         if (Order== 1)
                             a = Color.Gray;
                         else
                             a = Color.Brown;
                         //Order *= -1;
                         //ChessRules.CurrentOrder *= -1;

                         int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
                         int Ord3 = Order;
                         Color a3 = a;
                         int iAStarGreedy3 = iAStarGreedy;
                         Do |= this.FullGameThinkingTreeHourseGray(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy);
                         //var array3 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeHourseGray(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND));
                         ///array3.Start();
                         //Object tttt3 = new Object(); lock (tttt3) { TH.Add(array3); }

                         //Initiatye Variables.
                         Order = DummyOrder;
                         ChessRules.CurrentOrder = DummyCurrentOrder;
                     }
                 }, () =>
                 {
                     Object O1 = new Object();
                     lock (O1)
                     {
                         if (Order== 1)
                             a = Color.Gray;
                         else
                             a = Color.Brown;
                         //Order *= -1;
                         //ChessRules.CurrentOrder *= -1;

                         int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
                         int Ord4 = Order;
                         Color a4 = a;
                         int iAStarGreedy4 = iAStarGreedy;
                         Do |= this.FullGameThinkingTreeCastleGray(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy);
                         //var array4 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeCastleGray(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND));
                         //array4.Start();
                         //Object tttt4 = new Object(); lock (tttt4) { TH.Add(array4); }

                         //Initiatye Variables.
                         Order = DummyOrder;
                         ChessRules.CurrentOrder = DummyCurrentOrder;
                     }
                 }, () =>
                 {
                     Object O1 = new Object();
                     lock (O1)
                     {
                         if (Order== 1)
                             a = Color.Gray;
                         else
                             a = Color.Brown;
                         //Order *= -1;
                         //ChessRules.CurrentOrder *= -1;
                         int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
                         int Ord5 = Order;
                         Color a5 = a;
                         int iAStarGreedy5 = iAStarGreedy;
                         Do |= this.FullGameThinkingTreeMinisterGray(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy);
                         //var array5 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeMinisterGray(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND));
                         //array5.Start();
                         //Object tttt5 = new Object(); lock (tttt5) { TH.Add(array5); }

                         //Initiatye Variables.
                         Order = DummyOrder;
                         ChessRules.CurrentOrder = DummyCurrentOrder;
                     }
                 }, () =>
                 {
                     Object O1 = new Object();
                     lock (O1)
                     {
                         if (Order== 1)
                             a = Color.Gray;
                         else
                             a = Color.Brown;
                         //Order *= -1;
                         //ChessRules.CurrentOrder *= -1;
                         int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
                         int Ord6 = Order;
                         Color a6 = a;
                         int iAStarGreedy6 = iAStarGreedy;
                         Do |= this.FullGameThinkingTreeKingGray(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy);
                         //var array6 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeKingGray(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND));
                         //array6.Start();
                         //Object tttt6 = new Object(); lock (tttt6) { TH.Add(array6); }
                         Order = DummyOrder;
                         ChessRules.CurrentOrder = DummyCurrentOrder;
                     }
                 })
                );
                output.Wait();
            }
            //For Brown Order Blitz Game Calculate Maximum Table Inclusive AStarGreedy First Game Search.
            else
            {
                var output = Task.Factory.StartNew(() =>
                Parallel.Invoke(() =>
                {
                    Object O1 = new Object();
                    lock (O1)
                    {
                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
                        int Ord1 = OrderP;
                        Color a1 = a;
                        int iAStarGreedy1 = iAStarGreedy;
                        Do |= this.FullGameThinkingTreeSoldierBrown(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy);
                        //var array1 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeSoldierBrown(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND));
                        //array1.Start();
                        //Object tttt1 = new Object(); lock (tttt1) { TH.Add(array1); }

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                    }
                }, () =>
                {
                    Object O1 = new Object();
                    lock (O1)
                    {
                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;

                        int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
                        int Ord2 = Order;
                        Color a2 = a;
                        int iAStarGreedy2 = iAStarGreedy;
                        Do |= this.FullGameThinkingTreeElephantBrown(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy);
                        //var array2 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeElephantBrown(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND));
                        //array2.Start();
                        //Object tttt2 = new Object(); lock (tttt2) { TH.Add(array2); }

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                    }
                }, () =>
                {
                    Object O1 = new Object();
                    lock (O1)
                    {
                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;

                        int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
                        int Ord3 = Order;
                        Color a3 = a;
                        int iAStarGreedy3 = iAStarGreedy;
                        Do |= this.FullGameThinkingTreeHourseBrown(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy);
                        //var array3 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeHourseBrown(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND));
                        ///array3.Start();
                        //Object tttt3 = new Object(); lock (tttt3) { TH.Add(array3); }

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                    }
                }, () =>
                {
                    Object O1 = new Object();
                    lock (O1)
                    {
                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;

                        int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
                        int Ord4 = Order;
                        Color a4 = a;
                        int iAStarGreedy4 = iAStarGreedy;
                        Do |= this.FullGameThinkingTreeCastleBrown(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy);
                        //var array4 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeCastleBrown(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND));
                        //array4.Start();
                        //Object tttt4 = new Object(); lock (tttt4) { TH.Add(array4); }

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                    }
                }, () =>
                {
                    Object O1 = new Object();
                    lock (O1)
                    {
                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
                        int Ord5 = Order;
                        Color a5 = a;
                        int iAStarGreedy5 = iAStarGreedy;
                        Do |= this.FullGameThinkingTreeMinisterBrown(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy);
                        //var array5 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeMinisterBrown(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND));
                        //array5.Start();
                        //Object tttt5 = new Object(); lock (tttt5) { TH.Add(array5); }

                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                    }
                }, () =>
                {
                    Object O1 = new Object();
                    lock (O1)
                    {
                        if (Order== 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        //Order *= -1;
                        //ChessRules.CurrentOrder *= -1;
                        int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
                        int Ord6 = Order;
                        Color a6 = a;
                        int iAStarGreedy6 = iAStarGreedy;
                        Do |= this.FullGameThinkingTreeKingBrown(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy);
                        //var array6 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeKingBrown(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND));
                        //array6.Start();
                        //Object tttt6 = new Object(); lock (tttt6) { TH.Add(array6); }
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                    }
                })
                );
                output.Wait();
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTree:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        bool FullGameThinkingTreeObject(int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //List<Task> tH = new List<Task>();
            bool Do = false;
            //Initiatye Variables.
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;

            Color a;
            if (Order== 1)
                a = Color.Gray;
            else
                a = Color.Brown;
            ////Order *= -1;
            //Index = -1;
            //jindex = -1;
            //Kind =
            Object O = new Object();
            lock (O)
            {
                if (AllDraw.Blitz)
                    FullGameMakimgBlitz(ref Index, ref jindex, Order, LeafAStarGreedy);
            }
            if (Order== 1)
            {
                var output = Task.Factory.StartNew(() =>
                Parallel.For(0, MaxGrayMidle(), i =>
                {
                    Parallel.Invoke(() =>

                      {
                          Object ooo = new Object();
                          lock (ooo)
                          {
                              if (i < SodierMidle)
                              {
                                  Object O1 = new Object();
                                  lock (O1)
                                  {
                                      if (Order== 1)
                                          a = Color.Gray;
                                      else
                                          a = Color.Brown;
                                      int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
                                      int Ord1 = OrderP;
                                      Color a1 = a;
                                      int iAStarGreedy1 = iAStarGreedy;
                                      int i1 = i;
                                      Do |= FullGameThinkingTreeSoldier(i1, a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy);
                                      //var array1 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeSoldierGray(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND));
                                      //array1.Start();
                                      //Object tttt1 = new Object(); lock (tttt1) { TH.Add(array1); }

                                      Order = DummyOrder;
                                      ChessRules.CurrentOrder = DummyCurrentOrder;
                                  }
                              }
                          }
                      }, () =>
                      {
                          Object ooo = new Object();
                          lock (ooo)
                          {

                              if (i < ElefantMidle)
                              {
                                  Object O1 = new Object();
                                  lock (O1)
                                  {
                                      if (Order== 1)
                                          a = Color.Gray;
                                      else
                                          a = Color.Brown;
                                      //Order *= -1;
                                      //ChessRules.CurrentOrder *= -1;

                                      int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
                                      int Ord2 = Order;
                                      Color a2 = a;
                                      int iAStarGreedy2 = iAStarGreedy;
                                      int i2 = i;
                                      Do |= this.FullGameThinkingTreeElephant(i2, a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy);
                                      //Initiatye Variables.
                                      Order = DummyOrder;
                                      ChessRules.CurrentOrder = DummyCurrentOrder;
                                  }
                              }
                          }
                      }, () =>
                      {
                          Object ooo = new Object();
                          lock (ooo)
                          {

                              if (i < HourseMidle)
                              {
                                  Object O1 = new Object();
                                  lock (O1)
                                  {
                                      if (Order== 1)
                                          a = Color.Gray;
                                      else
                                          a = Color.Brown;
                                      //Order *= -1;
                                      //ChessRules.CurrentOrder *= -1;

                                      int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
                                      int Ord3 = Order;
                                      Color a3 = a;
                                      int iAStarGreedy3 = iAStarGreedy;
                                      int i3 = i;
                                      Do |= this.FullGameThinkingTreeHourse(i3, a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy);
                                      //Initiatye Variables.
                                      Order = DummyOrder;
                                      ChessRules.CurrentOrder = DummyCurrentOrder;
                                  }
                              }
                          }
                      }, () =>
                      {
                          Object ooo = new Object();
                          lock (ooo)
                          {

                              if (i < CastleMidle)
                              {
                                  Object O1 = new Object();
                                  lock (O1)
                                  {
                                      if (Order== 1)
                                          a = Color.Gray;
                                      else
                                          a = Color.Brown;
                                      //Order *= -1;
                                      //ChessRules.CurrentOrder *= -1;

                                      int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
                                      int Ord4 = Order;
                                      Color a4 = a;
                                      int iAStarGreedy4 = iAStarGreedy;
                                      int i4 = i;
                                      Do |= this.FullGameThinkingTreeCastle(i4, a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy);
                                      //Initiatye Variables.
                                      Order = DummyOrder;
                                      ChessRules.CurrentOrder = DummyCurrentOrder;
                                  }
                              }
                          }
                      }, () =>
                      {
                          Object ooo = new Object();
                          lock (ooo)
                          {

                              if (i < MinisterMidle)
                              {
                                  Object O1 = new Object();
                                  lock (O1)
                                  {
                                      if (Order== 1)
                                          a = Color.Gray;
                                      else
                                          a = Color.Brown;
                                      //Order *= -1;
                                      //ChessRules.CurrentOrder *= -1;
                                      int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
                                      int Ord5 = Order;
                                      Color a5 = a;
                                      int iAStarGreedy5 = iAStarGreedy;
                                      int i5 = i;
                                      Do |= this.FullGameThinkingTreeMinister(i5, a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy);
                                      //Initiatye Variables.
                                      Order = DummyOrder;
                                      ChessRules.CurrentOrder = DummyCurrentOrder;
                                  }
                              }
                          }
                      }, () =>
                      {
                          Object ooo = new Object();
                          lock (ooo)
                          {

                              if (i < KingMidle)

                              {
                                  Object O1 = new Object();
                                  lock (O1)
                                  {
                                      if (Order== 1)
                                          a = Color.Gray;
                                      else
                                          a = Color.Brown;
                                      //Order *= -1;
                                      //ChessRules.CurrentOrder *= -1;
                                      int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
                                      int Ord6 = Order;
                                      Color a6 = a;
                                      int iAStarGreedy6 = iAStarGreedy;
                                      int i6 = i;
                                      Do |= this.FullGameThinkingTreeKing(i6, a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy);
                                      Order = DummyOrder;
                                      ChessRules.CurrentOrder = DummyCurrentOrder;
                                  }
                              }
                          }
                      });
                })
                );
                output.Wait();

            }
            //For Brown Order Blitz Game Calculate Maximum Table Inclusive AStarGreedy First Game Search.
            else
            {
                var output = Task.Factory.StartNew(() =>
                Parallel.For(MinBrownMidle(), MaxGrayMidle(), i =>
                {
                    Parallel.Invoke(() =>
                {
                    Object ooo = new Object();
                    lock (ooo)
                    {

                        if (i >= SodierMidle && i < SodierHigh)
                        {

                            Object O1 = new Object();
                            lock (O1)
                            {
                                if (Order== 1)
                                    a = Color.Gray;
                                else
                                    a = Color.Brown;
                                int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
                                int Ord1 = OrderP;
                                Color a1 = a;
                                int iAStarGreedy1 = iAStarGreedy;
                                int i1 = i;
                                Do |= this.FullGameThinkingTreeSoldier(i1, a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy);
                                Order = DummyOrder;
                                ChessRules.CurrentOrder = DummyCurrentOrder;
                            }
                        }
                    }
                }, () =>
                {
                    if (i >= ElefantMidle && i < ElefantHigh)
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {
                            if (Order== 1)
                                a = Color.Gray;
                            else
                                a = Color.Brown;
                            int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
                            int Ord2 = Order;
                            Color a2 = a;
                            int iAStarGreedy2 = iAStarGreedy;
                            int i2 = i;
                            Do |= this.FullGameThinkingTreeElephant(i2, a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy);
                            //Initiatye Variables.
                            Order = DummyOrder;
                            ChessRules.CurrentOrder = DummyCurrentOrder;
                        }
                    }
                }, () =>
                {
                    if (i >= HourseMidle && i < HourseHight)
                    {
                        Object O1 = new Object();
                        lock (O1)
                        {
                            if (Order== 1)
                                a = Color.Gray;
                            else
                                a = Color.Brown;

                            int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
                            int Ord3 = Order;
                            Color a3 = a;
                            int iAStarGreedy3 = iAStarGreedy;
                            int i3 = i;
                            Do |= this.FullGameThinkingTreeHourse(i3, a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy);
                            //Initiatye Variables.
                            Order = DummyOrder;
                            ChessRules.CurrentOrder = DummyCurrentOrder;
                        }
                    }
                }, () =>
                {
                    if (i >= CastleMidle && i < CastleHigh)
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {
                            if (Order== 1)
                                a = Color.Gray;
                            else
                                a = Color.Brown;
                            int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
                            int Ord4 = Order;
                            Color a4 = a;
                            int iAStarGreedy4 = iAStarGreedy;
                            int i4 = i;
                            Do |= this.FullGameThinkingTreeCastle(i4, a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy);
                            //Initiatye Variables.
                            Order = DummyOrder;
                            ChessRules.CurrentOrder = DummyCurrentOrder;
                        }
                    }
                }, () =>
                {
                    if (i >= MinisterMidle && i < MinisterHigh)
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {
                            if (Order== 1)
                                a = Color.Gray;
                            else
                                a = Color.Brown;
                            int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
                            int Ord5 = Order;
                            Color a5 = a;
                            int iAStarGreedy5 = iAStarGreedy;
                            int i5 = i;
                            Do |= this.FullGameThinkingTreeMinister(i5, a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy);
                            //Initiatye Variables.
                            Order = DummyOrder;
                            ChessRules.CurrentOrder = DummyCurrentOrder;
                        }
                    }

                }, () =>
                {
                    if (i >= KingMidle && i < KingHigh)
                    {
                        Object ooo = new Object();
                        lock (ooo)
                        {
                            if (Order== 1)
                                a = Color.Gray;
                            else
                                a = Color.Brown;
                            if (Order== 1)
                                a = Color.Gray;
                            else
                                a = Color.Brown;
                            int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
                            int Ord6 = Order;
                            Color a6 = a;
                            int iAStarGreedy6 = iAStarGreedy;
                            int i6 = i;
                            Do |= this.FullGameThinkingTreeKing(i6, a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy);
                            Order = DummyOrder;
                            ChessRules.CurrentOrder = DummyCurrentOrder;
                        }
                    }
                });
                })
                );
                output.Wait();
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FullGameThinkingTreeObject:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Do;
        }
        int[,] CloneATable(int[,] Tab)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int[,] Table = new int[8, 8];
            for (var i = 0; i < 8; i++)
                for (var j = 0; j < 8; j++)
                    Table[i, j] = Tab[i, j];
            ////{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CloneATable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Table;
        }
        int MaxOfSixHuristic(int _1, int _2, int _3, int _4, int _5, int _6)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int[] LessB = new int[6];
            LessB[0] = _1;
            LessB[1] = _2;
            LessB[2] = _3;
            LessB[3] = _4;
            LessB[4] = _5;
            LessB[5] = _6;

            int Value = -1;
            int Les = Int32.MinValue;
            for (var i = 0; i < 6; i++)
            {
                if (LessB[i] > Les)
                {
                    Les = LessB[i];
                    Value = i;
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("MaxOfSixHuristic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Value;
        }
        int MinOfSixHuristic(int _1, int _2, int _3, int _4, int _5, int _6)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            int[] LessB = new int[6];
            LessB[0] = _1;
            LessB[1] = _2;
            LessB[2] = _3;
            LessB[3] = _4;
            LessB[4] = _5;
            LessB[5] = _6;

            int Value = -1;
            int Les = Int32.MaxValue;
            for (var i = 0; i < 6; i++)
            {
                if (LessB[i] < Les)
                {
                    Les = LessB[i];
                    Value = i;
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("MinOfSixHuristic:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Value;
        }
        //best movement indexes founder method.
        List<List<int>> FoundOfBestMovments(int AStarGreedy, ref List<int> i, ref List<int> j, ref List<int> k, AllDraw Dummy, Color a, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //initiate local variables.
            List<List<int>> p = new List<List<int>>();

            for (var ii = 0; ii < 6; ii++)
            {
                List<int> pl = new List<int>();
                p.Add(pl);

                Less = Int32.MinValue;
            }
            List<AllDraw> DummyList = new List<AllDraw>();
            DummyList.Add(Dummy);
            MaxHuristicAStarGreedytBackWard.Clear();
            //found best movment depend of max huristic.
            Dummy.HuristicAStarGreedySearch(0, a, Order, false);
            //proccess from a stored global variable decicion making.
            if (MaxHuristicAStarGreedytBackWard[0][1] != -1)//soldier.
            {
                i.Add(MaxHuristicAStarGreedytBackWard[0][2]);
                j.Add(MaxHuristicAStarGreedytBackWard[0][3]);
                k.Add(MaxHuristicAStarGreedytBackWard[0][4]);
                p[0].Add(MaxHuristicAStarGreedytBackWard[0][2]);
            }
            else if (MaxHuristicAStarGreedytBackWard[0][5] != -1)//Elephant
            {
                i.Add(MaxHuristicAStarGreedytBackWard[0][6]);
                j.Add(MaxHuristicAStarGreedytBackWard[0][7]);
                k.Add(MaxHuristicAStarGreedytBackWard[0][8]);
                p[1].Add(MaxHuristicAStarGreedytBackWard[0][6]);
            }
            else if (MaxHuristicAStarGreedytBackWard[0][9] != -1)//Hourse
            {
                i.Add(MaxHuristicAStarGreedytBackWard[0][10]);
                j.Add(MaxHuristicAStarGreedytBackWard[0][11]);
                k.Add(MaxHuristicAStarGreedytBackWard[0][12]);
                p[2].Add(MaxHuristicAStarGreedytBackWard[0][10]);
            }
            else if (MaxHuristicAStarGreedytBackWard[0][13] != -1)//Castles.
            {
                i.Add(MaxHuristicAStarGreedytBackWard[0][14]);
                j.Add(MaxHuristicAStarGreedytBackWard[0][15]);
                k.Add(MaxHuristicAStarGreedytBackWard[0][16]);
                p[3].Add(MaxHuristicAStarGreedytBackWard[0][14]);
            }
            else if (MaxHuristicAStarGreedytBackWard[0][17] != -1)//Minister
            {
                i.Add(MaxHuristicAStarGreedytBackWard[0][18]);
                j.Add(MaxHuristicAStarGreedytBackWard[0][19]);
                k.Add(MaxHuristicAStarGreedytBackWard[0][20]);
                p[4].Add(MaxHuristicAStarGreedytBackWard[0][18]);
            }
            else if (MaxHuristicAStarGreedytBackWard[0][21] != -1)//King.
            {
                i.Add(MaxHuristicAStarGreedytBackWard[0][22]);
                j.Add(MaxHuristicAStarGreedytBackWard[0][23]);
                k.Add(MaxHuristicAStarGreedytBackWard[0][24]);
                p[5].Add(MaxHuristicAStarGreedytBackWard[0][22]);
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("FoundOfBestMovments:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;

            //not found
            return p;
        }

        //Copying of Items of Enemy Non Move and Current Moved.
        public AllDraw CopyRemeiningItems(AllDraw ADummy, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Initiate Local Variables.
            AllDraw Dummy = new AllDraw(OrderPlate, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);
            Dummy.TableList.Add(TableList[0]);
            Dummy.SolderesOnTable = new DrawSoldier[SodierHigh];
            Dummy.ElephantOnTable = new DrawElefant[ElefantHigh];
            Dummy.HoursesOnTable = new DrawHourse[HourseHight];
            Dummy.CastlesOnTable = new DrawCastle[CastleHigh];
            Dummy.MinisterOnTable = new DrawMinister[MinisterHigh];
            Dummy.KingOnTable = new DrawKing[KingHigh];
            //For All Sodiers Movments.
            for (var i = 0; i < SodierHigh; i++)
            {
                
                    //Construction of Current Solders. 
                    Dummy.SolderesOnTable[i] = new DrawSoldier(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, SolderesOnTable[i].Row, SolderesOnTable[i].Column, SolderesOnTable[i].color, CloneATable(SolderesOnTable[i].Table), SolderesOnTable[i].Order, false, SolderesOnTable[i].Current);
               
            }
            //For All Elephant Objects.
            for (var i = 0; i < ElefantHigh; i++)
            {
                
                    //Construction of Curren Elephant.
                    Dummy.ElephantOnTable[i] = new DrawElefant(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ElephantOnTable[i].Row, ElephantOnTable[i].Column, ElephantOnTable[i].color, CloneATable(ElephantOnTable[i].Table), ElephantOnTable[i].Order, false, ElephantOnTable[i].Current);
               
            }
            //for All Hourse Objects.
            for (var i = 0; i < HourseHight; i++)
            {
                
                    //Construction of Hourse Objects.
                    Dummy.HoursesOnTable[i] = new DrawHourse(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, HoursesOnTable[i].Row, HoursesOnTable[i].Column, HoursesOnTable[i].color, CloneATable(HoursesOnTable[i].Table), HoursesOnTable[i].Order, false, HoursesOnTable[i].Current);
               
            }
            //For All Castles Objects.
            for (var i = 0; i < CastleHigh; i++)
            {
                
                    //Construction of Castles Objects.
                    Dummy.CastlesOnTable[i] = new DrawCastle(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, CastlesOnTable[i].Row, CastlesOnTable[i].Column, CastlesOnTable[i].color, CloneATable(CastlesOnTable[i].Table), CastlesOnTable[i].Order, false, CastlesOnTable[i].Current);
               
            }
            //For All Minister Objects.
            for (var i = 0; i < MinisterHigh; i++)
            {
                
                    //Construction of Current Minister.
                    Dummy.MinisterOnTable[i] = new DrawMinister(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, MinisterOnTable[i].Row, MinisterOnTable[i].Column, MinisterOnTable[i].color, CloneATable(MinisterOnTable[i].Table), MinisterOnTable[i].Order, false, MinisterOnTable[i].Current);
               
            }
            //For All King Objects.
            for (var i = 0; i < KingHigh; i++)
            {
                
                    //Construction of Kings Objects.
                    Dummy.KingOnTable[i] = new DrawKing(CurrentAStarGredyMax, MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, KingOnTable[i].Row, KingOnTable[i].Column, KingOnTable[i].color, CloneATable(KingOnTable[i].Table), KingOnTable[i].Order, false, KingOnTable[i].Current);
               
            }
            //Gray Order.
            if (Order== 1)
            {
                //For Gray Soders Objects.
                for (var i = 0; i < SodierMidle; i++)
                {
                    
                        //Clone a Movments.
                        ADummy.SolderesOnTable[i].Clone(ref Dummy.SolderesOnTable[i]);
                   
                }
                //For Gray Elephant.
                for (var i = 0; i < ElefantMidle; i++)
                {
                    
                        //Clone a  Movments.
                        ADummy.ElephantOnTable[i].Clone(ref Dummy.ElephantOnTable[i]);
                   
                }
                //For Gray Hourses.
                for (var i = 0; i < HourseMidle; i++)
                {
                    
                        //Clone a Movments.
                        ADummy.HoursesOnTable[i].Clone(ref Dummy.HoursesOnTable[i]);
                   
                }
                //For Gray Castles.
                for (var i = 0; i < CastleMidle; i++)
                {
                    
                        //Clone a Movments.
                        ADummy.CastlesOnTable[i].Clone(ref Dummy.CastlesOnTable[i]);
                   
                }
                //For Gray Ministers.
                for (var i = 0; i < MinisterMidle; i++)
                {
                    
                        //Clone a Movments.
                        ADummy.MinisterOnTable[i].Clone(ref Dummy.MinisterOnTable[i]);
                   
                }
                //For Gray King.
                for (var i = 0; i < KingMidle; i++)
                {
                    
                        //Clone a Movments.
                        ADummy.KingOnTable[i].Clone(ref Dummy.KingOnTable[i]);
                   
                }
                //For All Solders.
            }
            else//For Order Brown.
            {
                {
                    //For Brown Solders.
                    for (var i = SodierMidle; i < SodierHigh; i++)
                    {
                        
                            //Clone a Movments.
                            ADummy.SolderesOnTable[i].Clone(ref Dummy.SolderesOnTable[i]);
                       
                    }
                    //For All Brown Elephants.
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        
                            //Clone a Enemy.
                            ADummy.ElephantOnTable[i].Clone(ref Dummy.ElephantOnTable[i]);
                       
                    }
                    //For All Brown Hourses.
                    for (var i = HourseMidle; i < HourseHight; i++)
                    {
                        
                            //Clone a Enemy.
                            ADummy.HoursesOnTable[i].Clone(ref Dummy.HoursesOnTable[i]);
                       
                    }
                    //For Brown Castles. 
                    for (var i = CastleMidle; i < CastleHigh; i++)
                    {
                        
                            //Clone a Movments.
                            ADummy.CastlesOnTable[i].Clone(ref Dummy.CastlesOnTable[i]);
                       
                    }
                    //For Gray Minsters.
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        
                            //Clone a Enemy.
                            ADummy.MinisterOnTable[i].Clone(ref Dummy.MinisterOnTable[i]);
                       
                    }
                    //For Brown Kings.
                    for (var i = KingMidle; i < KingHigh; i++)
                    {
                        
                            //Clone a Enemy.
                            ADummy.KingOnTable[i].Clone(ref Dummy.KingOnTable[i]);
                       
                    }
                }

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CopyRemeiningItems:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            //Return Constructed Tables.
            return Dummy;


        }

        public bool TableZero(int[,] Ta)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            bool Zerro = true;
            for (var i = 0; i < 8; i++)
                for (var j = 0; j < 8; j++)
                    if (Ta[i, j] != 0)
                        Zerro = false;
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("TableZero:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return Zerro;
        }
        void CheckedMateConfiguratiionSoldier(int Order, int i, bool Regrad)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            for (var j = 0; j < SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder.Count; j++)
            {
                
                    if (SolderesOnTable[i].SoldierThinking[0].LearningVarsObject.Count == SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder.Count)
                        if (SolderesOnTable[i].SoldierThinking[0].LearningVarsObject[j][1] && (!SolderesOnTable[i].SoldierThinking[0].LearningVarsObject[j][4]))
                        {
                            SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].Initiate();
                            //if(Regrad)
                            //SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].LearningAlgorithmRegard();
                            //else
                            if (!Regrad)
                                SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].LearningAlgorithmPenalty();
                            SolderesOnTable[i].SoldierThinking[0].HuristicPenaltyValuePerform(SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j], Order, ref SolderesOnTable[i].SoldierThinking[0].HuristicListSolder[j][0], true);
                        }
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CheckedMateConfiguratiionSoldier:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void CheckedMateConfiguratiionElephant(int Order, int i, bool Regrad)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            for (var j = 0; j < ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant.Count; j++)
            {
                
                    if (ElephantOnTable[i].ElefantThinking[0].LearningVarsObject.Count == ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant.Count)
                        if (ElephantOnTable[i].ElefantThinking[0].LearningVarsObject[j][1] && (!ElephantOnTable[i].ElefantThinking[0].LearningVarsObject[j][4]))
                        {
                            ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].Initiate();
                            //if(Regrad)
                            //ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmRegard();
                            //else
                            if (!Regrad)
                                ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmPenalty();
                            ElephantOnTable[i].ElefantThinking[0].HuristicPenaltyValuePerform(ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j], Order, ref ElephantOnTable[i].ElefantThinking[0].HuristicListElefant[j][0], true);
                        }
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CheckedMateConfiguratiionElephant:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void CheckedMateConfiguratiionHourse(int Order, int i, bool Regrad)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            for (var j = 0; j < HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse.Count; j++)
            {
                
                    if (HoursesOnTable[i].HourseThinking[0].LearningVarsObject.Count == HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse.Count)
                        if (HoursesOnTable[i].HourseThinking[0].LearningVarsObject[j][1] && (!HoursesOnTable[i].HourseThinking[0].LearningVarsObject[j][4]))
                        {
                            HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].Initiate();
                            //if(Regrad)
                            //HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmRegard();
                            //else
                            if (!Regrad)
                                HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmPenalty();
                            HoursesOnTable[i].HourseThinking[0].HuristicPenaltyValuePerform(HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j], Order, ref HoursesOnTable[i].HourseThinking[0].HuristicListHourse[j][0], true);
                        }
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CheckedMateConfiguratiionHourse:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }

        void CheckedMateConfiguratiionCastle(int Order, int i, bool Regrad)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            for (var j = 0; j < CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle.Count; j++)
            {
                
                    if (CastlesOnTable[i].CastleThinking[0].LearningVarsObject.Count == CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle.Count)
                        if (CastlesOnTable[i].CastleThinking[0].LearningVarsObject[j][1] && (!CastlesOnTable[i].CastleThinking[0].LearningVarsObject[j][4]))
                        {
                            CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].Initiate();
                            //if(Regrad)
                            //CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmRegard();
                           //else
                            if (!Regrad)
                                CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmPenalty();
                            CastlesOnTable[i].CastleThinking[0].HuristicPenaltyValuePerform(CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j], Order, ref CastlesOnTable[i].CastleThinking[0].HuristicListCastle[j][0], true);
                        }
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CheckedMateConfiguratiionCastle:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void CheckedMateConfiguratiionMinister(int Order, int i, bool Regrad)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            for (var j = 0; j < MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister.Count; j++)
            {
                
                    if (MinisterOnTable[i].MinisterThinking[0].LearningVarsObject.Count == MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister.Count)
                        if (MinisterOnTable[i].MinisterThinking[0].LearningVarsObject[j][1] && (!MinisterOnTable[i].MinisterThinking[0].LearningVarsObject[j][4]))
                        {
                            MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].Initiate();
                            //if(Regrad)
                            //MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmRegard();
                            //else
                            if (!Regrad)
                                MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmPenalty();
                            MinisterOnTable[i].MinisterThinking[0].HuristicPenaltyValuePerform(MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j], Order, ref MinisterOnTable[i].MinisterThinking[0].HuristicListMinister[j][0], true);
                        }
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CheckedMateConfiguratiionMinister:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void CheckedMateConfiguratiionking(int Order, int i, bool Regrad)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            for (var j = 0; j < KingOnTable[i].KingThinking[0].PenaltyRegardListKing.Count; j++)
            {
                
                    if (KingOnTable[i].KingThinking[0].LearningVarsObject.Count == KingOnTable[i].KingThinking[0].PenaltyRegardListKing.Count)
                        if (KingOnTable[i].KingThinking[0].LearningVarsObject[j][1] && (!KingOnTable[i].KingThinking[0].LearningVarsObject[j][4]))
                        {
                            KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].Initiate();
                            //if(Regrad)
                            //KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmRegard();
                            //else
                            if (!Regrad)
                                KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmPenalty();
                            KingOnTable[i].KingThinking[0].HuristicPenaltyValuePerform(KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j], Order, ref KingOnTable[i].KingThinking[0].HuristicListKing[j][0], true);
                        }
               
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CheckedMateConfiguratiionking:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }

        void CheckedMateConfiguratiion(int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                if (ThinkingChess.LearningVarsCheckedMateOccured && ThinkingChess.LearningVarsCheckedMateOccuredOneCheckedMate)
                {
                    if (Order== 1)
                    {
                        for (var i = 0; i < SodierMidle; i++)
                            if (SolderesOnTable != null && SolderesOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionSoldier(Order, i, true);
                               

                        for (var i = 0; i < ElefantMidle; i++)
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionElephant(Order, i, true);
                               
                        for (var i = 0; i < HourseMidle; i++)
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionHourse(Order, i, true);
                               
                        for (var i = 0; i < CastleMidle; i++)
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionCastle(Order, i, true);
                               
                        for (var i = 0; i < MinisterMidle; i++)
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionMinister(Order, i, true);
                               
                        for (var i = 0; i < KingMidle; i++)
                            if (KingOnTable != null && KingOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionking(Order, i, true);
                               
                    }
                    else
                    {
                        for (var i = SodierMidle; i < SodierHigh; i++)
                            if (SolderesOnTable != null && SolderesOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionSoldier(Order, i, true);
                               
                        for (var i = ElefantMidle; i < ElefantHigh; i++)
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionElephant(Order, i, true);
                               
                        for (var i = HourseMidle; i < HourseHight; i++)
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionHourse(Order, i, true);
                               
                        for (var i = CastleMidle; i < CastleHigh; i++)
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionCastle(Order, i, true);
                               
                        for (var i = MinisterMidle; i < MinisterHigh; i++)
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionMinister(Order, i, true);
                               
                        for (var i = KingMidle; i < KingHigh; i++)
                            if (KingOnTable != null && KingOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionking(Order, i, true);
                               
                    }


                }
                else
                {
                    if (Order== 1)
                    {
                        for (var i = 0; i < SodierMidle; i++)
                            if (SolderesOnTable != null && SolderesOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionSoldier(Order, i, false);
                               
                        for (var i = 0; i < ElefantMidle; i++)
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionElephant(Order, i, false);
                               
                        for (var i = 0; i < HourseMidle; i++)
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionHourse(Order, i, false);
                               
                        for (var i = 0; i < CastleMidle; i++)
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionCastle(Order, i, false);
                               
                        for (var i = 0; i < MinisterMidle; i++)
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionMinister(Order, i, false);
                               
                        for (var i = 0; i < KingMidle; i++)
                            if (KingOnTable != null && KingOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionking(Order, i, false);
                               
                    }
                    else
                    {
                        for (var i = SodierMidle; i < SodierHigh; i++)
                            if (SolderesOnTable != null && SolderesOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionSoldier(Order, i, false);
                               
                        for (var i = ElefantMidle; i < ElefantHigh; i++)
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionElephant(Order, i, false);
                               
                        for (var i = HourseMidle; i < HourseHight; i++)
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionHourse(Order, i, false);
                               
                        for (var i = CastleMidle; i < CastleHigh; i++)
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionCastle(Order, i, false);
                               
                        for (var i = MinisterMidle; i < MinisterHigh; i++)
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionMinister(Order, i, false);
                               
                        for (var i = KingMidle; i < KingHigh; i++)
                            if (KingOnTable != null && KingOnTable[i] != null)
                                
                                    CheckedMateConfiguratiionking(Order, i, false);
                               
                    }

                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CheckedMateConfiguratiion:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        void SemaphoreExxedTime(int time, int Kind)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;

            if (time > 10000)
            {
                if (Kind == 1)
                    OutPut.Append("\r\nSolder Semaphre Full Game Exeede time");
                else
if (Kind == 2)
                    OutPut.Append("\r\nelephant Semaphre Full Game Exeede time");
                else
if (Kind == 3)
                    OutPut.Append("\r\nHourse Semaphre Full Game Exeede time");
                else
if (Kind == 4)
                    OutPut.Append("\r\nCastle Semaphre Full Game Exeede time");
                else
if (Kind == 5)
                    OutPut.Append("\r\nMinister Semaphre Full Game Exeede time");
                else if (Kind == 6)
                    OutPut.Append("\r\nKing Semaphre Full Game Exeede time");

            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("SemaphoreExxedTime:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
        }
        //Main Initiate Thinking Method.
        public int[,] Initiate(int ii, int jj, Color a, int[,] Table, int Order, bool TB, bool FOUND, int LeafAStarGreedy, bool SetDept = false)
        {
            ThinkingChess.IsAtLeastOneKillerAtDraw = false;
            //long Time = TimeElapced.TimeNow();Spaces++;
            var parallelOptions = new ParallelOptions();
            parallelOptions.MaxDegreeOfParallelism = PlatformHelper.ProcessorCount;
            SetDeptIgnore = SetDept;
            int[,] TableHuristic = null;
            int Current = ChessRules.CurrentOrder;
            int DummyOrder = Order;

            Object O = new Object();
            lock (O)
            {
                AllDraw.ActionStringReady = false;
                ThinkingChess.LearningVarsCheckedMateOccured = false;
                ThinkingChess.LearningVarsCheckedMateOccuredOneCheckedMate = false;
                RegardOccurred = false;
                Object OO21 = new Object();
                lock (OO21)
                {
                    TaskBegin = 0;
                    TaskEnd = 0;
                }

                Object OO1 = new Object();
                lock (OO1)
                {
                    lock (OO1)
                    {
                        
                            if (AllDraw.THIScomboBoxMaxLevelText != "")
                                MaxDuringLevelThinkingCreation = System.Convert.ToInt32(AllDraw.THIScomboBoxMaxLevelText);
                       
                    }
                }
                Object Om1 = new Object();
                lock (Om1)
                {
                    MinThinkingTreeDepth = 0;
                }
            
                ThinkingChess.FoundFirstMating = 0;
                ThinkingChess.FoundFirstSelfMating = 0;
                //Monitor Log File Appending First Line. 
                Object On = new Object();
                lock (On)
                {                 

                    OutPut.Append("\n\r=====================================================================================================================================================================<br/>");
                    OutPut.Append("\n\rMovment Number: " + AllDraw.MovmentsNumber);

                }
                //Initiate Local and Global Variables.            
                Object ol = new Object();
                lock (ol)
                {
                    CurrentHuristic = Int32.MinValue;
                    MaxHuristicxT = Int32.MinValue;
                    DrawCastle.MaxHuristicxB = Int32.MinValue;
                    DrawElefant.MaxHuristicxE = Int32.MinValue;
                    DrawHourse.MaxHuristicxH = Int32.MinValue;
                    DrawKing.MaxHuristicxK = Int32.MinValue;
                    DrawMinister.MaxHuristicxM = Int32.MinValue;
                    DrawSoldier.MaxHuristicxS = Int32.MinValue;
                    MovementsAStarGreedyHuristicFoundT = false;
                    DrawTable = false;
                    ChessRules.CheckBrownObjectDangourFirstTimesOcured = false;
                    ChessRules.CheckGrayObjectDangourFirstTimesOcured = false;
                }
            }

                MaxHuristicAStarGreedytBackWard.Clear();

                int[,] Tab = null;

                if (!FOUND)
                {
                    Object O7 = new Object();
                    lock (O7)
                    {
                        ThinkingChess.NotSolvedKingDanger = false;
                        LoopHuristicIndex = 0;
                        Less = Int32.MinValue;
                    }
                }
                //THIS.Invoke((MethodInvoker)delegate()
                {
                    Object OOO = new Object();
                    lock (OOO)
                    {
                        if (!SetDept)
                            MaxAStarGreedy = System.Convert.ToInt32(AllDraw.MaxDuringLevelThinkingCreation);
                        AllDraw.AStarGreedyiLevelMax = MaxAStarGreedy;
                        AStarGreedyiLevelMax = System.Convert.ToInt32(AllDraw.MaxDuringLevelThinkingCreation);
                        AllDraw.MaxAStarGreedyHuristicProgress = 6;
                        for (var i = 0; i <= MaxAStarGreedy; i++)
                            AllDraw.MaxAStarGreedyHuristicProgress += AllDraw.MaxAStarGreedyHuristicProgress * 6;
                        increasedProgress = (int)((int)999999999 / (int)(AllDraw.MaxAStarGreedyHuristicProgress));
                        Object Omm1 = new Object();
                        lock (Omm1)
                        {
                            AStarGreedytMaxCount = (int)MaxAStarGreedy;
                        }
                    }                    
                }//);

                ChessRules.CurrentOrder = Current;
                Order = DummyOrder;
                int iiii = ii, jjjj = jj, Ord = Order;
                int MaxAStarGreedy1 = 0;
                Object OOOO = new Object();
               lock (OOOO)
                {
                    MaxAStarGreedy1 = MaxAStarGreedy;
                }
                int[,] Tabl = CloneATable(Table);
                Color aaa = a;
                InitiateAStarGreedyt(MaxAStarGreedy1, iiii, jjjj, aaa, Tabl, Ord, false, FOUND, LeafAStarGreedy);

                Object Om = new Object();
                lock (Om)
                {
                    MinThinkingTreeDepth = MaxAStarGreedy - MinThinkingTreeDepth;
                    //Initaite Local Varibales.
                    Tab = new int[8, 8];
                    Less = Int32.MinValue;
                }
                ChessRules.CurrentOrder = Current;
                Order = DummyOrder;
                Object OO = new Object();
                lock (OO)
                {
                    OutPut.Append("\r\nMinimum Thinking Tree Depth:" + MinThinkingTreeDepth.ToString() + "!");
                }
                //Order = OrderP;

                TableHuristic = HuristicAStarGreedySearch(0, a, Order, false);
            if ((TableHuristic == null || ((TableZero(TableHuristic)))) && UsePenaltyRegardMechnisamT)
            {

                
                    Object OOoOO = new Object();
                    lock (OOoOO)
                    {
                        OutPut.Append("\r\nTable Zero.Possibly Full Penalty!");


                        //THIS.RefreshBoxText();
                        bool aa = UsePenaltyRegardMechnisamT;
                        UsePenaltyRegardMechnisamT = false;
                        //THISDummy = THISDummy.RemovePenalltyFromFirstBranches(Order);
                        RemovePenalltyFromFirstBranches(Order);
                        MaxAStarGreedy = 1;
                        AStarGreedyiLevelMax = 1;
                        Less = Int32.MinValue;
                        //TableHuristic = THISDummy.HuristicAStarGreedySearchPenalties(0, a, Order, false,ref HaveKilled);
                        //TableHuristic = THISDummy.HuristicAStarGreedySearch(0, a, Order, false,ref HaveKilled);
                        TableHuristic = HuristicAStarGreedySearch(0, a, Order, false);
                        //THISDummy.UsePenaltyRegardMechnisamT = aa;
                        UsePenaltyRegardMechnisamT = aa;
                    }

               
            }
            else
            if ((TableHuristic == null || ((TableZero(TableHuristic)))))
                OutPut.Append("\r\nTable Zero.Possibly Full failed!");

            //If Table Found.

            if (TableHuristic != null)
            {
                Object OOOOO = new Object();
                lock (OOOOO)
                {
                    Ord = Order;
                    if (Ord == 1)
                    {
                        OutPut.Append("\r\nHuristic Find Best Movements AStarGreedy " + AStarGreedy.ToString() + " By Bob!");
                    }
                    else
                    {
                        OutPut.Append("\r\nHuristic Find Best Movements AStarGreedy " + AStarGreedy.ToString() + " By Alice!");

                    }
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = Current;
            }
            else
            {
                Object OOoOO = new Object();
                lock (OOoOO)
                {
                    //Clear AStarGreedy Varibales.
                    AllDraw.StoreADraw.Clear();
                    TableCurrent.Clear();
                    AStarGreedy = 0;
                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = Current;
                //THISDummy.Dispose();
                Object Omm = new Object();
                lock (Omm)
                {
                    DrawTable = true;
                    FoundATable = true;
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("Initiate:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            return CloneATable(TableHuristic);
        }
        //Identification of Illegal AStarGreedy First and Common Hurist Movments.
        public bool IsEnemyThingsinStable(int[,] TableHuristic, int[,] TableAction, int Order)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            //Iniatiet Local Variables.
            int[,] Cromosom1 = TableHuristic;
            int[,] Cromosom2 = TableAction;
            bool and = true;

            bool Find = false;
            //bool Hit = false;
            int FindNumber = 0;
            int
                  CromosomRowFirst = -1, CromosomColumnFirst = -1,
                  CromosomRow = -1, CromosomColumn = -1;
            //Initiate Local Variables.

            //For All Table Home
            for (var i = 0; i < 8; i++)
            {
                for (var j = 0; j < 8; j++)
                {
                    //Gray Order.
                    if (Order== 1)
                    {
                        //Situation 11.
                        if (and)
                        {
                            //All The Brown Object Ignored.
                            if (Cromosom1[i, j] < 0 && Cromosom2[i, j] < 0)
                                continue;
                        }
                        else///Situation 2.
                        {
                            //All The Brown Ojects Ignored.
                            if (Cromosom1[i, j] < 0 || Cromosom2[i, j] < 0)
                                continue;
                        }
                    }
                    else//Brown Order.
                    {
                        //Situation 1.
                        if (and)
                        {
                            //All The Gray Objects Ignored.
                            if (Cromosom1[i, j] > 0 && Cromosom2[i, j] > 0)
                                continue;

                        }
                        else
                        {
                            //All The Gray Objects Ignored.
                            if (Cromosom1[i, j] > 0 || Cromosom2[i, j] > 0)
                                continue;
                        }
                    }
                    if (!(ArrangmentsChanged))
                    {
                        {
                            if (Order == 1 && j == 6 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j + 1] > 0) || (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0) || (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0) && Cromosom1[i, j] == 1))
                                {
                                    CromosomRowFirst = i;
                                    CromosomColumnFirst = j;
                                    if (Cromosom2[i, j + 1] > 0)
                                    {
                                        CromosomRow = i;
                                        CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0)
                                    {
                                        CromosomRow = i + 1;
                                        CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0)
                                    {
                                        CromosomRow = i - 1;
                                        CromosomColumn = j + 1;
                                    }
                                    Find = true;
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;

                                }

                            }
                            else
                                if (Order == -1 && j == 1 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j - 1] < 0) || (Cromosom2[i + 1, j - 1] < 0 && Cromosom1[i + 1, j - 1] > 0) || (Cromosom2[i - 1, j - 1] < 0 && Cromosom1[i - 1, j - 1] < 0) && Cromosom1[i, j] == -1))
                                {
                                    CromosomRowFirst = i;
                                    CromosomColumnFirst = j;
                                    if (Cromosom2[i, j - 1] > 0)
                                    {
                                        CromosomRow = i;
                                        CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0)
                                    {
                                        CromosomRow = i + 1;
                                        CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0)
                                    {
                                        CromosomRow = i - 1;
                                        CromosomColumn = j - 1;
                                    }
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;
                                }
                            }

                            //Castles King Validity Condition.
                            if (Order == 1 && j == 0)
                            {
                                //Small Gray Castles King.
                                if (i == 6 && Cromosom2[i, j] == 6 && Cromosom2[i - 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i - 1, j] != 4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleGray = true;
                                    CastlesKing = true;
                                }
                                else //Big Briges King Gray.
                                    if (i == 2 && Cromosom2[i, j] == 6 && Cromosom2[i + 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i + 1, j] != 4)
                                {
                                    CromosomRowFirst = i + 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleGray = true;
                                    CastlesKing = true;
                                }

                            }
                            else if (j == 7)
                            {
                                //Small Castles King Brown.
                                if (i == 6 && Cromosom2[i, j] == -6 && Cromosom2[i - 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i - 1, j] != -4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleBrown = true;
                                    CastlesKing = true;
                                }
                                else//Big Castles King Brown.
                                    if (i == 2 && Cromosom2[i, j] == -6 && Cromosom2[i + 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i + 1, j] != -4)
                                {
                                    CromosomRowFirst = i + 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleBrown = true;
                                    CastlesKing = true;
                                }

                            }

                        }
                    }
                    else
                    {
                        {
                            if (Order == 1 && j == 1 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j - 1] > 0) || (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0) || (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0) && Cromosom1[i, j] == 1))
                                {
                                    CromosomRowFirst = i;
                                    CromosomColumnFirst = j;
                                    if (Cromosom2[i, j - 1] > 0)
                                    {
                                        CromosomRow = i;
                                        CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0)
                                    {
                                        CromosomRow = i + 1;
                                        CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0)
                                    {
                                        CromosomRow = i - 1;
                                        CromosomColumn = j - 1;
                                    }
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;

                                }

                            }
                            else
                                if (Order == -1 && j == 6 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j + 1] < 0) || (Cromosom2[i + 1, j + 1] < 0 && Cromosom1[i + 1, j + 1] > 0) || (Cromosom2[i - 1, j + 1] < 0 && Cromosom1[i - 1, j + 1] < 0) && Cromosom1[i, j] == -1))
                                {
                                    CromosomRowFirst = i;
                                    CromosomColumnFirst = j;
                                    if (Cromosom2[i, j + 1] > 0)
                                    {
                                        CromosomRow = i;
                                        CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0)
                                    {
                                        CromosomRow = i + 1;
                                        CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0)
                                    {
                                        CromosomRow = i - 1;
                                        CromosomColumn = j + 1;
                                    }
                                    Find = true;
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;
                                }
                            }

                            //Castles King Validity Condition.
                            if (Order == 1 && j == 7)
                            {
                                //Small Gray Castles King.
                                if (i == 6 && Cromosom2[i, j] == 6 && Cromosom2[i - 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i - 1, j] != 4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleGray = true;
                                    CastlesKing = true;
                                }
                                else //Big Briges King Gray.
                                    if (i == 2 && Cromosom2[i, j] == 6 && Cromosom2[i + 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i + 1, j] != 4)
                                {
                                    CromosomRowFirst = i + 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleGray = true;
                                    CastlesKing = true;
                                }

                            }
                            else if (j == 0)
                            {
                                //Small Castles King Brown.
                                if (i == 6 && Cromosom2[i, j] == -6 && Cromosom2[i - 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i - 1, j] != -4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleBrown = true;
                                    CastlesKing = true;
                                }
                                else//Big Castles King Brown.
                                    if (i == 2 && Cromosom2[i, j] == -6 && Cromosom2[i + 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i + 1, j] != -4)
                                {
                                    CromosomRowFirst = i + 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleBrown = true;
                                    CastlesKing = true;
                                }

                            }

                        }
                    }

                    //When To Same Location Tbles are Different in Gen.
                    if (Cromosom1[i, j] != Cromosom2[i, j])
                    {
                        //When Cromosom 2 is Empty.
                        if (Cromosom2[i, j] == 0)
                        {
                            //Initiate Location of Table.
                            continue;
                        }
                        else
                        {
                            //Situation 1.0
                            if (and)
                            {
                                //When Cromosom1 Current Location is Empty.
                                if (Cromosom1[i, j] == 0)
                                {
                                    //Initiate Location of Gen.
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    continue;
                                }
                            }
                        }
                        //Store Location of Gen and Calculate Gen Numbers.
                        CromosomRow = i;
                        CromosomColumn = j;
                        Find = true;
                        FindNumber++;
                    }
                }
            }
            //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("IsEnemyThingsinStable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
            //If Gen Foundation is Valid. 
            if (((FindNumber == 1 || FindNumber == 2) && Find) || CastlesKing || AllDraw.SodierConversionOcuured)
                return Find;
            //Gen Not Found.
            return false;
        }
        List<int[]> WhereNumbers(String Tag)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object OOOO = new Object();
            lock (OOOO)
            {

                List<int[]> TagList = new List<int[]>();
                for (var i = 0; i < Tag.Length; i++)
                {
                    if (i + 1 < Tag.Length)
                    {
                        for (var j = i + 1; j < i + RefrigtzDLL.AllDraw.MaxAStarGreedy.ToString().Length + 1; j++)
                        {
                            
                                int A = System.Convert.ToInt32(Tag.Substring(i, j - i));
                                if (A >= 0 && A <= AllDraw.MaxAStarGreedy)
                                {
                                    int[] Loc = new int[2];
                                    Loc[0] = i;
                                    Loc[1] = j - i;
                                    TagList.Add(Loc);
                                }
                           



                        }
                    }
                }
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("WhereNumbers:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                
                return TagList;
            }
        }
        String CreateHtmlTag(String Tag)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //List<int[]> List = new List<int[]>();
                //List = WhereNumbers(Tag);
                //for (var i = 0; i < List.Count; i++)
                //Tag = Tag.Replace(Tag.Substring(List[i][0], List[i][1]), "<font Color=\"Gold\">" + Tag.Substring(List[i][0], List[i][1]) + "</font>");

                if (Tag.Contains("Thinking"))
                    Tag = Tag.Replace("Thinking", "<font Color=\"Green\">" + "Thinking" + "</font>");
                if (Tag.Contains("Perception"))
                    Tag = Tag.Replace("Perception", "<font Color=\"Green\">" + "Perception" + "</font>");
                if (Tag.Contains("Bob"))
                    Tag = Tag.Replace("Bob", "<font Color=\"Gray\">" + "Bob" + "</font>");
                if (Tag.Contains("Alice"))
                    Tag = Tag.Replace("Alice", "<font Color=\"Brown\">" + "Brown" + "</font>");
                if (Tag.Contains("AstarGreedy "))
                    Tag = Tag.Replace("AstarGreedy ", "<font Color=\"Yellow\">" + "AstarGreedy " + "</font>");
                if (Tag.Contains("Level"))
                    Tag = Tag.Replace("Level", "<font Color=\"Blue\">" + "Level" + "</Font>");
                /*              if (Tag.Contains("Soldeir"))
                                  Tag = Tag.Replace("Soldeir", "<font Color=\"Silver\">" + "Soldeir" + "</font>");
                              else
                              if (Tag.Contains("Elephant"))
                                  Tag = Tag.Replace("Elephant", "<font Color=\"Silver\">" + "Elephant" + "</font>");
                              else
                              if (Tag.Contains("Hourse"))
                                  Tag = Tag.Replace("Hourse", "<font Color=\"Silver\">" + "Hourse" + "</font>");
                              else
                              if (Tag.Contains("Castle"))
                                  Tag = Tag.Replace("Castle", "<font Color=\"Silver\">" + "Castle" + "</font>");
                              else
                              if (Tag.Contains("Minister"))
                                  Tag = Tag.Replace("Minister", "<font Color=\"Silver\">" + "Minister" + "</font>");
                              else
                              if (Tag.Contains("King"))
                                  Tag = Tag.Replace("King", "<font Color=\"Silver\">" + "King" + "</font>");
              */
                String R = "<font Color=\"Red\">" + Tag + "</font>";
                //{ AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) AllDraw.OutPut.Append(Space);  AllDraw.OutPut.Append("CreateHtmlTag:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return R;
            }
        }
    }
}
//End of Documentation.
