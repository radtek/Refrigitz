/****************************************************************************
 * Thinking Operation class.*************************************************
 * Ramin Edjlal**************************************************************
 * Drived Classess of Autamata Cellular Quantum Thinking Kernel**************
 * 1394/12/19****************************************************************
 * Crashed with Stack Overflow Exception***************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Drives Caused Memory lack***************************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * New Version Cased Stack Overflow********************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Scanning Four Dimension Homes of Thing Existences Taking A lot Of Time******RS**0.12**4**Managements and Cuation Programing**********************(+)
 * All Data in This Scope From AllDraw Become Clear When Scope Changes*********RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Work but the Movements And Attack Method Doesn’t work*************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Probability Heuristic constant Table return*********************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Working Not Constant Immunity*************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Constant Result Mechanism*****************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Things Order and Virtualization Error***************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Misleading Things Order movement********************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Multi Movements (3 ) In Chess Thinking**************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Location of Horse 'Bob' (Gray) After Hitting Un logically UnSelfSupported***RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Check Thinking 'Alice' Malfunction*******************************************RS**0.12**4**Managements and Cuation Programing*********************(+)
 * 'CheckMate' By 'Bob' Have Not Been Recognized.***********************************RS**0.12**4**Managements and Cuation Programing*****************(+)
 * 'Check' By 'Bob' Not Recognized.*********************************************RS**0.12**4**Managements and Cuation Programing*********************(+)
 * 'Check' 'Alice' Detected. No Action Was Done.********************************RS**0.12**4**Managements and Cuation Programing*********************(+)
 * 'Check' Mechanism Failure.***************************************************RS**0.12**4**Managements and Cuation Programing*********************(+)
 * Strategy By 'Alice' Changed. 'Check' Not Recognized By 'Alice'.**************RS**0.12**4**Managements and Cuation Programing*********************(+)
 * Heuristic Loop**************************************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * 'Check' Mechanism For Penalty Regard Is Malfunction**************************RC**0.88**1**Risk Control*******************************************(*)QC-OK.
 * Things Location Failure. Row and Column of this Objects class Malfunction***RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Malfunction Of Operating Lists in this class.*******************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Some Movements of All Possible Movements is not Identified******************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Malfunction Clone Data To be Copied. List Will be erased********************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * King Cannot Hit UnSelfSupported Enemy Things at Check.***********************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Thinking Time Taking al lot of time.****************************************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * There is No Reason For Mal Function of Thinking.****************************RS**0.12**4**Managements and Cuation Programing**********************[+]
 * Huristic SelfSupported at horse huristic cal at table content malfunction.**RS**0.12**4**Managements and Cuation Programing**********************[+]
 * No Reason for malfunctioning of table content at huristic SelfSupported.****RS**0.12**4**Managements and Cuation Programing**********************[+]
 * Thinking Finished Misleading.bool Variable of Think Finished Not Work on.***RS**0.12**4**Managements and Cuation Programing**********************(+) 
 * A non Identified King Table List Alice is in List and Unhabitly ignored.****RS**0.12**4**Managements and Cuation Programing**********************(+)
 * The Location of Penalty Regard Mechansim is Misleading.*********************RS**0.12**4**Managements and Cuation Programing**********************(+)
 * Penalty Reagrd List is Empty.No Misleading List of Penalty Regard Mec.******RS**0.12**4**Managements and Cuation Programing**********************(+)
 * No Ilegal Non ObjectDanger and Check By 'Alice' at Current Game in PR Mech.********RS**0.12**4**Managements and Cuation Programing***************(+)
 * Mechansianm For Like Napeloonires KLish CheckMate is Incompletable.**************RC**0.88**1**Risk Control***************************************(*)QC-OK.
 * Ileegal Table Content Ignoring of Objects Kind.*****************************RC**0.88**1**Risk Control********************************************(*)QC-OK.
 * Tree Construction of AStarGready is Uncompleted.Some Nodes Become Empty.****RS**0.12**4**Managements and Cuation Programing**********************<+>
 * All Penalty Leads to 16 Objects Unmovable or Make Penalty But in Reality Non Penalty Exist.******************************************************(+)
 * All Self and Enemy CheckMate Mechanisam is Logical else Mislaeading.*************RC**0.88**1**Risk Control***************************************(*).QC-Ok.
 * Proccess of Thinking Stop Misleading With Error.*********************************RC**0.88**1**Risk Control***************************************{*}.QC-Ok.
 * All List of this class make differncy at several runable state of one table board state.RC**0.88**1**Risk Control********************************{*}.QC-OK.
 * Thinking Act Misleading.***************************************************************.RC**0.88**1**Risk Control********************************{*}QC-OK.
 * The Achmaz Removing and maybe SelfNotSupported in Attacker conflict and thus Ignore.RC**0.88**1**Risk Control************************************(*)QC-OK.
 * The Self Supporter in Attacker somthime goes to misleading act.********************.RC**0.88**1**Risk Control************************************(*)QC-Ok.
 * Enemy Attacker Not Supported act Misleading.***************************************.RC**0.88**1**Risk Control************************************(*)QC_OK.
 * Heuristic proccesing dosne't haave any aim.****************************************.RC**0.88**1**Risk Control************************************(*)QC-OK.
 * Rating of Alice as Computer Game is very weak as compatitor of users.**************.RC**0.88**1**Risk Control************************************<*>
 * Thinking gone to take some part of stones.*****************************************.RC**0.88**1**Risk Control************************************<*>
 * Thinking failed becuase of all possible movment penalties of first level**.********.RC**0.88**1**Risk Control************************************<*>
 * Object Dangour and Check is aditive of HeuristicCheckedand checked mated.**********.RC**0.88**1**Risk Control************************************<*>
 * Heuristics take some part of stone.************************************************.RC**0.88**1**Risk Control************************************<*>
 * Branch Dept at Thinking Tree is low becuse of harware constraints and speed.*******.RC**0.88**1**Risk Control************************************<*>
 * **************************************************************************(+:Sum(26)) (*:Sum(1)) 5:(+:Sum(3)) 6.(+:Sum0.12**4**Managements and Cuation Programing**********************(+)) 7.(QC-OK:Sum(1))
 * **************************************************************************
 */


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;
using System.Threading;
using LearningMachine;
using System.IO;
using System.Diagnostics;
using System.Threading.Tasks;
using LearningMachine;


namespace AppRefregitz
{
    public class ThinkingChess
    {
        //Initiate Global Variables.
        public static bool FoundFirstMating = false;
        bool EE = false;
        public int SodierValue = 1;//1 * 3;
        public int ElefantValue = 1;//2 * 16;
        public int HourseValue = 1;//3 * 8;
        public int BridgeValue = 1;//5 * 16;
        public int MinisterValue = 1;//8 * 32;
        public int KingValue = 1;//10 * 8;
        public static int BeginThread = 0;
        public static int EndThread = 0;
        bool ExistingOfEnemyHiiting = false;
        int IgnoreObjectDangour = -1;
        public int CheckMateAStarGreedy = 0;
        bool CheckMateOcuured = false;
        int CurrentRow = -1, CurrentColumn = -1;
        public bool IsCheck = false;
        public bool SelfCheckMateAction = false;
        public bool AchamazCurrent = false;
        public bool InAttackedNotSelfSupported = false;
        public bool SelfSupported = false;
        public bool EnemyNotSupported = false;
        public bool InAttackedNotEnemySupported = false;
        public static int Sign = 1;
        public int Kind = 0;
        public static double MaxHuristicx = Double.MinValue;
        public static bool MovementsAStarGreedyHuristicFound = false;
        public static bool IgnoreSelfObjects = false;
        public static bool UsePenaltyRegardMechnisam = true;
        public static bool BestMovments = false;
        public static bool PredictHuristic = true;
        public static bool OnlySelf = false;
        public static bool AStarGreedyHuristic = false;
        public List<int> HitNumber = new List<int>();
        public static bool NotSolvedKingDanger = false;
        public static bool ThinkingRun = false;
        public int ThingsNumber = 0;
        public int CurrentArray = 0;
        public double HuristicValue = 0;
        public double HuristicValueMovement = 0;
        public double HuristicValueSelfSupported = 0;
        public double HuristicValueObjectDangourCheckMate = 0;
        public bool ThinkingBegin = false;
        public bool ThinkingFinished = false;
        public int IndexSoldier = 0;
        public int IndexElefant = 0;
        public int IndexHourse = 0;
        public int IndexBridge = 0;
        public int IndexMinister = 0;
        public int IndexKing = 0;
        static public int Index = 0;
        static public int[,] RowColumn;
        public List<int[]> RowColumnSoldier;
        public List<int[]> RowColumnElefant;
        public List<int[]> RowColumnHourse;
        public List<int[]> RowColumnBridge;
        public List<int[]> RowColumnMinister;
        public List<int[]> RowColumnKing;
        public int[,] TableT;
        public List<int> HitNumberSoldier;
        public List<int> HitNumberElefant;
        public List<int> HitNumberHourse;
        public List<int> HitNumberBridge;
        public List<int> HitNumberMinister;
        public List<int> HitNumberKing;
        public int[,] TableConst;
        public List<int[,]> TableListSolder = new List<int[,]>();
        public List<int[,]> TableListElefant = new List<int[,]>();
        public List<int[,]> TableListHourse = new List<int[,]>();
        public List<int[,]> TableListBridge = new List<int[,]>();
        public List<int[,]> TableListMinister = new List<int[,]>();
        public List<int[,]> TableListKing = new List<int[,]>();
        public List<double[]> HuristicListSolder = new List<double[]>();
        public List<double[]> HuristicListElefant = new List<double[]>();
        public List<double[]> HuristicListHourse = new List<double[]>();
        public List<double[]> HuristicListBridge = new List<double[]>();
        public List<double[]> HuristicListMinister = new List<double[]>();
        public List<double[]> HuristicListKing = new List<double[]>();
        public List<QuantumAtamata> PenaltyRegardListSolder = new List<QuantumAtamata>();
        public List<QuantumAtamata> PenaltyRegardListElefant = new List<QuantumAtamata>();
        public List<QuantumAtamata> PenaltyRegardListHourse = new List<QuantumAtamata>();
        public List<QuantumAtamata> PenaltyRegardListBridge = new List<QuantumAtamata>();
        public List<QuantumAtamata> PenaltyRegardListMinister = new List<QuantumAtamata>();
        public List<QuantumAtamata> PenaltyRegardListKing = new List<QuantumAtamata>();
        public int Max;
        public int Row, Column;
        public Color color;
        public int Order;
        public Task t = null;
        public List<AllDraw> AStarGreedy = null;
        public FormRefrigtz THIS;
        private static ParallelLoopResult result1;
        public static long SomeExtremelyLargeNumber { get; private set; }
        ///Log of Errors.
       
        public ThinkingChess(int i, int j)
        {
            Row = i;
            Column = j;
            //Clear Dearty Part.
            TableListSolder.Clear();
            TableListElefant.Clear();
            TableListHourse.Clear();
            TableListBridge.Clear();
            TableListMinister.Clear();
            TableListKing.Clear();
            RowColumnSoldier = new List<int[]>();
            RowColumnElefant = new List<int[]>();
            RowColumnHourse = new List<int[]>();
            RowColumnBridge = new List<int[]>();
            RowColumnMinister = new List<int[]>();
            RowColumnKing = new List<int[]>();
            HitNumberSoldier = new List<int>();
            HitNumberElefant = new List<int>();
            HitNumberHourse = new List<int>();
            HitNumberBridge = new List<int>();
            HitNumberMinister = new List<int>();
            HitNumberKing = new List<int>();
            PenaltyRegardListSolder = new List<QuantumAtamata>();
            PenaltyRegardListElefant = new List<QuantumAtamata>();
            PenaltyRegardListHourse = new List<QuantumAtamata>();
            PenaltyRegardListBridge = new List<QuantumAtamata>();
            PenaltyRegardListMinister = new List<QuantumAtamata>();
            PenaltyRegardListKing = new List<QuantumAtamata>();
            AStarGreedy = new List<AllDraw>();

        }
        ///Constructor
        public ThinkingChess(int i, int j, Color a, int[,] Tab, int Ma, int Ord, bool ThinkingBeg, int CurA, int ThingN//, ref FormRefrigtz TH
            , int Kin)
        {
            Kind = Kin;
            //THIS = TH;
            AStarGreedy = new List<AllDraw>();
            ThingsNumber = ThingN;
            CurrentArray = CurA;
            TableListSolder.Clear();
            TableListElefant.Clear();
            TableListHourse.Clear();
            TableListBridge.Clear();
            TableListMinister.Clear();
            TableListKing.Clear();
            RowColumnSoldier = new List<int[]>();
            RowColumnElefant = new List<int[]>();
            RowColumnHourse = new List<int[]>();
            RowColumnBridge = new List<int[]>();
            RowColumnMinister = new List<int[]>();
            RowColumnKing = new List<int[]>();
            RowColumn = new int[1000000, 2];
            HitNumberSoldier = new List<int>();
            HitNumberElefant = new List<int>();
            HitNumberHourse = new List<int>();
            HitNumberBridge = new List<int>();
            HitNumberMinister = new List<int>();
            HitNumberKing = new List<int>();
            PenaltyRegardListSolder = new List<QuantumAtamata>();
            PenaltyRegardListElefant = new List<QuantumAtamata>();
            PenaltyRegardListHourse = new List<QuantumAtamata>();
            PenaltyRegardListBridge = new List<QuantumAtamata>();
            PenaltyRegardListMinister = new List<QuantumAtamata>();
            PenaltyRegardListKing = new List<QuantumAtamata>();
            Row = i;
            Column = j;
            color = a;
            Max = Ma;
            TableT = Tab;
            Index = 0;
            IndexSoldier = 0;
            IndexElefant = 0;
            IndexHourse = 0;
            IndexBridge = 0;
            IndexMinister = 0;
            IndexKing = 0;
            TableConst = new int[8, 8];
            for (int ii = 0;
                ii < 8; ii++)
                for (int jj = 0; jj < 8; jj++)
                {
                    TableConst[ii, jj] = TableT[ii, jj];
                }
            Order = Ord;
            ThinkingBegin = ThinkingBeg;
            AStarGreedy = new List<AllDraw>();

        }

        int[,] CloneATable(int[,] Tab)
        {
            int[,] Table = new int[8, 8];
            for (int i = 0; i < 8; i++)
                for (int j = 0; j < 8; j++)
                    Table[i, j] = Tab[i, j];
            return Table;
        }
        int[] CloneAList(int[] Tab, int Count)
        {
            int[] Table = new int[Count];
            for (int i = 0; i < Count; i++)
                Table[i] = Tab[i];
            return Table;
        }
        double[] CloneAList(double[] Tab, int Count)
        {
            double[] Table = new double[Count];
            for (int i = 0; i < Count; i++)
                Table[i] = Tab[i];
            return Table;
        }
        ///Clone a Copy.
        public void Clone(ref ThinkingChess AA//, ref FormRefrigtz THIS
            )
        {
            //Assignment Contert to New Content Object.
            AA = new ThinkingChess(Row, Column);
            if (AStarGreedy.Count != 0)
            {

                for (int i = 0; i < AStarGreedy.Count; i++)
                {
                    //AA.AStarGreedy.Add(new AllDraw(ref THIS));
                    try
                    {
                        AStarGreedy[i].Clone(AA.AStarGreedy[i]);
                    }
                    catch (Exception tt)
                    {
                        
                    }
                }
            }

            for (int j = 0; j < RowColumnSoldier.Count; j++)

                AA.RowColumnSoldier.Add(CloneAList(RowColumnSoldier[j], 2));

            for (int j = 0; j < RowColumnBridge.Count; j++)
                AA.RowColumnBridge.Add(CloneAList(RowColumnBridge[j], 2));


            for (int j = 0; j < RowColumnElefant.Count; j++)
                AA.RowColumnElefant.Add(CloneAList(RowColumnElefant[j], 2));

            for (int j = 0; j < RowColumnHourse.Count; j++)
                AA.RowColumnHourse.Add(CloneAList(RowColumnHourse[j], 2));

            for (int j = 0; j < RowColumnKing.Count; j++)
                AA.RowColumnKing.Add(CloneAList(RowColumnKing[j], 2));

            for (int j = 0; j < RowColumnMinister.Count; j++)
                AA.RowColumnMinister.Add(CloneAList(RowColumnMinister[j], 2));

            AA.t = t;
            AA.TableT = new int[8, 8];
            AA.TableConst = new int[8, 8];
            if (TableT != null)
                for (int i = 0; i < 8; i++)
                    for (int j = 0; j < 8; j++)
                        AA.TableT[i, j] = TableT[i, j];
            if (TableConst != null)
                for (int i = 0; i < 8; i++)
                    for (int j = 0; j < 8; j++)
                        AA.TableConst[i, j] = TableConst[i, j];
            for (int i = 0; i < TableListBridge.Count; i++)
                AA.TableListBridge.Add(CloneATable(TableListBridge[i]));

            for (int i = 0; i < TableListElefant.Count; i++)
                AA.TableListElefant.Add(CloneATable(TableListElefant[i]));

            for (int i = 0; i < TableListHourse.Count; i++)
                AA.TableListHourse.Add(CloneATable(TableListHourse[i]));

            for (int i = 0; i < TableListKing.Count; i++)
                AA.TableListKing.Add(CloneATable(TableListKing[i]));

            for (int i = 0; i < TableListMinister.Count; i++)
                AA.TableListMinister.Add(CloneATable(TableListMinister[i]));

            for (int i = 0; i < TableListSolder.Count; i++)
                AA.TableListSolder.Add(CloneATable(TableListSolder[i]));


            for (int i = 0; i < HuristicListSolder.Count; i++)
                AA.HuristicListSolder.Add(CloneAList(HuristicListSolder[i], 4));


            for (int i = 0; i < HuristicListElefant.Count; i++)
                AA.HuristicListElefant.Add(CloneAList(HuristicListElefant[i], 4));

            for (int i = 0; i < HuristicListHourse.Count; i++)
                AA.HuristicListHourse.Add(CloneAList(HuristicListHourse[i], 4));


            for (int i = 0; i < HuristicListBridge.Count; i++)
                AA.HuristicListBridge.Add(CloneAList(HuristicListBridge[i], 4));

            for (int i = 0; i < HuristicListMinister.Count; i++)
                AA.HuristicListMinister.Add(CloneAList(HuristicListMinister[i], 4));

            for (int i = 0; i < HuristicListKing.Count; i++)
                AA.HuristicListKing.Add(CloneAList(HuristicListKing[i], 4));


            AA.PenaltyRegardListSolder = new List<QuantumAtamata>();
            for (int i = 0; i < PenaltyRegardListSolder.Count; i++)
            {
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                PenaltyRegardListSolder[i].Clone(ref Current);
                AA.PenaltyRegardListSolder.Add(Current);
            }

            AA.PenaltyRegardListElefant = new List<QuantumAtamata>();
            for (int i = 0; i < PenaltyRegardListElefant.Count; i++)
            {
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                PenaltyRegardListElefant[i].Clone(ref Current);
                AA.PenaltyRegardListElefant.Add(Current);
            }

            AA.PenaltyRegardListHourse = new List<QuantumAtamata>();
            for (int i = 0; i < PenaltyRegardListHourse.Count; i++)
            {
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                PenaltyRegardListHourse[i].Clone(ref Current);
                AA.PenaltyRegardListHourse.Add(Current);
            }

            AA.PenaltyRegardListBridge = new List<QuantumAtamata>();
            for (int i = 0; i < PenaltyRegardListBridge.Count; i++)
            {
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                PenaltyRegardListBridge[i].Clone(ref Current);
                AA.PenaltyRegardListBridge.Add(Current);
            }
            AA.PenaltyRegardListMinister = new List<QuantumAtamata>();
            for (int i = 0; i < PenaltyRegardListMinister.Count; i++)
            {
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                PenaltyRegardListMinister[i].Clone(ref Current);
                AA.PenaltyRegardListMinister.Add(Current);
            }
            AA.PenaltyRegardListKing = new List<QuantumAtamata>();
            for (int i = 0; i < PenaltyRegardListKing.Count; i++)
            {
                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                PenaltyRegardListKing[i].Clone(ref Current);
                AA.PenaltyRegardListKing.Add(Current);
            }
            AA.AchamazCurrent = AchamazCurrent;
            AA.AStarGreedy = AStarGreedy;
            AA.BridgeValue = BridgeValue;
            AA.color = color;
            AA.Column = Column;
            AA.CurrentArray = CurrentArray;
            AA.CurrentColumn = CurrentColumn;
            AA.CurrentRow = CurrentRow;
            AA.ElefantValue = ElefantValue;
            AA.EnemyNotSupported = EnemyNotSupported;
            AA.ExistingOfEnemyHiiting = ExistingOfEnemyHiiting;
            AA.HourseValue = HourseValue;
            AA.HuristicValue = HuristicValue;
            AA.HuristicValueObjectDangourCheckMate = HuristicValueObjectDangourCheckMate;
            AA.HuristicValueMovement = HuristicValueMovement;
            AA.HuristicValueSelfSupported = HuristicValueSelfSupported;
            AA.IgnoreObjectDangour = IgnoreObjectDangour;
            AA.InAttackedNotEnemySupported = InAttackedNotEnemySupported;
            AA.InAttackedNotSelfSupported = InAttackedNotSelfSupported;
            AA.IndexBridge = IndexBridge;
            AA.IndexElefant = IndexElefant;
            AA.IndexHourse = IndexHourse;
            AA.IndexKing = IndexKing;
            AA.IndexMinister = IndexMinister;
            AA.IndexSoldier = IndexSoldier;
            AA.IsCheck = IsCheck;
            AA.Kind = Kind;
            AA.KingValue = KingValue;
            AA.CheckMateAStarGreedy = CheckMateAStarGreedy;
            AA.CheckMateOcuured = CheckMateOcuured;
            AA.Max = Max;
            AA.MinisterValue = MinisterValue;
            AA.Order = Order;
            AA.Row = Row;
            AA.SelfCheckMateAction = SelfCheckMateAction;
            AA.SelfSupported = SelfSupported;
            AA.SodierValue = SodierValue;
            AA.ThingsNumber = ThingsNumber;
            AA.ThinkingBegin = ThinkingBegin;
            AA.ThinkingFinished = ThinkingFinished;
            AA.THIS = THIS;
        }
        ///Huristic of Attacker.QC-OK
        float HuristicAttack(int[,] Table, int Order, Color a)
        {
            int HA = 0;
            int DumOrder = Order;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            ///When AStarGreedy Huristic is Not Assigned.
            try
            {
                if (!AStarGreedyHuristic)
                {
                    ///For Every Objects.
                    int i = Row, j = Column;
                    ///For All Movments.
                    for (int ii = 0; ii < 8; ii++)
                    {
                        for (int jj = 0; jj < 8; jj++)
                        {
                            if (i == ii && j == jj)
                                continue;
                            int Sign = 1;
                            Order = DummyOrder;
                            ///When Attack is true. means [ii,jj] is in Attacked  [i,j].
                            ///What is Attack!
                            ///Ans:When [ii,jj] is Attacked [i,j] return true when enemy is located in [ii,jj].
                            if (Table[ii, jj] > 0 && DummyOrder == -1 && Table[i, j] < 0)
                            {
                                Order = -1;
                                Sign = 100 * AllDraw.SignAttack;
                                ChessRules.CurrentOrder = -1;
                                a = Color.Brown;
                            }
                            else if (Table[ii, jj] < 0 && DummyOrder == 1 && Table[i, j] > 0)
                            {
                                Order = 1;
                                Sign = -100 * AllDraw.SignAttack;
                                ChessRules.CurrentOrder = 1;
                                a = Color.Gray;
                            }
                            else
                                /*   else
                                       if (Table[ii, jj] < 0 && DummyOrder == -1 && Table[i, j] > 0)
                                       {
                                           Order = 1;
                                           Sign = 100 * AllDraw.SignAttack;
                                           ChessRules.CurrentOrder = 1;
                                           a = Color.Gray;
                                       }
                                       else if (Table[ii, jj] > 0 && DummyOrder == 1 && Table[i, j] < 0)
                                       {
                                           Order = -1;
                                           Sign = -100 * AllDraw.SignAttack;
                                           ChessRules.CurrentOrder = -1;
                                           a = Color.Brown;
                                       }
                                       else
                                 */
                                continue;
                            //For Attack Movments.
                            if (Attack(Table, i, j, ii, jj, a, Order))
                            {
                                //Finf Huristic Value Of Current and Add to Sumation.
                                //  if (System.Math.Abs(Table[i, j]) < MaxOrderEnemyAndSelf(Table, i, j, ii, jj, Order))
                                {
                                    if (System.Math.Abs(Table[i, j]) == 1)
                                        HA += (Sign * System.Math.Abs(SodierValue + GetObjectValue(Table[ii, jj])
                                            ));
                                    else if (System.Math.Abs(Table[i, j]) == 2)
                                        HA += (Sign * System.Math.Abs(ElefantValue + GetObjectValue(Table[ii, jj])
                                            ));
                                    else if (System.Math.Abs(Table[i, j]) == 3)
                                        HA += (Sign * System.Math.Abs(HourseValue + GetObjectValue(Table[ii, jj])
                                            ));
                                    else if (System.Math.Abs(Table[i, j]) == 4)
                                        HA += (Sign * System.Math.Abs(BridgeValue + GetObjectValue(Table[ii, jj])
                                            ));
                                    else if (System.Math.Abs(Table[i, j]) == 5)
                                        HA += (Sign * System.Math.Abs(MinisterValue + GetObjectValue(Table[ii, jj])
                                            ));
                                    else if (System.Math.Abs(Table[i, j]) == 6)
                                        HA += (Sign * System.Math.Abs(KingValue + GetObjectValue(Table[ii, jj])
                                            ));
                                    bool Supported = false;

                                    for (int g = 0; g < 8; g++)
                                        for (int h = 0; h < 8; h++)
                                        {
                                            if (Order == 1 && Table[g, h] >= 0)
                                                continue;
                                            if (Order == -1 && Table[g, h] <= 0)
                                                continue;
                                            Color aa;
                                            if (Order == -1)
                                                aa = Color.Gray;
                                            else
                                                aa = Color.Brown;
                                            if (Support(Table, g, h, ii, jj, aa, Table[g, h]))
                                            {
                                                Supported = true;
                                                Sign *= 10;
                                                if (System.Math.Abs(Table[g, h]) == 1)
                                                    HA -= (Sign * System.Math.Abs(SodierValue + GetObjectValue(Table[ii, jj])
                                                        ));
                                                else if (System.Math.Abs(Table[g, h]) == 2)
                                                    HA -= (Sign * System.Math.Abs(ElefantValue + GetObjectValue(Table[ii, jj])
                                                        ));
                                                else if (System.Math.Abs(Table[g, h]) == 3)
                                                    HA -= (Sign * System.Math.Abs(HourseValue + GetObjectValue(Table[ii, jj])
                                                        ));
                                                else if (System.Math.Abs(Table[g, h]) == 4)
                                                    HA -= (Sign * System.Math.Abs(BridgeValue + GetObjectValue(Table[ii, jj])
                                                        ));
                                                else if (System.Math.Abs(Table[g, h]) == 5)
                                                    HA -= (Sign * System.Math.Abs(MinisterValue + GetObjectValue(Table[ii, jj])
                                                        ));
                                                else if (System.Math.Abs(Table[g, h]) == 6)
                                                    HA -= (Sign * System.Math.Abs(KingValue + GetObjectValue(Table[ii, jj])
                                                        ));

                                            }
                                        }
                                    if (!Supported)
                                        HA *= 100;
                                    else
                                        HA *= -100;
                                }



                            }
                            else
                            {
                                bool Supported = false;

                                for (int g = 0; g < 8; g++)
                                    for (int h = 0; h < 8; h++)
                                    {
                                        if (Order == 1 && Table[g, h] >= 0)
                                            continue;
                                        if (Order == -1 && Table[g, h] <= 0)
                                            continue;
                                        Color aa;
                                        if (Order == -1)
                                            aa = Color.Gray;
                                        else
                                            aa = Color.Brown;
                                        if (Support(Table, g, h, ii, jj, aa, Table[g, h]))
                                        {
                                            Supported = true;
                                            Sign *= 10;
                                            if (System.Math.Abs(Table[g, h]) == 1)
                                                HA -= (Sign * System.Math.Abs(SodierValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[g, h]) == 2)
                                                HA -= (Sign * System.Math.Abs(ElefantValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[g, h]) == 3)
                                                HA -= (Sign * System.Math.Abs(HourseValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[g, h]) == 4)
                                                HA -= (Sign * System.Math.Abs(BridgeValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[g, h]) == 5)
                                                HA -= (Sign * System.Math.Abs(MinisterValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[g, h]) == 6)
                                                HA -= (Sign * System.Math.Abs(KingValue + GetObjectValue(Table[ii, jj])
                                                    ));

                                        }
                                    }
                                if (!Supported)
                                    HA *= 100;
                                else
                                    HA *= -100;
                            }




                        }
                    }

                }
                //For All Table Homes find Attack Huristic.
                else
                {
                    for (int i = 0; i < 8; i++)
                    {
                        for (int j = 0; j < 8; j++)
                        {
                            for (int ii = 0; ii < 8; ii++)
                            {
                                for (int jj = 0; jj < 8; jj++)
                                {
                                    if (i == ii && j == jj)
                                        continue;
                                    Order = DummyOrder;
                                    int Sign = 1;
                                    ///When Attack is true. means [ii,jj] is in Attacked  [i,j].
                                    ///What is Attack!
                                    ///Ans:When [ii,jj] is Attacked [i,j] return true when enemy is located in [ii,jj].
                                    if (Table[ii, jj] > 0 && DummyOrder == -1 && Table[i, j] < 0)
                                    {
                                        Order = -1;
                                        Sign = 100 * AllDraw.SignAttack;
                                        ChessRules.CurrentOrder = -1;
                                        a = Color.Brown;
                                    }
                                    else if (Table[ii, jj] < 0 && DummyOrder == 1 && Table[i, j] > 0)
                                    {
                                        Order = 1;
                                        Sign = -100 * AllDraw.SignAttack;
                                        ChessRules.CurrentOrder = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                        /*        else
                                                    if (Table[ii, jj] < 0 && DummyOrder == -1 && Table[i, j] > 0)
                                                    {
                                                        Order = 1;
                                                        Sign = 100 * AllDraw.SignAttack;
                                                        ChessRules.CurrentOrder = 1;
                                                        a = Color.Gray;
                                                    }
                                                    else if (Table[ii, jj] > 0 && DummyOrder == 1 && Table[i, j] < 0)
                                                    {
                                                        Order = -1;
                                                        Sign = -100 * AllDraw.SignAttack;
                                                        ChessRules.CurrentOrder = -1;
                                                        a = Color.Brown;
                                                    }
                                                    else
                                         */
                                        continue;
                                    //For Attack Movments.
                                    if (Attack(Table, i, j, ii, jj, a, Order))
                                    {
                                        //Find Huristic Movments Attack.
                                        {
                                            if (System.Math.Abs(Table[i, j]) == 1)
                                                HA += (Sign * System.Math.Abs(SodierValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[i, j]) == 2)
                                                HA += (Sign * System.Math.Abs(ElefantValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[i, j]) == 3)
                                                HA += (Sign * System.Math.Abs(HourseValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[i, j]) == 4)
                                                HA += (Sign * System.Math.Abs(BridgeValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[i, j]) == 5)
                                                HA += (Sign * System.Math.Abs(MinisterValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[i, j]) == 6)
                                                HA += (Sign * System.Math.Abs(KingValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            bool Supported = false;
                                            for (int g = 0; g < 8; g++)
                                                for (int h = 0; h < 8; h++)
                                                {
                                                    if (Order == 1 && Table[g, h] >= 0)
                                                        continue;
                                                    if (Order == -1 && Table[g, h] <= 0)
                                                        continue;
                                                    Color A = Color.Gray;
                                                    if (Order == -1)
                                                        A = Color.Brown;
                                                    if (Support(Table, g, h, ii, jj, Color.Brown, Table[g, h]))
                                                    {
                                                        Supported = true;
                                                        Sign *= 10;
                                                        if (System.Math.Abs(Table[g, h]) == 1)
                                                            HA -= (Sign * System.Math.Abs(SodierValue + GetObjectValue(Table[ii, jj])
                                                                ));
                                                        else if (System.Math.Abs(Table[g, h]) == 2)
                                                            HA -= (Sign * System.Math.Abs(ElefantValue + GetObjectValue(Table[ii, jj])
                                                                ));
                                                        else if (System.Math.Abs(Table[g, h]) == 3)
                                                            HA -= (Sign * System.Math.Abs(HourseValue + GetObjectValue(Table[ii, jj])
                                                                ));
                                                        else if (System.Math.Abs(Table[g, h]) == 4)
                                                            HA -= (Sign * System.Math.Abs(BridgeValue + GetObjectValue(Table[ii, jj])
                                                                ));
                                                        else if (System.Math.Abs(Table[g, h]) == 5)
                                                            HA -= (Sign * System.Math.Abs(MinisterValue + GetObjectValue(Table[ii, jj])
                                                                ));
                                                        else if (System.Math.Abs(Table[g, h]) == 6)
                                                            HA -= (Sign * System.Math.Abs(KingValue + GetObjectValue(Table[ii, jj])
                                                                ));

                                                    }
                                                }
                                            if (!Supported)
                                                HA *= 100;
                                        }
                                    }
                                    else
                                    {
                                        {
                                            bool Supported = false;

                                            for (int g = 0; g < 8; g++)
                                                for (int h = 0; h < 8; h++)
                                                {
                                                    if (Order == 1 && Table[g, h] >= 0)
                                                        continue;
                                                    if (Order == -1 && Table[g, h] <= 0)
                                                        continue;
                                                    Color aa;
                                                    if (Order == -1)
                                                        aa = Color.Gray;
                                                    else
                                                        aa = Color.Brown;
                                                    if (Support(Table, g, h, ii, jj, aa, Table[g, h]))
                                                    {
                                                        Supported = true;
                                                        Sign *= 10;
                                                        if (System.Math.Abs(Table[g, h]) == 1)
                                                            HA -= (Sign * System.Math.Abs(SodierValue + GetObjectValue(Table[ii, jj])
                                                                ));
                                                        else if (System.Math.Abs(Table[g, h]) == 2)
                                                            HA -= (Sign * System.Math.Abs(ElefantValue + GetObjectValue(Table[ii, jj])
                                                                ));
                                                        else if (System.Math.Abs(Table[g, h]) == 3)
                                                            HA -= (Sign * System.Math.Abs(HourseValue + GetObjectValue(Table[ii, jj])
                                                                ));
                                                        else if (System.Math.Abs(Table[g, h]) == 4)
                                                            HA -= (Sign * System.Math.Abs(BridgeValue + GetObjectValue(Table[ii, jj])
                                                                ));
                                                        else if (System.Math.Abs(Table[g, h]) == 5)
                                                            HA -= (Sign * System.Math.Abs(MinisterValue + GetObjectValue(Table[ii, jj])
                                                                ));
                                                        else if (System.Math.Abs(Table[g, h]) == 6)
                                                            HA -= (Sign * System.Math.Abs(KingValue + GetObjectValue(Table[ii, jj])
                                                                ));

                                                    }
                                                }
                                            if (!Supported)
                                                HA *= 100;
                                            else
                                                HA *= -100;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            catch (Exception t)
            {
            }
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            Order = DumOrder;
            //Initiate to Begin Call Orders.
            //Add Local Huristic to Global One.
            HuristicValue += HA * SignOrderToPlate(Order);
            return HA;
        }
        //QC-OK.
        float HuristicReducsedAttack(int[,] Table, int Order, Color a)
        {
            int HA = 0;
            int DumOrder = Order;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            ///When AStarGreedy Huristic is Not Assigned.
            try
            {
                if (!AStarGreedyHuristic)
                {
                    ///For Every Objects.
                    int i = Row, j = Column;
                    ///For All Movments.
                    for (int ii = 0; ii < 8; ii++)
                    {
                        for (int jj = 0; jj < 8; jj++)
                        {
                            if (i == ii && j == jj)
                                continue;
                            int Sign = 1;
                            Order = DummyOrder;
                            ///When Attack is true. means [ii,jj] is in Attacked  [i,j].
                            ///What is Attack!
                            ///Ans:When [ii,jj] is Attacked [i,j] return true when enemy is located in [ii,jj].
                            if (Table[ii, jj] > 0 && DummyOrder == -1 && Table[i, j] < 0)
                            {
                                Order = 1;
                                Sign = -100 * AllDraw.SignReducedAttacked;
                                ChessRules.CurrentOrder = 1;
                                a = Color.Gray;
                            }
                            else if (Table[ii, jj] < 0 && DummyOrder == 1 && Table[i, j] > 0)
                            {
                                Order = -1;
                                Sign = -100 * AllDraw.SignReducedAttacked;
                                ChessRules.CurrentOrder = -1;
                                a = Color.Brown;
                            }
                            /*  else
                                  if (Table[ii, jj] < 0 && DummyOrder == -1 && Table[i, j] > 0)
                                  {
                                      Order = -1;
                                      Sign = 100 * AllDraw.SignReducedAttacked;
                                      ChessRules.CurrentOrder = -1;
                                      a = Color.Brown;
                                  }
                                  else if (Table[ii, jj] > 0 && DummyOrder == 1 && Table[i, j] < 0)
                                  {
                                      Order = 1;
                                      Sign = 100 * AllDraw.SignReducedAttacked;
                                      ChessRules.CurrentOrder = 1;
                                      a = Color.Gray;
                                  }
                             */
                            else
                                continue;
                            //For Attack Movments.
                            if (Attack(Table, ii, jj, i, j, a, Order))
                            {
                                //Finf Huristic Value Of Current and Add to Sumation.
                                {

                                    if (System.Math.Abs(Table[i, j]) == 1)
                                        HA += (Sign * System.Math.Abs(SodierValue + GetObjectValue(Table[ii, jj])
                                            ));
                                    else if (System.Math.Abs(Table[i, j]) == 2)
                                        HA += (Sign * System.Math.Abs(ElefantValue + GetObjectValue(Table[ii, jj])
                                            ));
                                    else if (System.Math.Abs(Table[i, j]) == 3)
                                        HA += (Sign * System.Math.Abs(HourseValue + GetObjectValue(Table[ii, jj])
                                            ));
                                    else if (System.Math.Abs(Table[i, j]) == 4)
                                        HA += (Sign * System.Math.Abs(BridgeValue + GetObjectValue(Table[ii, jj])
                                            ));
                                    else if (System.Math.Abs(Table[i, j]) == 5)
                                        HA += (Sign * System.Math.Abs(MinisterValue + GetObjectValue(Table[ii, jj])
                                            ));
                                    else if (System.Math.Abs(Table[i, j]) == 6)
                                        HA += (Sign * System.Math.Abs(KingValue + GetObjectValue(Table[ii, jj])
                                            ));

                                }



                            }





                        }
                    }

                }
                //For All Table Homes find Attack Huristic.
                else
                {
                    for (int i = 0; i < 8; i++)
                    {
                        for (int j = 0; j < 8; j++)
                        {
                            for (int ii = 0; ii < 8; ii++)
                            {
                                for (int jj = 0; jj < 8; jj++)
                                {
                                    if (i == ii && j == jj)
                                        continue;
                                    Order = DummyOrder;
                                    int Sign = 1;
                                    ///When Attack is true. means [ii,jj] is in Attacked  [i,j].
                                    ///What is Attack!
                                    ///Ans:When [ii,jj] is Attacked [i,j] return true when enemy is located in [ii,jj].
                                    if (Table[ii, jj] > 0 && DummyOrder == -1 && Table[i, j] < 0)
                                    {
                                        Order = 1;
                                        Sign = -100 * AllDraw.SignReducedAttacked;
                                        ChessRules.CurrentOrder = 1;
                                        a = Color.Gray;
                                    }
                                    else if (Table[ii, jj] < 0 && DummyOrder == 1 && Table[i, j] > 0)
                                    {
                                        Order = -1;
                                        Sign = -100 * AllDraw.SignReducedAttacked;
                                        ChessRules.CurrentOrder = -1;
                                        a = Color.Brown;
                                    }
                                    /*       else
                                               if (Table[ii, jj] < 0 && DummyOrder == -1 && Table[i, j] > 0)
                                               {
                                                   Order = -1;
                                                   Sign = 100 * AllDraw.SignReducedAttacked;
                                                   ChessRules.CurrentOrder = -1;
                                                   a = Color.Brown;
                                               }
                                               else if (Table[ii, jj] > 0 && DummyOrder == 1 && Table[i, j] < 0)
                                               {
                                                   Order = 1;
                                                   Sign = 100 * AllDraw.SignReducedAttacked;
                                                   ChessRules.CurrentOrder = 1;
                                                   a = Color.Gray;
                                               }

                                     */
                                    else continue;
                                    //For Attack Movments.
                                    if (Attack(Table, ii, jj, i, j, a, Order))
                                    {

                                        //Find Huristic Movments Attack.
                                        {

                                            if (System.Math.Abs(Table[i, j]) == 1)
                                                HA += (Sign * System.Math.Abs(SodierValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[i, j]) == 2)
                                                HA += (Sign * System.Math.Abs(ElefantValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[i, j]) == 3)
                                                HA += (Sign * System.Math.Abs(HourseValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[i, j]) == 4)
                                                HA += (Sign * System.Math.Abs(BridgeValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[i, j]) == 5)
                                                HA += (Sign * System.Math.Abs(MinisterValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                            else if (System.Math.Abs(Table[i, j]) == 6)
                                                HA += (Sign * System.Math.Abs(KingValue + GetObjectValue(Table[ii, jj])
                                                    ));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception t)
            {
            }

            //Initiate to Begin Call Orders.
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            Order = DumOrder;
            //Add Local Huristic to Global One.
            HuristicValue += HA * SignOrderToPlate(Order);
            return HA;
        }
        ///QC-OK.
        int GetObjectValue(int Object)
        {
            int HA = 0;
            if (System.Math.Abs(Object) == 1)
                HA = 1;
            else if (System.Math.Abs(Object) == 2)
                HA = 2;
            else if (System.Math.Abs(Object) == 3)
                HA = 3;
            else if (System.Math.Abs(Object) == 4)
                HA = 5;
            else if (System.Math.Abs(Object) == 5)
                HA = 8;
            else if (System.Math.Abs(Object) == 6)
                HA = 10;
            return HA;

        }
        ///Huristic of ObjectDanger.QC-OK
        float HuristicObjectDangour(int[,] Table, int Order, Color a)
        {
            int HA = 0;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            ///When There is no AStarGreedyHuristic
            try
            {
                if (!AStarGreedyHuristic)
                {
                    ///For Every Object.
                    int i = Row, j = Column;
                    ///For All Object in Current Table.
                    for (int ii = 0; ii < 8; ii++)
                    {
                        for (int jj = 0; jj < 8; jj++)
                        {
                            if (i == ii && j == jj)
                                continue;
                            Order = DummyOrder;
                            int Sign = 1;
                            ///When ObjectDanger is true. means [ii,jj] is in ObjectDanger by [i,j].
                            ///What is ObjectDanger!
                            ///Ans:When [i,j] is Attacked [ii,jj] return true when enemy is located in [ii,jj].
                            if (Table[ii, jj] > 0 && DummyOrder == -1 && Table[i, j] < 0)
                            {
                                Order = 1;
                                Sign = -100 * AllDraw.SignObjectDangour;
                                ChessRules.CurrentOrder = 1;
                                a = Color.Gray;
                            }
                            else if (Table[ii, jj] < 0 && DummyOrder == 1 && Table[i, j] > 0)
                            {
                                Order = -1;
                                Sign = -100 * AllDraw.SignObjectDangour;
                                ChessRules.CurrentOrder = -1;
                                a = Color.Brown;
                            }
                            /*else
                                if (Table[ii, jj] < 0 && DummyOrder == -1 && Table[i, j] > 0)
                                {
                                    Order = -1;
                                    Sign = 100 * AllDraw.SignObjectDangour;
                                    ChessRules.CurrentOrder = -1;
                                    a = Color.Brown;
                                }
                                else if (Table[ii, jj] > 0 && DummyOrder == 1 && Table[i, j] < 0)
                                {
                                    Order = 1;
                                    Sign = 100 * AllDraw.SignObjectDangour;
                                    ChessRules.CurrentOrder = 1;
                                    a = Color.Gray;
                                }
                             */
                            else
                                continue;
                            //For ObjectDanger Movments.
                            if (ObjectDanger(Table, ii, jj, i, j, a, Order))
                            {
                                //Find Local Sumation of ObjectDanger Huristic.
                                {
                                    if (System.Math.Abs(Table[i, j]) == 1)
                                        HA += Sign * System.Math.Abs(SodierValue);
                                    else if (System.Math.Abs(Table[i, j]) == 2)
                                        HA += Sign * System.Math.Abs(ElefantValue);
                                    else if (System.Math.Abs(Table[i, j]) == 3)
                                        HA += Sign * System.Math.Abs(HourseValue);
                                    else if (System.Math.Abs(Table[i, j]) == 4)
                                        HA += Sign * System.Math.Abs(BridgeValue);
                                    else if (System.Math.Abs(Table[i, j]) == 5)
                                        HA += Sign * System.Math.Abs(MinisterValue);
                                    else if (System.Math.Abs(Table[i, j]) == 6)
                                        HA += Sign * System.Math.Abs(KingValue);
                                }



                            }





                        }
                    }

                }
                //For All Table Home Find ObjectDanger Huristic
                else
                {
                    for (int i = 0; i < 8; i++)
                    {
                        for (int j = 0; j < 8; j++)
                        {
                            for (int ii = 0; ii < 8; ii++)
                            {
                                for (int jj = 0; jj < 8; jj++)
                                {
                                    if (i == ii && j == jj)
                                        continue;
                                    int Sign = 1;
                                    ///When ObjectDanger is true. means [ii,jj] is in ObjectDanger by [i,j].
                                    ///What is ObjectDanger!
                                    ///Ans:When [i,j] is Attacked [ii,jj] return true when enemy is located in [ii,jj].
                                    if (Table[ii, jj] > 0 && DummyOrder == -1 && Table[i, j] < 0)
                                    {
                                        Order = 1;
                                        Sign = -100 * AllDraw.SignObjectDangour;
                                        ChessRules.CurrentOrder = 1;
                                        a = Color.Gray;
                                    }
                                    else if (Table[ii, jj] < 0 && DummyOrder == 1 && Table[i, j] > 0)
                                    {
                                        Order = -1;
                                        Sign = -100 * AllDraw.SignObjectDangour;
                                        ChessRules.CurrentOrder = -1;
                                        a = Color.Brown;
                                    }
                                    /*     else
                                             if (Table[ii, jj] < 0 && DummyOrder == -1 && Table[i, j] > 0)
                                             {
                                                 Order = -1;
                                                 Sign = 100 * AllDraw.SignObjectDangour;
                                                 ChessRules.CurrentOrder = -1;
                                                 a = Color.Brown;
                                             }
                                             else if (Table[ii, jj] > 0 && DummyOrder == 1 && Table[i, j] < 0)
                                             {
                                                 Order = 1;
                                                 Sign = 100 * AllDraw.SignObjectDangour;
                                                 ChessRules.CurrentOrder = 1;
                                                 a = Color.Gray;
                                             }
                                     */
                                    else
                                        continue;

                                    //For Current Movments of legal Movments.
                                    if (ObjectDanger(Table, ii, jj, i, j, a, Order))
                                    {
                                        //Find ObjectDanger Huristic Locals.
                                        {
                                            if (System.Math.Abs(Table[i, j]) == 1)
                                                HA += Sign * System.Math.Abs(SodierValue);
                                            else if (System.Math.Abs(Table[i, jj]) == 2)
                                                HA += Sign * System.Math.Abs(ElefantValue);
                                            else if (System.Math.Abs(Table[i, j]) == 3)
                                                HA += Sign * System.Math.Abs(HourseValue);
                                            else if (System.Math.Abs(Table[i, jj]) == 4)
                                                HA += Sign * System.Math.Abs(BridgeValue);
                                            else if (System.Math.Abs(Table[i, j]) == 5)
                                                HA += Sign * System.Math.Abs(MinisterValue);
                                            else if (System.Math.Abs(Table[i, j]) == 6)
                                                HA += Sign * System.Math.Abs(KingValue);

                                        }

                                    }





                                }
                            }
                        }
                    }
                }
            }
            catch (Exception t)
            {
            }
            //Initiate Orders to Call Begining.
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            //Assignments of Global Huristic with Local One.
            HuristicValueObjectDangourCheckMate += HA * SignOrderToPlate(Order);
            //return Local Huristic.
            return HA;
        }
        void HuristicHitting(int[,] Tab, int i, int j, int Order, Color a, bool Hit)
        {
            //Defualt is Gray Order.
            double HA = 0.0;
            int Sign = AllDraw.SignHitting * 100;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;

            try
            {
                for (int iii = 0; iii < 8; iii++)
                    for (int jjj = 0; jjj < 8; jjj++)
                    {

                        Color colorAS = a;
                        if (Tab[iii, jjj] > 0)
                        {
                            Order = 1;
                            if (Order != FormRefrigtz.OrderPlate)
                                Sign *= -1;
                            ChessRules.CurrentOrder = 1;
                            a = Color.Gray;
                        }
                        else
                            if (Tab[iii, jjj] < 0)
                            {
                                Order = -1;
                                if (Order != FormRefrigtz.OrderPlate)
                                    Sign *= -1;
                                ChessRules.CurrentOrder = -1;
                                a = Color.Brown;
                            }
                        if ((new ThinkingChess(iii, jjj)).Attack(Tab, iii, jjj, i, j, a, Order))
                        {
                            //Sign = -9 * AllDraw.SignHitting;
                            if (System.Math.Abs(Tab[iii, jjj]) == 1)
                                HA += (float)((Sign * GetObjectValue(Tab[i, j]) + SodierValue
                                    ) * Sign);
                            else
                                if (System.Math.Abs(Tab[iii, jjj]) == 2)
                                    HA += (float)((GetObjectValue(Tab[i, j]) + ElefantValue
                                        ) * Sign);
                                else
                                    if (System.Math.Abs(Tab[iii, jjj]) == 3)
                                        HA += (float)((GetObjectValue(Tab[i, j]) + HourseValue
                                            ) * Sign);
                                    else
                                        if (System.Math.Abs(Tab[iii, jjj]) == 4)
                                            HA += (float)((GetObjectValue(Tab[i, j]) + BridgeValue
                                                ) * Sign);
                                        else
                                            if (System.Math.Abs(Tab[iii, jjj]) == 5)
                                                HA += (float)((GetObjectValue(Tab[i, j]) + MinisterValue
                                                    ) * Sign);
                                            else
                                                if (System.Math.Abs(Tab[iii, jjj]) == 6)
                                                    HA += (float)((GetObjectValue(Tab[i, j]) + KingValue
                                                        ) * Sign);
                        }


                        a = colorAS;

                        HuristicValue += HA * SignOrderToPlate(Order);
                    }
            }
            catch (Exception t)
            {
            }
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;


        }
        //Attacks Of Enemy that is not Supported.QC-OK
        bool InAttackedEnemyNotSupporetd(int[,] Table, int Order, Color a, int iii, int jjj, int i, int j)
        {
            //Initiate Global Variables.
            int[,] Tab = new int[8, 8];
            for (int ik = 0; ik < 8; ik++)
                for (int jk = 0; jk < 8; jk++)
                    Tab[ik, jk] = Table[ik, jk];
            EE = false;
            int Cdum = ChessRules.CurrentOrder;
            int COr = Order;
            InAttackedNotEnemySupported = false;
            EnemyNotSupported = false;
            ExistingOfEnemyHiiting = false;
            //For Enemy Order.
            for (int ii = 0; ii < 8; ii++)
            {
                for (int jj = 0; jj < 8; jj++)
                {
                    InAttackedNotEnemySupported = false;
                    //Ignore of self Order.
                    if (Order == 1 && Tab[ii, jj] >= 0)
                        continue;
                    else
                        if (Order == -1 && Tab[ii, jj] <= 0)
                            continue;
                    //For Current Order.
                    //int iiii = iii, jjjj = jjj;
                    for (int iiii = 0; iiii < 8; iiii++)
                    {
                        for (int jjjj = 0; jjjj < 8; jjjj++)
                        {
                            ChessRules.CurrentOrder = Cdum;
                            Order = COr;
                            //Ignore of Enemy Order.
                            if (Order == 1 && Tab[iiii, jjjj] <= 0)
                                continue;
                             else
                               if (Order == -1 && Tab[iiii, jjjj] >= 0)
                                   continue;
                            EE = GetObjectValue(Tab[ii, jj]) > GetObjectValue(Tab[iiii, jjjj]);

                            //When Current Objet Attacked Enemy.
                            if (Attack(Tab, iiii, jjjj, ii, jj, a, Order))
                            {
                                InAttackedNotEnemySupported = true;
                                ExistingOfEnemyHiiting = false;

                                //For All Enemy Objects.
                                for (int iiiii = 0; iiiii < 8; iiiii++)
                                {
                                    for (int jjjjj = 0; jjjjj < 8; jjjjj++)
                                    {
                                        //Ignore of self Order.
                                        if (Order == 1 && Tab[iiiii, jjjjj] >= 0)
                                            continue;
                                        else
                                            if (Order == -1 && Tab[iiiii, jjjjj] <= 0)
                                                continue;
                                        //If Order is Gray.
                                        if (Order == 1)
                                        {
                                            //Set Enemy Order.
                                            ChessRules.CurrentOrder = -1;
                                            //When Enemy is Supporeted.
                                            if (Support(Tab, iiiii, jjjjj, ii, jj, Color.Brown, -1))
                                            {

                                                //Set false and return false.
                                                ExistingOfEnemyHiiting = true;
                                                break;
                                            }
                                            else
                                            {

                                                //Set True.
                                                ExistingOfEnemyHiiting = false;
                                                continue;
                                            }

                                        }
                                        //Brown Order.
                                        else
                                        {
                                            //For Enemy Order.
                                            ChessRules.CurrentOrder = 1;
                                            //When Enemy is Supported.
                                            if (Support(Tab, iiiii, jjjjj, ii, jj, Color.Gray, 1))
                                            {
                                                //Set false and return false.
                                                ExistingOfEnemyHiiting = true;
                                                ChessRules.CurrentOrder = Cdum;
                                                Order = COr;
                                                break;
                                            }
                                            else
                                            {
                                                //Set true.
                                                ExistingOfEnemyHiiting = false;
                                                continue;
                                            }
                                        }
                                    }
                                    if (ExistingOfEnemyHiiting)
                                        break;

                                }
                            }
                            if (ExistingOfEnemyHiiting)
                                break;
                        }
                        if (ExistingOfEnemyHiiting)
                            break;

                    }

                    if (ExistingOfEnemyHiiting)
                        break;

                }
                if (ExistingOfEnemyHiiting)
                    break;
            }
            if (!ExistingOfEnemyHiiting)
            {
                EnemyNotSupported = true;
            }
            else
            {
                EnemyNotSupported = false;
            }
            return true;
        }
        //Supported of Self that is Not Attacks.QC-OK
        bool InAttackedُSelfNotSupporetd(int[,] Table, int Order, Color a, int ij, int ji)
        {
            //if (System.Math.Abs(Tab[i, j]) == 6)
            //    return false;
            int[,] Tab = new int[8, 8];
            for (int ik = 0; ik < 8; ik++)
                for (int jk = 0; jk < 8; jk++)
                    Tab[ik, jk] = Table[ik, jk];
            InAttackedNotSelfSupported = false;
            SelfSupported = false;
            bool Supported = false;
            bool DangourousSupporter = false;
            //Fow Current Objects.
            for (int i = 0; i < 8; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    InAttackedNotSelfSupported = false;
                    if (Tab[i, j] <= 0 && Order == 1)
                        continue;
                    if (Tab[i, j] >= 0 && Order == -1)
                        continue;
                    int Dum = ChessRules.CurrentOrder;
                    //For Enemy.
                    for (int iii = 0; iii < 8; iii++)
                    {
                        for (int jjj = 0; jjj < 8; jjj++)
                        {
                            if (Tab[iii, jjj] >= 0 && Order == 1)
                                continue;
                            if (Tab[iii, jjj] <= 0 && Order == -1)
                                continue;
                            bool E = GetObjectValue(Tab[i, j]) >= GetObjectValue(Tab[iii, jjj]);
                            if (E)
                            {

                                //Gray Order.
                                if (Order == 1)
                                {
                                    //Set Enemy Order.
                                    ChessRules.CurrentOrder = -1;
                                    //When Enemy Attacked Cuurent Object.
                                    int COr = Order;
                                    Order *= -1;
                                    if (Attack(Tab, iii, jjj, i, j, Color.Brown, Order))
                                    {
                                        Order = COr;
                                        //Setting true.
                                        InAttackedNotSelfSupported = true;
                                        //For Current Order and Setting false for Supporation.
                                        ChessRules.CurrentOrder = Dum;
                                        Supported = false;
                                        DangourousSupporter = false;
                                        //For Current Order.
                                        for (int ii = 0; ii < 8; ii++)
                                        {
                                            for (int jj = 0; jj < 8; jj++)
                                            {
                                                //Ignore of Enemy.
                                                if (Tab[ii, jj] <= 0)
                                                    continue;
                                                //Setting Current Order.
                                                ChessRules.CurrentOrder = Order;
                                                //Wen Current Object Supported.
                                                if (Support(Tab, ii, jj, i, j, a, Order))
                                                {
                                                    //if (GetObjectValue(Tab[iii, jjj]) > GetObjectValue(Tab[i, j]))
                                                    //    {
                                                    //Setting Sepported true and break.
                                                    Supported = true;
                                                    break;
                                                    //}
                                                    //else
                                                    /// {
                                                    //     Supported = false;
                                                    //     DangourousSupporter = true;
                                                    // }
                                                }

                                            }
                                            if (Supported)
                                                break;
                                        }
                                    }
                                    Order = COr;

                                }
                                //For Brown Order.
                                else
                                {
                                   //Setting Enemy Order.
                                    ChessRules.CurrentOrder = 1;
                                    //Wen Enemy Atta
                                    int COr = Order;
                                    Order *= -1;
                                    if (Attack(Tab, iii, jjj, i, j, Color.Gray, Order))
                                    {
                                        Order = COr;
                                        //Setting true.
                                        InAttackedNotSelfSupported = true;
                                        //Setting Current Order and setting Supported false.
                                        ChessRules.CurrentOrder = Dum;
                                        Supported = false;
                                        //For Current Objects.
                                        for (int ii = 0; ii < 8; ii++)
                                        {
                                            for (int jj = 0; jj < 8; jj++)
                                            {
                                                //Ignore of Enemy Objects.
                                                if (Tab[ii, jj] >= 0)
                                                    continue;
                                                //For Current Objects.
                                                ChessRules.CurrentOrder = Order;
                                                //When Cuurent Objects has Supporeted.
                                                if (Support(Tab, ii, jj, i, j, a, Order))
                                                {
                                                    //if (GetObjectValue(Tab[iii, jjj]) > GetObjectValue(Tab[i, j]))
                                                    //{
                                                    //Setting Supporeted and break.
                                                    Supported = true;
                                                    break;
                                                    //}
                                                    //else
                                                    //{
                                                    //  Supported = false;
                                                    //DangourousSupporter = true;
                                                    //break;
                                                    //}
                                                }

                                            }
                                            if (Supported)
                                                break;

                                        }
                                        if (Supported)
                                            break;

                                    }
                                    Order = COr;
                                }
                            }
                            if (Supported)
                                break;
                        }
                        if (Supported)
                            break;
                    }
                    ChessRules.CurrentOrder = Dum;
                    if (Supported || InAttackedNotSelfSupported)
                        break;

                }
                if (Supported || InAttackedNotSelfSupported)
                    break;

            }
            //When Current condition return true.
            if (Supported)
            {
                SelfSupported = true;
                return true;
            }
            else
                //return false.
                SelfSupported = false;
            return false;
        }

        ///Huristic of Suportation.
        float HuristicSelfSupported(int[,] Tab, int Order, Color a)
        {
            //Initiate Local Vrariables.
            int HA = 0;
            int DumOrder = Order;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            //If There is Not AStarGreedy Huristic Boolean Value.
            try
            {
                if (!AStarGreedyHuristic)
                {
                    //For Current Object Lcation.
                    int i = Row, j = Column;
                    //In All Homes of Table.
                    for (int ii = 0; ii < 8; ii++)
                    {
                        for (int jj = 0; jj < 8; jj++)
                        {
                            //Ignore Current Unnessery Home.
                            if (i == ii && j == jj)
                                continue;
                            //Default Is Gray One.
                            int Sign = 1;
                            Order = DummyOrder;
                            ///When Supporte is true. means [ii,jj] Supportes [i,j].
                            ///What is Supporte!
                            ///Ans:When [i,j] is Supporte [ii,jj] return true when Self is located in [ii,jj].
                            if (Tab[ii, jj] < 0 && DummyOrder == -1 && Tab[i, j] < 0)
                            {
                                Order = -1;
                                Sign = 100 * AllDraw.SignSupport;
                                ChessRules.CurrentOrder = -1;
                                a = Color.Brown;
                            }
                            else if (Tab[ii, jj] > 0 && DummyOrder == 1 && Tab[i, j] > 0)
                            {
                                Order = 1;
                                Sign = 100 * AllDraw.SignSupport;
                                ChessRules.CurrentOrder = 1;
                                a = Color.Gray;
                            }
                            /* else
                                 if (Tab[ii, jj] > 0 && DummyOrder == -1 && Tab[i, j] > 0)
                                 {
                                     Order = 1;
                                     Sign = -100 * AllDraw.SignSupport;
                                     ChessRules.CurrentOrder = 1;
                                     a = Color.Gray;
                                 }
                                 else if (Tab[ii, jj] < 0 && DummyOrder == 1 && Tab[i, j] < 0)
                                 {
                                     Order = -1;
                                     Sign = -100 * AllDraw.SignSupport;
                                     ChessRules.CurrentOrder = -1;
                                     a = Color.Brown;
                                 }
                             */
                            else
                                continue;
                            //For Support Movments.
                            if (Support(Tab, ii, jj, i, j, a, Order))
                            {
                                //Calculate Local Support Huristic.
                                {


                                    if (System.Math.Abs(Tab[ii, jj]) == 1)
                                        HA += (Sign * System.Math.Abs(SodierValue + GetObjectValue(Tab[i, j])
                                            ));
                                    else if (System.Math.Abs(Tab[ii, jj]) == 2)
                                        HA += (Sign * System.Math.Abs(ElefantValue + GetObjectValue(Tab[i, j])
                                            ));
                                    else if (System.Math.Abs(Tab[ii, jj]) == 3)
                                        HA += (Sign * System.Math.Abs(HourseValue + GetObjectValue(Tab[i, j])
                                            ));
                                    else if (System.Math.Abs(Tab[ii, jj]) == 4)
                                        HA += (Sign * System.Math.Abs(BridgeValue + GetObjectValue(Tab[i, j])
                                            ));
                                    else if (System.Math.Abs(Tab[ii, jj]) == 5)
                                        HA += (Sign * System.Math.Abs(MinisterValue + GetObjectValue(Tab[i, j])
                                            ));
                                    else if (System.Math.Abs(Tab[ii, jj]) == 6)
                                        HA += (Sign * System.Math.Abs(KingValue + GetObjectValue(Tab[i, j])
                                            ));
                                }
                            }


                        }
                    }

                }
                //For All Homes Table.
                else
                {
                    for (int i = 0; i < 8; i++)
                    {
                        for (int j = 0; j < 8; j++)
                        {
                            for (int ii = 0; ii < 8; ii++)
                            {
                                for (int jj = 0; jj < 8; jj++)
                                {
                                    //Ignore Current Home.
                                    if (i == ii && j == jj)
                                        continue;
                                    //Initiate Local Variables.
                                    int Sign = 1;
                                    Order = DummyOrder;
                                    ///When Supporte is true. means [ii,jj] is in SelfSupported.by [i,j].
                                    ///What is Supporte!
                                    ///Ans:When [i,j] is Supporte [ii,jj] return true when Self is located in [ii,jj].
                                    if (Tab[ii, jj] < 0 && DummyOrder == -1 && Tab[i, j] < 0)
                                    {
                                        Order = -1;
                                        Sign = 100 * AllDraw.SignSupport;
                                        ChessRules.CurrentOrder = -1;
                                        a = Color.Brown;
                                    }
                                    else if (Tab[ii, jj] > 0 && DummyOrder == 1 && Tab[i, j] > 0)
                                    {
                                        Order = 1;
                                        Sign = 100 * AllDraw.SignSupport;
                                        ChessRules.CurrentOrder = 1;
                                        a = Color.Gray;
                                    }
                                    /*      else
                                              if (Tab[ii, jj] > 0 && DummyOrder == -1 && Tab[i, j] > 0)
                                              {
                                                  Order = 1;
                                                  Sign = -100 * AllDraw.SignSupport;
                                                  ChessRules.CurrentOrder = 1;
                                                  a = Color.Gray;
                                              }
                                              else if (Tab[ii, jj] < 0 && DummyOrder == 1 && Tab[i, j] < 0)
                                              {
                                                  Order = -1;
                                                  Sign = -100 * AllDraw.SignSupport;
                                                  ChessRules.CurrentOrder = -1;
                                                  a = Color.Brown;
                                              }
                                     */
                                    else
                                        continue;
                                    //For Support Movments.
                                    if (Support(Tab, ii, jj, i, j, a, Order))
                                    {
                                        {
                                            if (System.Math.Abs(Tab[ii, jj]) == 1)
                                                HA += (Sign * System.Math.Abs(SodierValue + GetObjectValue(Tab[i, j])
                                                    ));
                                            else if (System.Math.Abs(Tab[ii, jj]) == 2)
                                                HA += (Sign * System.Math.Abs(ElefantValue + GetObjectValue(Tab[i, j])
                                                    ));
                                            else if (System.Math.Abs(Tab[ii, jj]) == 3)
                                                HA += (Sign * System.Math.Abs(HourseValue + GetObjectValue(Tab[i, j])
                                                    ));
                                            else if (System.Math.Abs(Tab[ii, jj]) == 4)
                                                HA += (Sign * System.Math.Abs(BridgeValue + GetObjectValue(Tab[i, j])
                                                    ));
                                            else if (System.Math.Abs(Tab[ii, jj]) == 5)
                                                HA += (Sign * System.Math.Abs(MinisterValue + GetObjectValue(Tab[i, j])
                                                    ));
                                            else if (System.Math.Abs(Tab[ii, jj]) == 6)
                                                HA += (Sign * System.Math.Abs(KingValue + GetObjectValue(Tab[i, j])
                                                    ));
                                        }


                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception t)
            {
            }

            //Reassignments of Global Orders with Local Begining One.
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            Order = DumOrder;
            HuristicValueSelfSupported += HA * SignOrderToPlate(Order);
            return HA;
        }
        ///Identification of Equality
        public static bool TableEqual(int[,] Tab1, int[,] Tab2)
        {
            try
            {
                //For All Home
                for (int i = 0; i < 8; i++)
                    for (int j = 0; j < 8; j++)
                    {
                        //When there is different values in same location of tow Table return non equality.
                        if (Tab1[i, j] != Tab2[i, j])
                            return false;
                    }
                //Else return equlity.
                return true;
            }
            catch (Exception t)
            {
                
                return false;
            }
        }
        public static bool TableEqual(int Tab1, int Tab2)
        {
            try
            {
                //For All Home
                //for (int i = 0; i < 8; i++)
                //  for (int j = 0; j < 8; j++)
                {
                    //When there is different values in same location of tow Table return non equality.
                    if (Tab1 != Tab2)
                        return false;
                }
                //Else return equlity.
                return true;
            }
            catch (Exception t)
            {
                
                return false;
            }
        }
        //Deterimination of Existance of Table in List.QC-OK.
        static public bool ExistTableInList(int[,] Tab, List<int[,]> List, int Index)
        {
            //Initiate Local Variables.
            bool Exist = false;
            //For All Tables of Table List.
            for (int i = Index; i < List.Count; i++)
            {
                //Strore Equality Value.
                bool Eq = TableEqual(Tab, List[i]);
                //When is Equality is Occurred.
                if (Eq)
                {
                    //Store Equality Local Value in a Global static value.
                    AllDraw.LoopHuristicIndex = i;
                    return Eq;
                }
                Exist |= Eq;
            }
            //return Equality Local value of all lists.
            return Exist;
        }
        ///Move Determination.QC-OK
        public bool Movable(int[,] Tab, int i, int j, int ii, int jj, Color a, int Order)
        {
            int[,] Table = new int[8, 8];
            for (int p = 0; p < 8; p++)
                for (int k = 0; k < 8; k++)
                    Table[p, k] = Tab[p, k];
            //Initiate Local Variables.
            int Store = Table[ii, jj];
            ChessRules A = new ChessRules(Table[i, j], Table, Order, i, j);
            ///Table[ii, jj] = 0;
            //Menen Parameter is Moveble to Second Parameters Location returm Movable.
            if (A.Rules(i, j, ii, jj, a, Order))
            {
                //Initiate Movments.
                Table[ii, jj] = Table[i, j];
                Table[i, j] = 0;
                //Default Order Assignments.
                int Ord = 1;
                //Brown Order Consideration.
                if (Table[ii, jj] < 0)
                    Ord = -1;
                //Store of Local Order Assignments in Global Assignments.
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                //Consider Global Check Variables.
                ChessRules AA = new ChessRules(Table[ii, jj], Table, Ord, ii, jj);
                AA.Check(Table, Ord);
                //Reaasignment of Premitive Variables.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //Reassignments of Table Content and Consider CheckMate Specific Order.
                Table[i, j] = Table[ii, jj];

                if (Table[i, j] > 0)
                {
                    Table[ii, jj] = Store;
                    if (AA.CheckMateGray)
                        return false;


                    return true;
                }


                if (Table[i, j] < 0)
                {
                    Table[ii, jj] = Store;
                    if (AA.CheckMateBrown)
                        return false;
                    return true;
                }


            }

            Table[ii, jj] = Store;
            return false;
        }
        //QC-OK
        double SignOrderToPlate(int Order)
        {
            double Sign = 1.0;
            if (Order == FormRefrigtz.OrderPlate)
                Sign = 1.0;
            else
                if (Order != FormRefrigtz.OrderPlate)
                    Sign = -1.0;
            return Sign;

        }
        public bool RemovePenalty(int[,] Tab, int Order, int i, int j)
        {
            bool Remove = false;
            ChessRules AA = new ChessRules(Tab[i, j], Tab, Order, i, j);
            if (AA.Check(Tab, Order))
            {
                if (Order == 1 && (AA.CheckGray || AA.CheckGrayObjectDangour))
                    return Remove;
                if (Order == -1 && (AA.CheckBrown || AA.CheckBrownObjectDangour))
                    return Remove;
            }
            


            //For Enemy.
            for (int ii = 0; ii < 8; ii++)
                for (int jj = 0; jj < 8; jj++)
                {
                    if (Order == 1 && Tab[ii, jj] >= 0)
                        continue;
                    if (Order == -1 && Tab[ii, jj] <= 0)
                        continue;
                    //Clone a Copy.
                    int[,] Table = new int[8, 8];
                    for (int iii = 0; iii < 8; iii++)
                        for (int jjj = 0; jjj < 8; jjj++)
                            Table[iii, jjj] = Tab[iii, jjj];
                    ChessRules A = new ChessRules(Table[ii, jj], Table, Order * -1, ii, jj);
                    Color a = Color.Gray;
                    if (Order * -1 == -1)
                        a = Color.Brown;
                    //When there is movment to current OPbject.
                    if (A.Rules(ii, jj, i, j, a, Table[ii, jj]))
                    {
                        //Number of Attacks and take move.
                        int Count = AttackerCount(Table, Order * -1, a, ii, jj);
                        Table[i, j] = Table[ii, jj];
                        Table[ii, jj] = 0;
                        //When there is Object Danger.
                       /* A.ObjectDangourKingMove(Order, Table, false);                    

                         
                        if (Order == 1 && (!A.CheckGrayObjectDangour))
                        {
                            Remove = true;
                            return Remove;
                        }
                        if (Order == -1 && (!A.CheckBrownObjectDangour))
                        {
                            Remove = true;
                            return Remove;
                        }

                        */ 
                        //Clone a Copy.
                        for (int iii = 0; iii < 8; iii++)
                            for (int jjj = 0; jjj < 8; jjj++)
                                Table[iii, jjj] = Tab[iii, jjj];
                        A = new ChessRules(Table[ii, jj], Table, Order, ii, jj);
                        a = Color.Gray;
                        if (Order == -1)
                            a = Color.Brown;
                        //When Current Movments Attacks Enemy.
                        if (Attack(Table, i, j, ii, jj, a, Order))
                        {
                            //For Current Home.
                            for (int iii = 0; iii < 8; iii++)
                                for (int jjj = 0; jjj < 8; jjj++)
                                {
                                    if (Order == 1 && Tab[iii, jjj] <= 0)
                                        continue;
                                    if (Order == -1 && Tab[iii, jjj] >= 0)
                                        continue;
                                    //Whn Value Of Current is Less That Enemy.
                                    if (GetObjectValue(Table[i, j]) < GetObjectValue(Table[ii, jj]))
                                    {
                                        //Take Move.
                                        Table[ii, jj] = Table[i, j];
                                        Table[i, j] = 0;
                                        a = Color.Gray;
                                        if (Order * -1 == -1)
                                            a = Color.Brown;
                                        //When Enemy Attacks Current Moved.
                                        if (Attack(Table, iii, jjj, ii, jj, a, Order * -1))
                                        {
                                            //For Current Order.
                                            for (int iiii = 0; iiii < 8; iiii++)
                                                for (int jjjj = 0; jjjj < 8; jjjj++)
                                                {
                                                    if (Order == 1 && Tab[iiii, jjjj] <= 0)
                                                        continue;
                                                    if (Order == -1 && Tab[iiii, jjjj] >= 0)
                                                        continue;
                                                    a = Color.Gray;
                                                    if (Order == -1)
                                                        a = Color.Brown;
                                                    //When Self Supported Current
                                                    if (Support(Table, iiii, jjjj, i, j, a, Order))
                                                    {
                                                        //If V alue of Enemy is Greater Than Current and Value of Enemy is Greater than Supporter.
                                                        if (GetObjectValue(Table[iii, jjj]) < GetObjectValue(Table[ii, jj]) && GetObjectValue(Table[iii, jjj]) > GetObjectValue(Table[iiii, jjjj]))
                                                        {
                                                            if (A.ObjectDangourKingMove(Order, Table, false) && Count > 0)
                                                            {
                                                                if (Order == 1 && (!A.CheckGrayObjectDangour))
                                                                {
                                                                    Remove = true;
                                                                    return Remove;
                                                                }
                                                                if (Order == -1 && (!A.CheckBrownObjectDangour))
                                                                {
                                                                    Remove = true;
                                                                    return Remove;
                                                                }
                                                            }
                                                        }
                                                        else
                                                            return Remove;
                                                    }
                                                    else
                                                        return Remove;
                                                }
                                        }
                                    }
                                    else
                                        return Remove;


                                }
                        }
                    }

                }

            return Remove;

        }
        //Dangouring of current movment fo current Order.QC-OK
        bool IsCurrentStateIsDangreousForCurrentOrder(int[,] Tabl, int Order, Color a, int ii, int jj)
        {
            //Initiate Object.
            ChessRules A = new ChessRules(1, Tabl, 1, Row, Column);
            //Gray Order.
            if (Order == 1)
            {
                //Find location of Gray King.
                int RowG = -1, ColumnG = -1;
                A.FindGrayKing(Tabl, ref RowG, ref ColumnG);
                //When found.
                if (RowG != -1 && ColumnG != -1)
                {
                    //For Brown
                    for (int i = 0; i < 8; i++)
                        for (int j = 0; j < 8; j++)
                        {
                            if (Tabl[i, j] >= 0)
                                continue;

                            //For Gray and Empty Objects
                            // for (int ii = 0; ii < 8; ii++)
                            //   for (int jj = 0; jj < 8; jj++)
                            {
                                //       if (Tabl[ii, jj] < 0)
                                //        continue;
                                if (i != ii && j != jj)
                                {
                                    //Create new Objects of Table
                                    int[,] TablCon = new int[8, 8];
                                    for (int iii = 0; iii < 8; iii++)
                                        for (int jjj = 0; jjj < 8; jjj++)
                                            TablCon[iii, jjj] = Tabl[iii, jjj];
                                    //For Enemy Order.
                                    if (TablCon[i, j] < 0)
                                    {
                                        //For Gray and Empty Objects.
                                        if (TablCon[ii, jj] >= 0)
                                        {
                                            //Setting Enemy Order.
                                            int DummyOrder = Order;
                                            int DummyCurrentOrder = ChessRules.CurrentOrder;
                                            A = new ChessRules(TablCon[i, j], TablCon, -1, i, j);
                                            //When Enemy is Attacked Gray Objects.
                                            if (A.Rules(i, j, ii, jj, Color.Brown, TablCon[i, j]))
                                            {
                                                //Take Movments.
                                                TablCon[ii, jj] = TablCon[i, j];
                                                TablCon[i, j] = 0;
                                                //Settting Current Order.
                                                ChessRules.CurrentOrder = 1;
                                                //Settting Object.
                                                A = new ChessRules(TablCon[ii, jj], TablCon, 1, ii, jj);
                                                //When Occured Check.
                                                if (A.Check(TablCon, 1))
                                                {
                                                    //When Gray is Check.
                                                    if (A.CheckGray)
                                                    {
                                                        //For Enemy Order Objects.
                                                        for (int iiii = 0; iiii < 8; iiii++)
                                                            for (int jjjj = 0; jjjj < 8; jjjj++)
                                                            {
                                                                //When is not Conflict.
                                                                if (iiii != i && jjjj != j && iiii != ii && jjjj != jj)
                                                                {
                                                                    //Setting Enemy.
                                                                    ChessRules.CurrentOrder = -1;
                                                                    //When Enemy is Supported 
                                                                    if (Support(TablCon, iiii, jjjj, i, j, Color.Brown, -1))
                                                                    {
                                                                        //restore and return true.
                                                                        Order = DummyOrder;
                                                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                                                        return true;
                                                                    }
                                                                }
                                                            }
                                                    }
                                                    Order = DummyOrder;
                                                    ChessRules.CurrentOrder = DummyCurrentOrder;

                                                }
                                            }

                                        }
                                    }
                                }
                            }
                        }
                }

            }
            //For Brown Order.
            else if (Order == -1)
            {
                //Found of Brown King.
                int RowB = -1, ColumnB = -1;
                A.FindBrownKing(Tabl, ref RowB, ref ColumnB);
                //When found.
                if (RowB != -1 && ColumnB != -1)
                {
                    //For Gray.
                    for (int i = 0; i < 8; i++)
                        for (int j = 0; j < 8; j++)
                        {
                            if (Tabl[i, j] <= 0)
                                continue;

                            //For Brown and Empty Objects
                            //for (int ii = 0; ii < 8; ii++)
                            // for (int jj = 0; jj < 8; jj++)
                            {
                                //      if (Tabl[ii, jj] > 0)
                                //       continue;

                                if (i != ii && j != jj)
                                {
                                    //Create new Objects of Table
                                    int[,] TablCon = new int[8, 8];
                                    for (int iii = 0; iii < 8; iii++)
                                        for (int jjj = 0; jjj < 8; jjj++)
                                            TablCon[iii, jjj] = Tabl[iii, jjj];
                                    //For Enemy Objects.
                                    if (TablCon[i, j] > 0)
                                    {
                                        //For Self Objects and Empty.
                                        if (TablCon[ii, jj] <= 0)
                                        {
                                            //Store and Enemy Order.
                                            int DummyOrder = Order;
                                            int DummyCurrentOrder = ChessRules.CurrentOrder;
                                            A = new ChessRules(TablCon[i, j], TablCon, 1, i, j);
                                            ChessRules.CurrentOrder = 1;
                                            //When Enemy Attacked Self Objects.
                                            if (A.Rules(i, j, ii, jj, Color.Gray, TablCon[i, j]))
                                            {
                                                //Take movemnts.
                                                TablCon[ii, jj] = TablCon[i, j];
                                                TablCon[i, j] = 0;
                                                //Setting current Order.
                                                ChessRules.CurrentOrder = -1;
                                                A = new ChessRules(TablCon[ii, jj], TablCon, -1, ii, jj);
                                                //When Check Occured.
                                                if (A.Check(TablCon, -1))
                                                {
                                                    //When Current is Check.
                                                    if (A.CheckBrown)
                                                    {
                                                        //For Enemy Objecvts.
                                                        for (int iiii = 0; iiii < 8; iiii++)
                                                            for (int jjjj = 0; jjjj < 8; jjjj++)
                                                            {
                                                                //Ignore of Conflit.
                                                                if (iiii != i && jjjj != j && iiii != ii && jjjj != jj)
                                                                {
                                                                    //Setting Enemy Order
                                                                    ChessRules.CurrentOrder = 1;
                                                                    //When Enemy is Supported.
                                                                    if (Support(TablCon, iiii, jjjj, i, j, Color.Gray, 1))
                                                                    {
                                                                        //restore and return true.
                                                                        Order = DummyOrder;
                                                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                                                        return true;
                                                                    }
                                                                }
                                                            }
                                                    }
                                                    //restore.
                                                    Order = DummyOrder;
                                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                                }
                                            }

                                        }
                                    }
                                }
                            }
                        }
                }

            }
            //return false.
            return false;
        }
        //When Next Movements is Checked.QC-OK
        bool IsNextMovmentIsCheckOrCheckMateForCurrentMovment(int[,] Tab, int Order, Color a, int i, int j)
        {
            //Store.
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;

            //For Current Order.
            int iii = i, jjj = j;
            //for (int iii = 0; iii < 8; iii++)
            //for (int jjj = 0; jjj < 8; jjj++)
            {
                // if (Order == 1 && Tab[iii, jjj] <= 0)
                //     continue;
                /// else
                //     if (Order == -1 && Tab[iii, jjj] >= 0)
                //        continue;
                //For Enemy Home of Current
                for (int ii = 0; ii < 8; ii++)
                    for (int jj = 0; jj < 8; jj++)
                    {
                        //Ignore Of Self Objects.
                        if (Order == 1 && Tab[ii, jj] >= 0)
                            continue;
                        else
                            if (Order == -1 && Tab[ii, jj] <= 0)
                                continue;
                        int[,] TabS = new int[8, 8];
                        for (int h = 0; h < 8; h++)
                            for (int k = 0; k < 8; k++)
                            {
                                TabS[h, k] = Tab[h, k];
                            }
                        ChessRules A = new ChessRules(TabS[ii, jj], TabS, Order * -1, ii, jj);
                        Color D = Color.Gray;
                        if (Order * -1 == -1)
                            D = Color.Brown;
                        if (A.Rules(ii, jj, iii, jjj, D, TabS[ii, jj]))
                        {
                            TabS[iii, jjj] = TabS[ii, jj];
                            TabS[ii, jj] = 0;
                            //Settting Enemy Order.
                            //ChessRules.CurrentOrder = Order * -1;
                            //When Enemy Attacked Current Objects.

                            if (A.CheckMate(TabS, Order * -1))
                            {
                                for (int iiii = 0; iiii < 8; iiii++)
                                    for (int jjjj = 0; jjjj < 8; jjj++)
                                    {
                                        int[,] TabSS = new int[8, 8];
                                        for (int h = 0; h < 8; h++)
                                            for (int k = 0; k < 8; k++)
                                            {
                                                TabSS[h, k] = TabS[h, k];
                                            }
                                        A = new ChessRules(TabSS[iiii, jjjj], TabSS, Order, iiii, jjjj);
                                        if (A.Rules(iiii, jjjj, iii, jjj, a, TabSS[iiii, jjjj]))
                                        {

                                            TabSS[iii, jjj] = TabSS[iiii, jjjj];
                                            TabSS[iiii, jjjj] = 0;
                                            if (A.CheckMate(TabSS, Order))
                                            {
                                                if (Order == 1 && (A.CheckGray))
                                                {
                                                    Order = DummyOrder;
                                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                                    return true;

                                                }
                                                else
                                                    if (Order == -1 && (A.CheckBrown))
                                                    {
                                                        Order = DummyOrder;
                                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                                        return true;

                                                    }
                                            }
                                        }
                                    }
                                return false;
                            }
                            else
                                return false;

                        }
                    }
            }

            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;

            //return false.
            return false;
        }
        //When Current Movements is in dangrous and is not movable.QC-OK
        bool IsGardForCurrentMovmentsAndIsNotMovable(int[,] Tab, int Order, Color a, int i, int j)
        {
            //Setting false.
            bool Attacked = false;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            //For Enemy Order.
            for (int ii = 0; ii < 8; ii++)
                for (int jj = 0; jj < 8; jj++)
                {
                    //Ignore of Self Objects.
                    if (Order == 1 && Tab[ii, jj] >= 0)
                        continue;
                    else
                        if (Order == -1 && Tab[ii, jj] <= 0)
                            continue;

                    //For Enemy Order.
                    ChessRules.CurrentOrder = Order * -1;
                    //When Enemy Attacked Current Movements.
                    if (Attack(Tab, ii, jj, i, j, a, Order * -1))
                    {
                        //Restore
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        //For Enemy Objects and Empty.
                        for (int iii = 0; iii < 8; iii++)
                            for (int jjj = 0; jjj < 8; jjj++)
                            {
                                //Ignore of Self Objects.
                                if (Order == 1 && Tab[iii, jjj] > 0)
                                    continue;
                                else
                                    if (Order == -1 && Tab[iii, jjj] < 0)
                                        continue;
                                //Clone a Table.
                                int[,] TabS = new int[8, 8];
                                for (int p = 0; p < 8; p++)
                                    for (int m = 0; m < 8; m++)
                                        TabS[p, m] = Tab[p, m];
                                //When Current Objects Attacked Enemy.
                                if ((new ChessRules(TabS[i, j], TabS, Order, i, j)).Rules(i, j, iii, jjj, a, TabS[i, j]))
                                {
                                    //Take Movments.
                                    TabS[iii, jjj] = TabS[i, j];
                                    TabS[i, j] = 0;
                                    //Restore and Setting Enemy.
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    ChessRules.CurrentOrder = Order * -1;
                                    //For Enemy Order.
                                    for (int p = 0; p < 8; p++)
                                        for (int m = 0; m < 8; m++)
                                        {
                                            //Ignore of Self and Empty.
                                            if (Order == 1 && TabS[p, m] >= 0)
                                                continue;
                                            else
                                                if (Order == -1 && TabS[p, m] <= 0)
                                                    continue;
                                            //Setting Color.
                                            a = Color.Gray;
                                            if (TabS[p, m] < 0)
                                                a = Color.Brown;
                                            //When Enemy Attacked Current Objects (By Take Movments.).
                                            if (Attack(TabS, p, m, iii, jjj, a, Order * -1))
                                                //Take or All
                                                Attacked |= true;
                                            else
                                                //Take and All.
                                                Attacked &= true;
                                            //Rerstore.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;


                                        }
                                }
                            }
                    }
                }
            //Restore.
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;

            //Return Variable.
            return Attacked;
        }

        ///when current movments gards enemy with higer priority.QC-OK
        bool IsEnenmyInGardForCurrentMovmentsIsSuitable(int[,] Tab, int Order, Color a, int i, int j)
        {
            //For All Current Order.
            //for (int i = 0; i < 8; i++)
            //  for (int j = 0; j < 8; j++)
            //{
            //                  if (Order == 1 && Tab[i, j] <= 0)
            //                    continue;
            //              else
            //                if (Order == -1 && Tab[i, j] >= 0)
            //                  continue;
            int Supported = 0;
            int Attacked = 0;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;

            //For Enemy Order.
            for (int ii = 0; ii < 8; ii++)
                for (int jj = 0; jj < 8; jj++)
                {
                    //Ignore of Self Order.
                    if (Order == 1 && Tab[ii, jj] >= 0)
                        continue;
                    else
                        if (Order == -1 && Tab[ii, jj] <= 0)
                            continue;
                    //When There is Enemy Gard The Current PenaltyRegard Mechanisam is Suitabled
                    if (Attack(Tab, ii, jj, i, j, a, Order * -1))
                        Attacked++;
                }
            //restore.
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            //For Current Order.
            for (int iii = 0; iii < 0; iii++)
                for (int jjj = 0; jjj < 0; jjj++)
                {
                    //Ignore of Enemy.
                    if (Order == 1 && Tab[iii, jjj] <= 0)
                        continue;
                    else
                        if (Order == -1 && Tab[iii, jjj] >= 0)
                            continue;
                    //When Cuurent supported currenty movments.
                    if (Support(Tab, i, j, iii, jjj, a, Order))
                        Supported++;
                }




            //}
            //When number of Supported is less tahn number of attackers return true.
            if (Supported < Attacked)
            {
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                return true;
            }
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;

            //return false.
            return false;
        }
        ///Huristic of Check and CheckMate.QC-OK
        public void HuristicCheckAndCheckMate(int[,] Table, Color a)
        {

            int DumOrder = Order;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;

            double ObjectDangour = 0;
            double Check = 0;
            double CheckMate = 9999999;

            try
            {
                //if (AStarGreedyHuristic)
                {
                    //Consider Global Check CheckMate ObjectDanger Variables Orderly.
                    ChessRules A = new ChessRules(1, Table, Order, Row, Column);
                    A.CheckMate(Table, Order);
                    ChessRules AA = new ChessRules(1, Table, Order, Row, Column);
                    AA.ObjectDangourKingMove(Order, Table, false);
                    {
                        //Consider Value to More Valuable Positive and Negative Check CheckMate ObjectDanger 
                        if (A.CheckMateGray || A.CheckMateBrown)
                        {
                            if (Order == 1 && A.CheckMateBrown)
                            {
                                HuristicValueObjectDangourCheckMate += CheckMate * SignOrderToPlate(Order);
                                ThinkingChess.MovementsAStarGreedyHuristicFound = true;
                            }
                            if (Order == -1 && A.CheckMateGray)
                            {
                                HuristicValueObjectDangourCheckMate += CheckMate * SignOrderToPlate(Order);
                                ThinkingChess.MovementsAStarGreedyHuristicFound = true;
                            }
                        }

                        if (A.CheckGray || A.CheckBrown)
                        {

                            if (Order == 1 && A.CheckBrown)
                            {
                                HuristicValueObjectDangourCheckMate += Check * SignOrderToPlate(Order);
                                ThinkingChess.MovementsAStarGreedyHuristicFound = true;
                            }
                            if (Order == -1 && A.CheckGray)
                            {
                                HuristicValueObjectDangourCheckMate += Check * SignOrderToPlate(Order);
                                ThinkingChess.MovementsAStarGreedyHuristicFound = true;
                            }
                        }

                        if (AA.CheckGrayObjectDangour || AA.CheckBrownObjectDangour)
                        {

                            if (Order == 1 && AA.CheckBrownObjectDangour)
                            {
                                HuristicValueObjectDangourCheckMate += ObjectDangour * SignOrderToPlate(Order);
                                ThinkingChess.MovementsAStarGreedyHuristicFound = true;
                            }
                            if (Order == -1 && AA.CheckGrayObjectDangour)
                            {
                                HuristicValueObjectDangourCheckMate += ObjectDangour * SignOrderToPlate(Order);
                                ThinkingChess.MovementsAStarGreedyHuristicFound = true;
                            }
                        }
                        if (A.CheckMateGray || A.CheckMateBrown)
                        {

                            if (Order == 1 && A.CheckMateGray)
                            {
                                HuristicValueObjectDangourCheckMate -= CheckMate * SignOrderToPlate(Order);
                            }
                            if (Order == -1 && A.CheckMateBrown)
                            {
                                HuristicValueObjectDangourCheckMate -= CheckMate * SignOrderToPlate(Order);
                            }
                        }

                        if (A.CheckGray || A.CheckBrown)
                        {

                            if (Order == 1 && A.CheckGray)
                            {
                                HuristicValueObjectDangourCheckMate -= Check * SignOrderToPlate(Order);
                            }
                            if (Order == -1 && A.CheckBrown)
                            {
                                HuristicValueObjectDangourCheckMate -= Check * SignOrderToPlate(Order);
                            }
                        }
                        if (AA.CheckBrownObjectDangour || AA.CheckGrayObjectDangour)
                        {

                            if (Order == 1 && AA.CheckGrayObjectDangour)
                            {
                                HuristicValueObjectDangourCheckMate -= ObjectDangour * SignOrderToPlate(Order);
                            }
                            if (Order == -1 && AA.CheckBrownObjectDangour)
                            {
                                HuristicValueObjectDangourCheckMate -= ObjectDangour * SignOrderToPlate(Order);
                            }
                        }


                    }
                }
            }
            catch (Exception t)
            {
            }
            //HuristicValueObjectDangourCheckMate *= SignOrderToPlate(Order);
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            Order = DumOrder;

        }
        int VeryFye(int[,] Table, int Order, Color a)
        {
            /* int Count = 0;
             float RowClickP = Row;
             float ColumnClickP = Column;
             int DummyOrder = Order;
             int DummyCurrentOrder = ChessRules.CurrentOrder;
             if (Order == 1)
                 ChessRules.CurrentOrder = 1;
             else
                 ChessRules.CurrentOrder = -1;
             bool[,] Tab = new bool[8, 8];
             for (int i = 0; i < 8; i++)
                 for (int j = 0; j < 8; j++)
                 {
                     int ii = Row;
                     int jj = Column;
                     //for (int ii = 0; ii < 8; ii++)
                     //     for (int jj = 0; jj < 8; jj++)
                     {
                         if (System.Math.Abs(Table[ii, jj]) == 1)
                         {
                             if ((new ChessRules(Table[ii, jj], Table, Order, ii, jj).Rules(ii, jj, i, j, a, Table[ii, jj])))
                             {
                                 bool Attacked = false;
                                 for (int iii = 0; iii < 8; iii++)
                                     for (int jjj = 0; jjj < 8; jjj++)
                                     {
                                         if (Order == 1 && Table[iii, jjj] >= 0)
                                             continue;
                                         else
                                             if (Order == -1 && Table[iii, jjj] <= 0)
                                                 continue;

                                         if (Attack(Table, iii, jjj, i, j, a, Order * -1))
                                         {
                                             Attacked = true;
                                         }
                                     }
                                 if (!Attacked)
                                 {
                                     Tab[i, j] = true;
                                     Count++;
                                 }
                             }
                         }
                         else
                             if (System.Math.Abs(Table[ii, jj]) == 2)
                             {
                                 if ((new ChessRules(Table[ii, jj], Table, Order, ii, jj).Rules(ii, jj, i, j, a, Table[ii, jj])))
                                 {
                                     bool Attacked = false;
                                     for (int iii = 0; iii < 8; iii++)
                                         for (int jjj = 0; jjj < 8; jjj++)
                                         {
                                             if (Order == 1 && Table[iii, jjj] >= 0)
                                                 continue;
                                             else
                                                 if (Order == -1 && Table[iii, jjj] <= 0)
                                                     continue;

                                             if (Attack(Table, iii, jjj, i, j, a, Order * -1))
                                             {
                                                 Attacked = true;
                                             }
                                         }
                                     if (!Attacked)
                                     {
                                         Tab[i, j] = true;
                                         Count++;
                                     }
                                 }
                             }
                             else
                                 if (System.Math.Abs(Table[ii, jj]) == 3)
                                 {
                                     if ((new ChessRules(Table[ii, jj], Table, Order, ii, jj).Rules(ii, jj, i, j, a, Table[ii, jj])))
                                     {
                                         bool Attacked = false;
                                         for (int iii = 0; iii < 8; iii++)
                                             for (int jjj = 0; jjj < 8; jjj++)
                                             {
                                                 if (Order == 1 && Table[iii, jjj] >= 0)
                                                     continue;
                                                 else
                                                     if (Order == -1 && Table[iii, jjj] <= 0)
                                                         continue;

                                                 if (Attack(Table, iii, jjj, i, j, a, Order * -1))
                                                 {
                                                     Attacked = true;
                                                 }
                                             }
                                         if (!Attacked)
                                         {
                                             Tab[i, j] = true;
                                             Count++;
                                         }
                                     }
                                 }
                                 else
                                     if (System.Math.Abs(Table[ii, jj]) == 4)
                                     {
                                         if ((new ChessRules(Table[ii, jj], Table, Order, ii, jj).Rules(ii, jj, i, j, a, Table[ii, jj])))
                                         {
                                             bool Attacked = false;
                                             for (int iii = 0; iii < 8; iii++)
                                                 for (int jjj = 0; jjj < 8; jjj++)
                                                 {
                                                     if (Order == 1 && Table[iii, jjj] >= 0)
                                                         continue;
                                                     else
                                                         if (Order == -1 && Table[iii, jjj] <= 0)
                                                             continue;

                                                     if (Attack(Table, iii, jjj, i, j, a, Order * -1))
                                                     {
                                                         Attacked = true;
                                                     }
                                                 }

                                             if (!Attacked)
                                             {
                                                 Tab[i, j] = true;
                                                 Count++;
                                             }
                                         }
                                     }
                                     else
                                         if (System.Math.Abs(Table[ii, jj]) == 5)
                                         {
                                             if ((new ChessRules(Table[ii, jj], Table, Order, ii, jj).Rules(ii, jj, i, j, a, Table[ii, jj])))
                                             {
                                                 bool Attacked = false;
                                                 for (int iii = 0; iii < 8; iii++)
                                                     for (int jjj = 0; jjj < 8; jjj++)
                                                     {
                                                         if (Order == 1 && Table[iii, jjj] >= 0)
                                                             continue;
                                                         else
                                                             if (Order == -1 && Table[iii, jjj] <= 0)
                                                                 continue;

                                                         if (Attack(Table, iii, jjj, i, j, a, Order * -1))
                                                         {
                                                             Attacked = true;
                                                         }
                                                     }
                                                 if (!Attacked)
                                                 {
                                                     Tab[i, j] = true;
                                                     Count++;
                                                 }
                                             }
                                         }
                                         else
                                             if (System.Math.Abs(Table[ii, jj]) == 6)
                                             {
                                                 if ((new ChessRules(Table[ii, jj], Table, Order, ii, jj).Rules(ii, jj, i, j, a, Table[ii, jj])))
                                                 {
                                                     bool Attacked = false;
                                                     for (int iii = 0; iii < 8; iii++)
                                                         for (int jjj = 0; jjj < 8; jjj++)
                                                         {
                                                             if (Order == 1 && Table[iii, jjj] >= 0)
                                                                 continue;
                                                             else
                                                                 if (Order == -1 && Table[iii, jjj] <= 0)
                                                                     continue;

                                                             if (Attack(Table, iii, jjj, i, j, a, Order * -1))
                                                             {
                                                                 Attacked = true;
                                                             }
                                                         }
                                                     if (!Attacked)
                                                     {
                                                         Tab[i, j] = true;
                                                         Count++;
                                                     }
                                                 }
                                             }


                     }
                 }

             Order = DummyOrder;
             ChessRules.CurrentOrder = DummyCurrentOrder;
            */
            int HA = 0;
            int Object = Table[Row, Column];
            if (System.Math.Abs(Object) == 1)
                HA = 1;
            else if (System.Math.Abs(Object) == 2)
                HA = 2;
            else if (System.Math.Abs(Object) == 3)
                HA = 3;
            else if (System.Math.Abs(Object) == 4)
                HA = 5;
            else if (System.Math.Abs(Object) == 5)
                HA = 8;
            else if (System.Math.Abs(Object) == 6)
                HA = 10;
            return HA;

            /*if (System.Math.Abs(Table[(int)RowClickP, (int)ColumnClickP]) == 1)
                Count = Count / AllDraw.SodierHigh;
            else
                if (System.Math.Abs(Table[(int)RowClickP, (int)ColumnClickP]) == 2)
                    Count = Count / AllDraw.ElefantHigh;
                else
                    if (System.Math.Abs(Table[(int)RowClickP, (int)ColumnClickP]) == 3)
                        Count = Count / AllDraw.HourseHight;
                    else
                        if (System.Math.Abs(Table[(int)RowClickP, (int)ColumnClickP]) == 4)
                            Count = Count / AllDraw.BridgeHigh;
                        else
                            if (System.Math.Abs(Table[(int)RowClickP, (int)ColumnClickP]) == 5)
                                Count = Count / AllDraw.MinisterHigh;
                            else
                                if (System.Math.Abs(Table[(int)RowClickP, (int)ColumnClickP]) == 6)
                                    Count = Count / AllDraw.KingHigh;

            */
            //            return Count;
        }
        //QC_OK
        int SupporterCount(int[,] Table, int Order, Color a, int ii, int jj)
        {
            int Count = 0;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            if (Order == 1)
                ChessRules.CurrentOrder = 1;
            else
                ChessRules.CurrentOrder = -1;
            bool[,] Tab = new bool[8, 8];
            for (int i = 0; i < 8; i++)
                for (int j = 0; j < 8; j++)
                {
                    if (Order == 1 && Table[i, j] <= 0)
                        continue;
                    else
                        if (Order == -1 && Table[i, j] >= 0)
                            continue;
                    if (Support(Table, i, j, ii, jj, a, Order))
                    {
                        Count++;
                    }
                }

            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            return Count;
        }
        //Attacks on Enemies.QC-OK
        int AttackerCount(int[,] Table, int Order, Color a, int i, int j)
        {
            int Count = 0;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            int[,] Tab = new int[8, 8];
            for (int h = 0; h < 8; h++)
                for (int k = 0; k < 8; k++)
                    Tab[h, k] = Table[h, k];
            //For Slef Objects..
            for (int ii = 0; ii < 8; ii++)
                for (int jj = 0; jj < 8; jj++)
                {
                    //Ignore Of Self Objects
                    if (Order == 1 && Tab[ii, jj] >= 0)
                        continue;
                    else
                        if (Order == -1 && Tab[ii, jj] <= 0)
                            continue;
                    //If Current Attacks Enemy.
                    if (Attack(Tab, i, j, ii, jj, a, Order))
                    {
                        Count++;
                    }
                }

            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            return Count;
        }
        //Attackers of Enemies.QC_OK.
        int EnemyAttackerCount(int[,] Table, int Order, Color a, int ii, int jj)
        {
            int Count = 0;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            if (Order == 1)
                ChessRules.CurrentOrder = 1;
            else
                ChessRules.CurrentOrder = -1;
            int[,] Tab = new int[8, 8];
            for (int h = 0; h < 8; h++)
                for (int k = 0; k < 8; k++)
                    Tab[h, k] = Table[h, k];
            for (int i = 0; i < 8; i++)
                for (int j = 0; j < 8; j++)
                {
                    if (Order == 1 && Table[i, j] >= 0)
                        continue;
                    else
                        if (Order == -1 && Table[i, j] <= 0)
                            continue;
                    if (Attack(Table, i, j, ii, jj, a, Order * -1))
                    {
                        Count++;
                    }
                }

            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            return Count;
        }
        //Distance of Enemy Kings from Current Object.QC-OK
        public void HeuristicDistabceOfCurrentMoveFromEnemyKing(int[,] Tab, int Order, int ii, int jj)
        {
            int RowG = -1, ColumnG = -1, RowB = -1, ColumnB = -1;
            ChessRules A = new ChessRules(Tab[ii, jj], Tab, Order, ii, jj);
            if (Order == -1)
            {
                A.FindGrayKing(Tab, ref RowG, ref ColumnG);
                double Dis = 0;
                if (System.Math.Abs(Tab[ii, jj]) == 1)
                    Dis = -100.0 * (1.0 / (double)SodierValue) * System.Math.Sqrt(System.Math.Pow(ii - RowG, 2) + System.Math.Pow(jj - ColumnG, 2));
                else
                    if (System.Math.Abs(Tab[ii, jj]) == 2)
                        Dis = -100.0 * (1.0 / (double)ElefantValue) * System.Math.Sqrt(System.Math.Pow(ii - RowG, 2) + System.Math.Pow(jj - ColumnG, 2));
                    else
                        if (System.Math.Abs(Tab[ii, jj]) == 3)
                            Dis = -100.0 * (1.0 / (double)HourseValue) * System.Math.Sqrt(System.Math.Pow(ii - RowG, 2) + System.Math.Pow(jj - ColumnG, 2));
                        else
                            if (System.Math.Abs(Tab[ii, jj]) == 4)
                                Dis = -100.0 * (1.0 / (double)BridgeValue) * System.Math.Sqrt(System.Math.Pow(ii - RowG, 2) + System.Math.Pow(jj - ColumnG, 2));
                            else
                                if (System.Math.Abs(Tab[ii, jj]) == 5)
                                    Dis = -100.0 * (1.0 / (double)MinisterValue) * System.Math.Sqrt(System.Math.Pow(ii - RowG, 2) + System.Math.Pow(jj - ColumnG, 2));
                                else
                                    if (System.Math.Abs(Tab[ii, jj]) == 6)
                                        Dis = -100.0 * (1.0 / (double)KingValue) * System.Math.Sqrt(System.Math.Pow(ii - RowG, 2) + System.Math.Pow(jj - ColumnG, 2));
                // Dis = -1000.0;
                HuristicValueObjectDangourCheckMate += Dis * SignOrderToPlate(Order);
            }
            else
            {
                A.FindBrownKing(Tab, ref RowB, ref ColumnB);
                double Dis = 0;
                if (System.Math.Abs(Tab[ii, jj]) == 1)
                    Dis = -100.0 * (1.0 / (double)SodierValue) * System.Math.Sqrt(System.Math.Pow(ii - RowB, 2) + System.Math.Pow(jj - ColumnB, 2));
                else
                    if (System.Math.Abs(Tab[ii, jj]) == 2)
                        Dis = -100.0 * (1.0 / (double)ElefantValue) * System.Math.Sqrt(System.Math.Pow(ii - RowB, 2) + System.Math.Pow(jj - ColumnB, 2));
                    else
                        if (System.Math.Abs(Tab[ii, jj]) == 3)
                            Dis = -100.0 * (1.0 / (double)HourseValue) * System.Math.Sqrt(System.Math.Pow(ii - RowB, 2) + System.Math.Pow(jj - ColumnB, 2));
                        else
                            if (System.Math.Abs(Tab[ii, jj]) == 4)
                                Dis = -100.0 * (1.0 / (double)BridgeValue) * System.Math.Sqrt(System.Math.Pow(ii - RowB, 2) + System.Math.Pow(jj - ColumnB, 2));
                            else
                                if (System.Math.Abs(Tab[ii, jj]) == 5)
                                    Dis = -100.0 * (1.0 / (double)MinisterValue) * System.Math.Sqrt(System.Math.Pow(ii - RowB, 2) + System.Math.Pow(jj - ColumnB, 2));
                                else
                                    Dis = -100.0 * (1.0 / (double)KingValue) * System.Math.Sqrt(System.Math.Pow(ii - RowG, 2) + System.Math.Pow(jj - ColumnG, 2));
                //Dis = -1000.0;
                HuristicValueObjectDangourCheckMate += Dis * SignOrderToPlate(Order);
            }
        }

        ///Huristic of Movments.QC-OK
        public float HuristicMovment(int[,] Table, Color a)
        {
            //Initiate Local Variable.
            int HA = 0;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            ///When AStarGreedy Huristic is Not Assigned.
            try
            {
                if (!AStarGreedyHuristic)
                {
                    ///For Current Objects.
                    int ii = Row, jj = Column;
                    for (int i = 0; i < 8; i++)
                    {
                        for (int j = 0; j < 8; j++)
                        {
                            if (i == ii && j == jj)
                                continue;
                            Order = DummyOrder;
                            int Sign = 1;
                            ///When Moveble is true. means [ii,jj] is in Movmebale to [i,j].
                            ///What is Moveable!
                            ///Ans:When [ii,jj] is Movebale to [i,j] return true when Empty or Enemy is located in [ii,jj].
                            if (Table[i, j] >= 0 && DummyOrder == -1 && Table[ii, jj] < 0)
                            {
                                Order = -1;
                                Sign = 100 * AllDraw.SignMovments;
                                ChessRules.CurrentOrder = -1;
                                a = Color.Brown;
                            }
                            else if (Table[i, j] <= 0 && DummyOrder == 1 && Table[ii, jj] > 0)
                            {
                                Order = 1;
                                Sign = 100 * AllDraw.SignMovments;
                                ChessRules.CurrentOrder = 1;
                                a = Color.Gray;
                            }
                            else

                                /*   else
                                       if (Table[ii, jj] < 0 && DummyOrder == 1 && Table[i, j] >= 0)
                                       {
                                           Order = -1;
                                           Sign = -100 * AllDraw.SignMovments;
                                           ChessRules.CurrentOrder = -1;
                                           a = Color.Brown;
                                       }
                                       else if (Table[ii, jj] > 0 && DummyOrder == -1 && Table[i, j] <= 0)
                                       {
                                           Order = 1;
                                           Sign = -100 * AllDraw.SignMovments;
                                           ChessRules.CurrentOrder = 1;
                                           a = Color.Gray;
                                       }
                                       else
                                 */
                                continue;
                            //When is Movable Movement inCurrent.
                            if (Movable(Table, ii, jj, i, j, a, Order))
                            {
                                if (System.Math.Abs(Table[ii, jj]) == 1)
                                    HA += (Sign * System.Math.Abs(SodierValue + GetObjectValue(Table[i, j])
                                        ));
                                else if (System.Math.Abs(Table[ii, jj]) == 2)
                                    HA += (Sign * System.Math.Abs(ElefantValue + GetObjectValue(Table[i, j])
                                        ));
                                else if (System.Math.Abs(Table[ii, jj]) == 3)
                                    HA += (Sign * System.Math.Abs(HourseValue + GetObjectValue(Table[i, j])
                                        ));
                                else if (System.Math.Abs(Table[ii, jj]) == 4)
                                    HA += (Sign * System.Math.Abs(BridgeValue + GetObjectValue(Table[i, j])
                                        ));
                                else if (System.Math.Abs(Table[ii, jj]) == 5)
                                    HA += (Sign * System.Math.Abs(MinisterValue + GetObjectValue(Table[i, j])
                                        ));
                                else if (System.Math.Abs(Table[ii, jj]) == 6)
                                    HA += (Sign * System.Math.Abs(KingValue + GetObjectValue(Table[i, j])
                                        ));
                            }
                        }
                    }

                }
                //For All Homes Table.
                else
                {
                    for (int i = 0; i < 8; i++)
                    {
                        for (int j = 0; j < 8; j++)
                        {
                            for (int ii = 0; ii < 8; ii++)
                            {
                                for (int jj = 0; jj < 8; jj++)
                                {
                                    if (i == ii && j == jj)
                                        continue;
                                    int Sign = 1;
                                    Order = DummyOrder;
                                    ///When Moveble is true. means [ii,jj] is in Movmebale to [i,j].
                                    ///What is Moveable!
                                    ///Ans:When [ii,jj] is Movebale to [i,j] return true when Empty or Enemy is located in [ii,jj].
                                    if (Table[i, j] >= 0 && DummyOrder == -1 && Table[ii, jj] < 0)
                                    {
                                        Order = -1;
                                        Sign = 100 * AllDraw.SignMovments;
                                        ChessRules.CurrentOrder = -1;
                                        a = Color.Brown;
                                    }
                                    else if (Table[i, j] <= 0 && DummyOrder == 1 && Table[ii, jj] > 0)
                                    {
                                        Order = 1;
                                        Sign = 100 * AllDraw.SignMovments;
                                        ChessRules.CurrentOrder = 1;
                                        a = Color.Gray;
                                    }
                                    /*        else
                                                if (Table[ii, jj] < 0 && DummyOrder == 1 && Table[i, j] >= 0)
                                                {
                                                    Order = -1;
                                                    Sign = -100 * AllDraw.SignMovments;
                                                    ChessRules.CurrentOrder = -1;
                                                    a = Color.Brown;
                                                }
                                                else if (Table[ii, jj] > 0 && DummyOrder == -1 && Table[i, j] <= 0)
                                                {
                                                    Order = 1;
                                                    Sign = -100 * AllDraw.SignMovments;
                                                    ChessRules.CurrentOrder = 1;
                                                    a = Color.Gray;
                                                }
                                     */
                                    else
                                        continue;
                                    //If Current Home is Moveble.
                                    if (Movable(Table, ii, jj, i, j, a, Order))
                                    {
                                        if (System.Math.Abs(Table[ii, jj]) == 1)
                                            HA += (Sign * System.Math.Abs(SodierValue + GetObjectValue(Table[i, j])
                                                ));
                                        else if (System.Math.Abs(Table[ii, jj]) == 2)
                                            HA += (Sign * System.Math.Abs(ElefantValue + GetObjectValue(Table[i, j])
                                                ));
                                        else if (System.Math.Abs(Table[ii, jj]) == 3)
                                            HA += (Sign * System.Math.Abs(HourseValue + GetObjectValue(Table[i, j])
                                                ));
                                        else if (System.Math.Abs(Table[ii, jj]) == 4)
                                            HA += (Sign * System.Math.Abs(BridgeValue + GetObjectValue(Table[i, j])
                                                ));
                                        else if (System.Math.Abs(Table[ii, jj]) == 5)
                                            HA += (Sign * System.Math.Abs(MinisterValue + GetObjectValue(Table[i, j])
                                                ));
                                        else if (System.Math.Abs(Table[ii, jj]) == 6)
                                            HA += (Sign * System.Math.Abs(KingValue + GetObjectValue(Table[i, j])
                                                ));
                                    }

                                }
                            }
                        }
                    }
                }
            }
            catch (Exception t)
            {
            }

            //Reassignments of Begin Call Global Orders.
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            //Store Local Huristic in Global One.
            HuristicValueMovement += HA * SignOrderToPlate(Order);
            //Return Local Huristic.
            return HA;

        }

        ///Attack Determination.QC_Ok
        public bool Attack(int[,] Tab, int i, int j, int ii, int jj, Color a, int Order)
        {
            int CCurentOrder = ChessRules.CurrentOrder;
            //Initiate Global static  Variable.
            ChessRules.CurrentOrder = Order;
            int[,] Table = new int[8, 8];
            for (int ik = 0; ik < 8; ik++)
                for (int jk = 0; jk < 8; jk++)
                    Table[ik, jk] = Tab[ik, jk];
            
            //when there is a Movment from Parameter One to Second Parameter return Attacke..
            if ((new ChessRules(Table[i, j], Table, Order, i, j)).Rules(i, j, ii, jj, a, Order) && Table[ii, jj] != 0)
            {
                ChessRules.CurrentOrder = CCurentOrder;
                return true;
            }
            ChessRules.CurrentOrder = CCurentOrder;
            return false;
        }
        ///ObjectDanger Determination.QC-OK
        public bool ObjectDanger(int[,] Tab, int i, int j, int ii, int jj, Color a, int Order)
        {
            int CCurrentOrder = ChessRules.CurrentOrder;
            //Initiate Local Varibales.
            int[,] Table = new int[8, 8];
            for (int iii = 0; iii < 8; iii++)
                for (int jjj = 0; jjj < 8; jjj++)
                {
                    Table[iii, jjj] = Tab[iii, jjj];
                }
            ChessRules.CurrentOrder = Order;
            ///When [i,j] is Attacked [ii,jj] retrun true when enemy is located in [ii,jj].
            if ((new ChessRules(Table[i, j], Table, Order, i, j)).Rules(i, j, ii, jj, a, Order))
            {
                //Initiate Local Variables.
                for (int iii = 0; iii < 8; iii++)
                    for (int jjj = 0; jjj < 8; jjj++)
                    {
                        Table[iii, jjj] = Tab[iii, jjj];
                    }
                //Take Movments.
                Table[ii, jj] = Table[i, j];
                Table[i, j] = 0;
                //Consider Check.
                ChessRules AA = new ChessRules(Table[ii, jj], Table, Order, i, j);
                if (AA.ObjectDangourKingMove(Order, Table, false))
                {
                    ChessRules.CurrentOrder = CCurrentOrder;
                    //Return ObjectDanger.
                    if ((AA.CheckGrayObjectDangour) && Order == 1)
                        return true;
                    else
                        if ((AA.CheckBrownObjectDangour) && Order == -1)
                            return true;

                }
                if (AA.CheckMate(Table, Order))
                {
                    ChessRules.CurrentOrder = CCurrentOrder;
                    //Return ObjectDanger.
                    if ((AA.CheckGray || AA.CheckMateGray) && Order == 1)
                        return true;
                    else
                        if ((AA.CheckBrown || AA.CheckMateBrown) && Order == -1)
                            return true;

                }
            }





            ChessRules.CurrentOrder = CCurrentOrder;
            //return Non ObjectDanger.
            return false;
        }

        ///Supportation Determination.QC_OK
        public bool Support(int[,] Tab, int i, int j, int ii, int jj, Color a, int Order)
        {
            //Initiate Local Variables.
            int[,] Table = new int[8, 8];

            for (int iii = 0; iii < 8; iii++)
                for (int jjj = 0; jjj < 8; jjj++)
                    Table[iii, jjj] = Tab[iii, jjj];
            ///When All Tables is Gray.
            if (Table[i, j] > 0 && Table[ii, jj] > 0)
            {
                Table[ii, jj] = 0;
                ///When [i,j] Supporte [ii,jj].
                if ((new ChessRules(Table[i, j], Table, Order, i, j)).Rules(i, j, ii, jj, a, Order))
                {

                    return true;
                }

            }

            for (int iii = 0; iii < 8; iii++)
                for (int jjj = 0; jjj < 8; jjj++)
                    Table[iii, jjj] = Tab[iii, jjj];
            ///When All is Brown.
            if (Table[i, j] < 0 && Table[ii, jj] < 0)
            {
                ///When [i,j] Supporetd [ii,jj].
                Table[ii, jj] = 0;
                if ((new ChessRules(Table[i, j], Table, Order, i, j)).Rules(i, j, ii, jj, a, Table[i, j]))
                {
                    return true;
                }
            }

            return false;
        }
        public bool MaxHuristic(ref int j, int Kin, ref double Less)
        {
            bool Found = false;
            if (Kin == 1)
            {
                for (int i = 0; i < this.PenaltyRegardListSolder.Count; i++)
                {
                    if (PenaltyRegardListSolder[i].IsPenaltyAction() != 0)
                    {
                        if (Less < HuristicListSolder[i][0] +
                            HuristicListSolder[i][1] +
                            HuristicListSolder[i][2] +
                            HuristicListSolder[i][3])
                        {
                            Less = HuristicListSolder[i][0] +
                        HuristicListSolder[i][1] +
                        HuristicListSolder[i][2] +
                        HuristicListSolder[i][3];
                            j = i;
                            Found = true;
                        }

                    }
                }

            }

            else
                if (Kin == 2)
                {
                    for (int i = 0; i < this.PenaltyRegardListElefant.Count; i++)
                    {
                        if (PenaltyRegardListElefant[i].IsPenaltyAction() != 0)
                        {
                            if (Less < HuristicListElefant[i][0] +
                                HuristicListElefant[i][1] +
                                HuristicListElefant[i][2] +
                                HuristicListElefant[i][3])
                            {
                                Less = HuristicListElefant[i][0] +
                            HuristicListElefant[i][1] +
                            HuristicListElefant[i][2] +
                            HuristicListElefant[i][3];
                                j = i;
                                Found = true;
                            }

                        }
                    }
                }
                else
                    if (Kin == 3)
                    {
                        for (int i = 0; i < this.PenaltyRegardListHourse.Count; i++)
                        {
                            if (PenaltyRegardListHourse[i].IsPenaltyAction() != 0)
                            {
                                if (Less < HuristicListHourse[i][0] +
                                    HuristicListHourse[i][1] +
                                    HuristicListHourse[i][2] +
                                    HuristicListHourse[i][3])
                                {
                                    Less = HuristicListHourse[i][0] +
                                HuristicListHourse[i][1] +
                                HuristicListHourse[i][2] +
                                HuristicListHourse[i][3];
                                    j = i;
                                    Found = true;
                                }

                            }
                        }
                    }
                    else
                        if (Kin == 4)
                        {
                            for (int i = 0; i < this.PenaltyRegardListBridge.Count; i++)
                            {
                                if (PenaltyRegardListBridge[i].IsPenaltyAction() != 0)
                                {
                                    if (Less < HuristicListBridge[i][0] +
                                        HuristicListBridge[i][1] +
                                        HuristicListBridge[i][2] +
                                        HuristicListBridge[i][3])
                                    {
                                        Less = HuristicListBridge[i][0] +
                                    HuristicListBridge[i][1] +
                                    HuristicListBridge[i][2] +
                                    HuristicListBridge[i][3];
                                        j = i;
                                        Found = true;
                                    }

                                }
                            }
                        }

                        else
                            if (Kin == 5)
                            {
                                for (int i = 0; i < this.PenaltyRegardListMinister.Count; i++)
                                {
                                    if (PenaltyRegardListMinister[i].IsPenaltyAction() != 0)
                                    {
                                        if (Less < HuristicListMinister[i][0] +
                                            HuristicListMinister[i][1] +
                                            HuristicListMinister[i][2] +
                                            HuristicListMinister[i][3])
                                        {
                                            Less = HuristicListMinister[i][0] +
                                        HuristicListMinister[i][1] +
                                        HuristicListMinister[i][2] +
                                        HuristicListMinister[i][3];
                                            j = i;
                                            Found = true;
                                        }

                                    }
                                }
                            }
                            else
                                if (Kin == 6)
                                {
                                    for (int i = 0; i < this.PenaltyRegardListKing.Count; i++)
                                    {
                                        if (PenaltyRegardListKing[i].IsPenaltyAction() != 0)
                                        {
                                            if (Less < HuristicListKing[i][0] +
                                                HuristicListKing[i][1] +
                                                HuristicListKing[i][2] +
                                                HuristicListKing[i][3])
                                            {
                                                Less = HuristicListKing[i][0] +
                                            HuristicListKing[i][1] +
                                            HuristicListKing[i][2] +
                                            HuristicListKing[i][3];
                                                j = i;
                                                Found = true;
                                            }

                                        }
                                    }
                                }
            return Found;
        }
        public double ReturnHuristic(int ii, int j, int Order)
        {
            double Huristic = 0; ;
            int iIndex = -1, mIndex = -1, jIndex = -1, Kin = -1;
            double Less = Double.MinValue;
            if (ii != -1)
            {
                if (Order == -1)
                {
                    for (int i = 0; i < AStarGreedy.Count; i++)
                    {
                        for (int m = 0; m < AllDraw.SodierMidle; m++)
                        {
                            if (AStarGreedy[i].SolderesOnTable[m] != null)
                            {
                                if (AStarGreedy[i].SolderesOnTable[m].SoldierThinking[0].MaxHuristic(ref jIndex, 1, ref Less))
                                {
                                    iIndex = i;
                                    mIndex = m;
                                    Kin = 1;
                                    Huristic = Less;
                                }
                            }

                        }
                        for (int m = 0; m < AllDraw.ElefantMidle; m++)
                        {
                            if (AStarGreedy[i].ElephantOnTable[m] != null)
                            {
                                if (AStarGreedy[i].ElephantOnTable[m].ElefantThinking[0].MaxHuristic(ref jIndex, 2, ref Less))
                                {
                                    iIndex = i;
                                    mIndex = m;
                                    Kin = 2;
                                    Huristic = Less;
                                }
                            }

                        }
                        for (int m = 0; m < AllDraw.HourseMidle; m++)
                        {
                            if (AStarGreedy[i].HoursesOnTable[m] != null)
                            {
                                if (AStarGreedy[i].HoursesOnTable[m].HourseThinking[0].MaxHuristic(ref jIndex, 3, ref Less))
                                {
                                    iIndex = i;
                                    mIndex = m;
                                    Kin = 3;
                                    Huristic = Less;
                                }
                            }

                        }
                        for (int m = 0; m < AllDraw.BridgeMidle; m++)
                        {
                            if (AStarGreedy[i].BridgesOnTable[m] != null)
                            {
                                if (AStarGreedy[i].BridgesOnTable[m].BridgeThinking[0].MaxHuristic(ref jIndex, 4, ref Less))
                                {
                                    iIndex = i;
                                    mIndex = m;
                                    Kin = 4;
                                    Huristic = Less;
                                }
                            }

                        }
                        for (int m = 0; m < AllDraw.MinisterMidle; m++)
                        {
                            if (AStarGreedy[i].MinisterOnTable[m] != null)
                            {
                                if (AStarGreedy[i].MinisterOnTable[m].MinisterThinking[0].MaxHuristic(ref jIndex, 5, ref Less))
                                {
                                    iIndex = i;
                                    mIndex = m;
                                    Kin = 5;
                                    Huristic = Less;
                                }
                            }

                        }
                        for (int m = 0; m < AllDraw.KingMidle; m++)
                        {
                            if (AStarGreedy[i].KingOnTable[m] != null)
                            {
                                if (AStarGreedy[i].KingOnTable[m].KingThinking[0].MaxHuristic(ref jIndex, 1, ref Less))
                                {
                                    iIndex = i;
                                    mIndex = m;
                                    Kin = 6;
                                    Huristic = Less;
                                }
                            }

                        }
                    }

                }
                else
                {
                    for (int i = 0; i < AStarGreedy.Count; i++)
                    {
                        for (int m = AllDraw.SodierMidle; m < AllDraw.SodierHigh; m++)
                        {
                            if (AStarGreedy[i].SolderesOnTable[m] != null)
                            {
                                if (AStarGreedy[i].SolderesOnTable[m].SoldierThinking[0].MaxHuristic(ref jIndex, 1, ref Less))
                                {
                                    iIndex = i;
                                    mIndex = m;
                                    Kin = 1;
                                    Huristic = Less;
                                }
                            }

                        }
                        for (int m = AllDraw.ElefantMidle; m < AllDraw.ElefantHigh; m++)
                        {
                            if (AStarGreedy[i].ElephantOnTable[m] != null)
                            {
                                if (AStarGreedy[i].ElephantOnTable[m].ElefantThinking[0].MaxHuristic(ref jIndex, 2, ref Less))
                                {
                                    iIndex = i;
                                    mIndex = m;
                                    Kin = 2;
                                    Huristic = Less;
                                }
                            }

                        }
                        for (int m = AllDraw.HourseMidle; m < AllDraw.HourseHight; m++)
                        {
                            if (AStarGreedy[i].HoursesOnTable[m] != null)
                            {
                                if (AStarGreedy[i].HoursesOnTable[m].HourseThinking[0].MaxHuristic(ref jIndex, 3, ref Less))
                                {
                                    iIndex = i;
                                    mIndex = m;
                                    Kin = 3;
                                    Huristic = Less;
                                }
                            }

                        }
                        for (int m = AllDraw.BridgeMidle; m < AllDraw.BridgeHigh; m++)
                        {
                            if (AStarGreedy[i].BridgesOnTable[m] != null)
                            {
                                if (AStarGreedy[i].BridgesOnTable[m].BridgeThinking[0].MaxHuristic(ref jIndex, 4, ref Less))
                                {
                                    iIndex = i;
                                    mIndex = m;
                                    Kin = 4;
                                    Huristic = Less;
                                }
                            }

                        }
                        for (int m = AllDraw.MinisterMidle; m < AllDraw.MinisterHigh; m++)
                        {
                            if (AStarGreedy[i].MinisterOnTable[m] != null)
                            {
                                if (AStarGreedy[i].MinisterOnTable[m].MinisterThinking[0].MaxHuristic(ref jIndex, 5, ref Less))
                                {
                                    iIndex = i;
                                    mIndex = m;
                                    Kin = 5;
                                    Huristic = Less;
                                }
                            }

                        }
                        for (int m = AllDraw.KingMidle; m < AllDraw.KingHigh; m++)
                        {
                            if (AStarGreedy[i].KingOnTable[m] != null)
                            {
                                if (AStarGreedy[i].KingOnTable[m].KingThinking[0].MaxHuristic(ref jIndex, 1, ref Less))
                                {
                                    iIndex = i;
                                    mIndex = m;
                                    Kin = 6;
                                    Huristic = Less;
                                }
                            }

                        }
                    }

                }
                if (System.Math.Abs(Kind) == 1)
                {
                    Huristic += HuristicListSolder[j][0] +
                        HuristicListSolder[j][1] +
                        HuristicListSolder[j][2] +
                        HuristicListSolder[j][3];
                }
                else
                    if (System.Math.Abs(Kind) == 2)
                    {
                        Huristic += HuristicListElefant[j][0] +
                            HuristicListElefant[j][1] +
                            HuristicListElefant[j][2] +
                            HuristicListElefant[j][3];
                    }
                    else
                        if (System.Math.Abs(Kind) == 3)
                        {
                            Huristic += HuristicListHourse[j][0] +
                                HuristicListHourse[j][1] +
                                HuristicListHourse[j][2] +
                                HuristicListHourse[j][3];
                        }
                        else
                            if (System.Math.Abs(Kind) == 4)
                            {
                                Huristic += HuristicListBridge[j][0] +
                                    HuristicListBridge[j][1] +
                                    HuristicListBridge[j][2] +
                                    HuristicListBridge[j][3];
                            }
                            else
                                if (System.Math.Abs(Kind) == 5)
                                {
                                    Huristic += HuristicListMinister[j][0] +
                                        HuristicListMinister[j][1] +
                                        HuristicListMinister[j][2] +
                                        HuristicListMinister[j][3];
                                }
                                else
                                    if (System.Math.Abs(Kind) == 6)
                                    {
                                        Huristic += HuristicListKing[j][0] +
                                            HuristicListKing[j][1] +
                                            HuristicListKing[j][2] +
                                            HuristicListKing[j][3];
                                    }
            }
            else
            {
                if (System.Math.Abs(Kind) == 1)
                {
                    Huristic += HuristicListSolder[j][0] +
                        HuristicListSolder[j][1] +
                        HuristicListSolder[j][2] +
                        HuristicListSolder[j][3];
                }
                else
                    if (System.Math.Abs(Kind) == 2)
                    {
                        Huristic += HuristicListElefant[j][0] +
                            HuristicListElefant[j][1] +
                            HuristicListElefant[j][2] +
                            HuristicListElefant[j][3];
                    }
                    else
                        if (System.Math.Abs(Kind) == 3)
                        {
                            Huristic += HuristicListHourse[j][0] +
                                HuristicListHourse[j][1] +
                                HuristicListHourse[j][2] +
                                HuristicListHourse[j][3];
                        }
                        else
                            if (System.Math.Abs(Kind) == 4)
                            {
                                Huristic += HuristicListBridge[j][0] +
                                    HuristicListBridge[j][1] +
                                    HuristicListBridge[j][2] +
                                    HuristicListBridge[j][3];
                            }
                            else
                                if (System.Math.Abs(Kind) == 5)
                                {
                                    Huristic += HuristicListMinister[j][0] +
                                        HuristicListMinister[j][1] +
                                        HuristicListMinister[j][2] +
                                        HuristicListMinister[j][3];
                                }
                                else
                                    if (System.Math.Abs(Kind) == 6)
                                    {
                                        Huristic += HuristicListKing[j][0] +
                                            HuristicListKing[j][1] +
                                            HuristicListKing[j][2] +
                                            HuristicListKing[j][3];
                                    }

            }
            if (Kin != -1)
            {
                if (Kin == 1)
                    Huristic += AStarGreedy[iIndex].SolderesOnTable[jIndex].SoldierThinking[0].ReturnHuristic(ii, j, Order * -1);
                else
                    if (Kin == 2)
                        Huristic += AStarGreedy[iIndex].ElephantOnTable[jIndex].ElefantThinking[0].ReturnHuristic(ii, j, Order * -1);
                    else
                        if (Kin == 3)
                            Huristic += AStarGreedy[iIndex].HoursesOnTable[jIndex].HourseThinking[0].ReturnHuristic(ii, j, Order * -1);
                        else
                            if (Kin == 4)
                                Huristic += AStarGreedy[iIndex].BridgesOnTable[jIndex].BridgeThinking[0].ReturnHuristic(ii, j, Order * -1);
                            else
                                if (Kin == 5)
                                    Huristic += AStarGreedy[iIndex].MinisterOnTable[jIndex].MinisterThinking[0].ReturnHuristic(ii, j, Order * -1);
                                else
                                    if (Kin == 6)
                                        Huristic += AStarGreedy[iIndex].KingOnTable[jIndex].KingThinking[0].ReturnHuristic(ii, j, Order * -1);

            }
            return Huristic;
        }
        //Returrn of Hurestic Tree.QC_Ok.
        public double ReturnHuristicH(int ii, int j, int Order)
        {
            //if (IsCheck)
            //    return AllDraw.Less + 1;
            int Ki = Kind;
            Kind *= Sign;
            Sign *= -1;
            int COrder = Order;
            double a = 0;
            if (ii != -1)
            {
                if (System.Math.Abs(Kind) == 1)
                {
                    for (int i = 0; i < HuristicListSolder.Count; i++)
                    {

                        for (int iii = 0; iii < this.AStarGreedy.Count; iii++)
                        {
                            a += HuristicListSolder[i][0] +
                              HuristicListSolder[i][1] +
                              HuristicListSolder[i][2] +
                              HuristicListSolder[i][3];


                            try
                            {
                                if (Order == 1)
                                {
                                    Kind = 1;
                                    Order *= -1;
                                    for (int h = 0; h < AllDraw.SodierMidle; h++)

                                        try
                                        {
                                            a += this.AStarGreedy[iii].SolderesOnTable[h].SoldierThinking[0].ReturnHuristic(i, j, Order);
                                        }
                                        catch (Exception t)
                                        {
                                            //
                                        }
                                    Order = COrder;
                                    Kind = 2;
                                    Order *= -1;
                                    for (int h = 0; h < AllDraw.ElefantMidle; h++)

                                        try
                                        {
                                            a += this.AStarGreedy[iii].ElephantOnTable[h].ElefantThinking[0].ReturnHuristic(i, j, Order);
                                        }
                                        catch (Exception t)
                                        {
                                            //
                                        }
                                    Order = COrder;
                                    Kind = 3;
                                    Order *= -1;
                                    for (int h = 0; h < AllDraw.HourseMidle; h++)

                                        try
                                        {
                                            a += this.AStarGreedy[iii].HoursesOnTable[h].HourseThinking[0].ReturnHuristic(i, j, Order);
                                        }
                                        catch (Exception t)
                                        {
                                            //
                                        }
                                    Order = COrder;
                                    Kind = 4;
                                    Order *= -1;
                                    for (int h = 0; h < AllDraw.BridgeMidle; h++)

                                        try
                                        {
                                            a += this.AStarGreedy[iii].BridgesOnTable[h].BridgeThinking[0].ReturnHuristic(i, j, Order);
                                        }
                                        catch (Exception t)
                                        {
                                            //
                                        }
                                    Order = COrder;
                                    Kind = 5;
                                    Order *= -1;
                                    for (int h = 0; h < AllDraw.MinisterMidle; h++)

                                        try
                                        {
                                            a += this.AStarGreedy[iii].MinisterOnTable[h].MinisterThinking[0].ReturnHuristic(i, j, Order);
                                        }
                                        catch (Exception t)
                                        {
                                            //
                                        }
                                    Order = COrder;
                                    Kind = 6;
                                    Order *= -1;
                                    for (int h = 0; h < AllDraw.KingMidle; h++)

                                        try
                                        {
                                            a += this.AStarGreedy[iii].KingOnTable[h].KingThinking[0].ReturnHuristic(i, j, Order);
                                        }
                                        catch (Exception t)
                                        {
                                            //
                                        }
                                }
                                else
                                {
                                    if (Order == -1)
                                    {
                                        Order = COrder;
                                        Kind = -1;
                                        Order *= -1;
                                        for (int h = AllDraw.SodierMidle; h < AllDraw.SodierHigh; h++)

                                            try
                                            {
                                                a += this.AStarGreedy[iii].SolderesOnTable[h].SoldierThinking[0].ReturnHuristic(i, j, Order);
                                            }
                                            catch (Exception t)
                                            {
                                                //
                                            }
                                        Order = COrder;
                                        Kind = -2;
                                        Order *= -1;
                                        for (int h = AllDraw.ElefantMidle; h < AllDraw.ElefantHigh; h++)

                                            try
                                            {
                                                a += this.AStarGreedy[iii].ElephantOnTable[h].ElefantThinking[0].ReturnHuristic(i, j, Order);
                                            }
                                            catch (Exception t)
                                            {
                                                //
                                            }
                                        Order = COrder;

                                        Kind = -3;
                                        Order *= -1;
                                        for (int h = AllDraw.HourseMidle; h < AllDraw.HourseHight; h++)

                                            try
                                            {
                                                a += this.AStarGreedy[iii].HoursesOnTable[h].HourseThinking[0].ReturnHuristic(i, j, Order);
                                            }
                                            catch (Exception t)
                                            {
                                                //
                                            }
                                        Order = COrder;
                                        Kind = -4;
                                        Order *= -1;
                                        for (int h = AllDraw.BridgeMidle; h < AllDraw.BridgeHigh; h++)

                                            try
                                            {
                                                a += this.AStarGreedy[iii].BridgesOnTable[h].BridgeThinking[0].ReturnHuristic(i, j, Order);
                                            }
                                            catch (Exception t)
                                            {
                                                //
                                            }
                                        Order = COrder;
                                        Kind = -5;
                                        Order *= -1;
                                        for (int h = AllDraw.MinisterMidle; h < AllDraw.MinisterHigh; h++)

                                            try
                                            {
                                                a += this.AStarGreedy[iii].MinisterOnTable[h].MinisterThinking[0].ReturnHuristic(i, j, Order);
                                            }
                                            catch (Exception t)
                                            {
                                                //
                                            }
                                        Order = COrder;
                                        Kind = -6;
                                        Order *= -1;
                                        for (int h = AllDraw.KingMidle; h < AllDraw.KingHigh; h++)

                                            try
                                            {
                                                a += this.AStarGreedy[iii].KingOnTable[h].KingThinking[0].ReturnHuristic(i, j, Order);
                                            }
                                            catch (Exception t)
                                            {
                                                //
                                            }
                                        Order = COrder;
                                    }

                                }
                            }
                            catch (Exception t)
                            {
                                //
                            }
                        }
                    }
                }
                else
                    if (System.Math.Abs(Kind) == 2)
                    {

                        for (int i = 0; i < HuristicListElefant.Count; i++)
                        {
                            a += HuristicListElefant[i][0] +
                                HuristicListElefant[i][1] +
                                HuristicListElefant[i][2] +
                                HuristicListElefant[i][3];

                            for (int iii = 0; iii < this.AStarGreedy.Count; iii++)
                                try
                                {
                                    if (Order == 1)
                                    {
                                        Kind = 1;
                                        Order *= -1;
                                        for (int h = 0; h < AllDraw.SodierMidle; h++)

                                            try
                                            {
                                                a += this.AStarGreedy[iii].SolderesOnTable[h].SoldierThinking[0].ReturnHuristic(i, j, Order);
                                            }
                                            catch (Exception t)
                                            {
                                                //
                                            }
                                        Order = COrder;
                                        Kind = 2;
                                        Order *= -1;
                                        for (int h = 0; h < AllDraw.ElefantMidle; h++)

                                            try
                                            {
                                                a += this.AStarGreedy[iii].ElephantOnTable[h].ElefantThinking[0].ReturnHuristic(i, j, Order);
                                            }
                                            catch (Exception t)
                                            {
                                                //
                                            }
                                        Order = COrder;
                                        Kind = 3;
                                        Order *= -1;
                                        for (int h = 0; h < AllDraw.HourseMidle; h++)

                                            try
                                            {
                                                a += this.AStarGreedy[iii].HoursesOnTable[h].HourseThinking[0].ReturnHuristic(i, j, Order);
                                            }
                                            catch (Exception t)
                                            {
                                                //
                                            }
                                        Order = COrder;
                                        Kind = 4;
                                        Order *= -1;
                                        for (int h = 0; h < AllDraw.BridgeMidle; h++)

                                            try
                                            {
                                                a += this.AStarGreedy[iii].BridgesOnTable[h].BridgeThinking[0].ReturnHuristic(i, j, Order);
                                            }
                                            catch (Exception t)
                                            {
                                                //
                                            }
                                        Order = COrder;
                                        Kind = 5;
                                        Order *= -1;
                                        for (int h = 0; h < AllDraw.MinisterMidle; h++)

                                            try
                                            {
                                                a += this.AStarGreedy[iii].MinisterOnTable[h].MinisterThinking[0].ReturnHuristic(i, j, Order);
                                            }
                                            catch (Exception t)
                                            {
                                                //
                                            }
                                        Order = COrder;
                                        Kind = 6;
                                        Order *= -1;
                                        for (int h = 0; h < AllDraw.KingMidle; h++)

                                            try
                                            {
                                                a += this.AStarGreedy[iii].KingOnTable[h].KingThinking[0].ReturnHuristic(i, j, Order);
                                            }
                                            catch (Exception t)
                                            {
                                                //
                                            }
                                    }
                                    else
                                    {
                                        if (Order == -1)
                                        {
                                            Order = COrder;
                                            Kind = -1;
                                            Order *= -1;
                                            for (int h = AllDraw.SodierMidle; h < AllDraw.SodierHigh; h++)

                                                try
                                                {
                                                    a += this.AStarGreedy[iii].SolderesOnTable[h].SoldierThinking[0].ReturnHuristic(i, j, Order);
                                                }
                                                catch (Exception t)
                                                {
                                                    //
                                                }
                                            Order = COrder;
                                            Kind = -2;
                                            Order *= -1;
                                            for (int h = AllDraw.ElefantMidle; h < AllDraw.ElefantHigh; h++)

                                                try
                                                {
                                                    a += this.AStarGreedy[iii].ElephantOnTable[h].ElefantThinking[0].ReturnHuristic(i, j, Order);
                                                }
                                                catch (Exception t)
                                                {
                                                    //
                                                }
                                            Order = COrder;

                                            Kind = -3;
                                            Order *= -1;
                                            for (int h = AllDraw.HourseMidle; h < AllDraw.HourseHight; h++)

                                                try
                                                {
                                                    a += this.AStarGreedy[iii].HoursesOnTable[h].HourseThinking[0].ReturnHuristic(i, j, Order);
                                                }
                                                catch (Exception t)
                                                {
                                                    //
                                                }
                                            Order = COrder;
                                            Kind = -4;
                                            Order *= -1;
                                            for (int h = AllDraw.BridgeMidle; h < AllDraw.BridgeHigh; h++)

                                                try
                                                {
                                                    a += this.AStarGreedy[iii].BridgesOnTable[h].BridgeThinking[0].ReturnHuristic(i, j, Order);
                                                }
                                                catch (Exception t)
                                                {
                                                    //
                                                }
                                            Order = COrder;
                                            Kind = -5;
                                            Order *= -1;
                                            for (int h = AllDraw.MinisterMidle; h < AllDraw.MinisterHigh; h++)

                                                try
                                                {
                                                    a += this.AStarGreedy[iii].MinisterOnTable[h].MinisterThinking[0].ReturnHuristic(i, j, Order);
                                                }
                                                catch (Exception t)
                                                {
                                                    //
                                                }
                                            Order = COrder;
                                            Kind = -6;
                                            Order *= -1;
                                            for (int h = AllDraw.KingMidle; h < AllDraw.KingHigh; h++)

                                                try
                                                {
                                                    a += this.AStarGreedy[iii].KingOnTable[h].KingThinking[0].ReturnHuristic(i, j, Order);
                                                }
                                                catch (Exception t)
                                                {
                                                    //
                                                }
                                            Order = COrder;
                                        }

                                    }
                                }
                                catch (Exception t)
                                {
                                    //
                                }
                        }
                    }
                    else
                        if (System.Math.Abs(Kind) == 3)
                        {

                            for (int i = 0; i < HuristicListHourse.Count; i++)
                            {

                                for (int iii = 0; iii < this.AStarGreedy.Count; iii++)
                                {
                                    a += HuristicListHourse[i][0] +
                                        HuristicListHourse[i][1] +
                                        HuristicListHourse[i][2] +
                                        HuristicListHourse[i][3];
                                    try
                                    {
                                        if (Order == 1)
                                        {
                                            Kind = 1;
                                            Order *= -1;
                                            for (int h = 0; h < AllDraw.SodierMidle; h++)

                                                try
                                                {
                                                    a += this.AStarGreedy[iii].SolderesOnTable[h].SoldierThinking[0].ReturnHuristic(i, j, Order);
                                                }
                                                catch (Exception t)
                                                {
                                                    //
                                                }
                                            Order = COrder;
                                            Kind = 2;
                                            Order *= -1;
                                            for (int h = 0; h < AllDraw.ElefantMidle; h++)

                                                try
                                                {
                                                    a += this.AStarGreedy[iii].ElephantOnTable[h].ElefantThinking[0].ReturnHuristic(i, j, Order);
                                                }
                                                catch (Exception t)
                                                {
                                                    //
                                                }
                                            Order = COrder;
                                            Kind = 3;
                                            Order *= -1;
                                            for (int h = 0; h < AllDraw.HourseMidle; h++)

                                                try
                                                {
                                                    a += this.AStarGreedy[iii].HoursesOnTable[h].HourseThinking[0].ReturnHuristic(i, j, Order);
                                                }
                                                catch (Exception t)
                                                {
                                                    //
                                                }
                                            Order = COrder;
                                            Kind = 4;
                                            Order *= -1;
                                            for (int h = 0; h < AllDraw.BridgeMidle; h++)

                                                try
                                                {
                                                    a += this.AStarGreedy[iii].BridgesOnTable[h].BridgeThinking[0].ReturnHuristic(i, j, Order);
                                                }
                                                catch (Exception t)
                                                {
                                                    //
                                                }
                                            Order = COrder;
                                            Kind = 5;
                                            Order *= -1;
                                            for (int h = 0; h < AllDraw.MinisterMidle; h++)

                                                try
                                                {
                                                    a += this.AStarGreedy[iii].MinisterOnTable[h].MinisterThinking[0].ReturnHuristic(i, j, Order);
                                                }
                                                catch (Exception t)
                                                {
                                                    //
                                                }
                                            Order = COrder;
                                            Kind = 6;
                                            Order *= -1;
                                            for (int h = 0; h < AllDraw.KingMidle; h++)

                                                try
                                                {
                                                    a += this.AStarGreedy[iii].KingOnTable[h].KingThinking[0].ReturnHuristic(i, j, Order);
                                                }
                                                catch (Exception t)
                                                {
                                                    //
                                                }

                                        }
                                        else
                                        {
                                            if (Order == -1)
                                            {
                                                Order = COrder;
                                                Kind = -1;
                                                Order *= -1;
                                                for (int h = AllDraw.SodierMidle; h < AllDraw.SodierHigh; h++)

                                                    try
                                                    {
                                                        a += this.AStarGreedy[iii].SolderesOnTable[h].SoldierThinking[0].ReturnHuristic(i, j, Order);
                                                    }
                                                    catch (Exception t)
                                                    {
                                                        //
                                                    }
                                                Order = COrder;
                                                Kind = -2;
                                                Order *= -1;
                                                for (int h = AllDraw.ElefantMidle; h < AllDraw.ElefantHigh; h++)

                                                    try
                                                    {
                                                        a += this.AStarGreedy[iii].ElephantOnTable[h].ElefantThinking[0].ReturnHuristic(i, j, Order);
                                                    }
                                                    catch (Exception t)
                                                    {
                                                        //
                                                    }
                                                Order = COrder;

                                                Kind = -3;
                                                Order *= -1;
                                                for (int h = AllDraw.HourseMidle; h < AllDraw.HourseHight; h++)

                                                    try
                                                    {
                                                        a += this.AStarGreedy[iii].HoursesOnTable[h].HourseThinking[0].ReturnHuristic(i, j, Order);
                                                    }
                                                    catch (Exception t)
                                                    {
                                                        //
                                                    }
                                                Order = COrder;
                                                Kind = -4;
                                                Order *= -1;
                                                for (int h = AllDraw.BridgeMidle; h < AllDraw.BridgeHigh; h++)

                                                    try
                                                    {
                                                        a += this.AStarGreedy[iii].BridgesOnTable[h].BridgeThinking[0].ReturnHuristic(i, j, Order);
                                                    }
                                                    catch (Exception t)
                                                    {
                                                        //
                                                    }
                                                Order = COrder;
                                                Kind = -5;
                                                Order *= -1;
                                                for (int h = AllDraw.MinisterMidle; h < AllDraw.MinisterHigh; h++)

                                                    try
                                                    {
                                                        a += this.AStarGreedy[iii].MinisterOnTable[h].MinisterThinking[0].ReturnHuristic(i, j, Order);
                                                    }
                                                    catch (Exception t)
                                                    {
                                                        //
                                                    }
                                                Order = COrder;
                                                Kind = -6;
                                                Order *= -1;
                                                for (int h = AllDraw.KingMidle; h < AllDraw.KingHigh; h++)

                                                    try
                                                    {
                                                        a += this.AStarGreedy[iii].KingOnTable[h].KingThinking[0].ReturnHuristic(i, j, Order);
                                                    }
                                                    catch (Exception t)
                                                    {
                                                        //
                                                    }
                                                Order = COrder;
                                            }

                                        }
                                    }
                                    catch (Exception t)
                                    {
                                        //
                                    }
                                }
                            }
                        }
                        else
                            if (System.Math.Abs(Kind) == 4)
                            {

                                for (int i = 0; i < HuristicListBridge.Count; i++)
                                {

                                    for (int iii = 0; iii < this.AStarGreedy.Count; iii++)
                                    {
                                        a += HuristicListBridge[i][0] +
                                            HuristicListBridge[i][1] +
                                            HuristicListBridge[i][2] +
                                            HuristicListBridge[i][3];
                                        try
                                        {
                                            if (Order == 1)
                                            {
                                                Kind = 1;
                                                Order *= -1;
                                                for (int h = 0; h < AllDraw.SodierMidle; h++)

                                                    try
                                                    {
                                                        a += this.AStarGreedy[iii].SolderesOnTable[h].SoldierThinking[0].ReturnHuristic(i, j, Order);
                                                    }
                                                    catch (Exception t)
                                                    {
                                                        //
                                                    }
                                                Order = COrder;
                                                Kind = 2;
                                                Order *= -1;
                                                for (int h = 0; h < AllDraw.ElefantMidle; h++)

                                                    try
                                                    {
                                                        a += this.AStarGreedy[iii].ElephantOnTable[h].ElefantThinking[0].ReturnHuristic(i, j, Order);
                                                    }
                                                    catch (Exception t)
                                                    {
                                                        //
                                                    }
                                                Order = COrder;
                                                Kind = 3;
                                                Order *= -1;
                                                for (int h = 0; h < AllDraw.HourseMidle; h++)

                                                    try
                                                    {
                                                        a += this.AStarGreedy[iii].HoursesOnTable[h].HourseThinking[0].ReturnHuristic(i, j, Order);
                                                    }
                                                    catch (Exception t)
                                                    {
                                                        //
                                                    }
                                                Order = COrder;
                                                Kind = 4;
                                                Order *= -1;
                                                for (int h = 0; h < AllDraw.BridgeMidle; h++)

                                                    try
                                                    {
                                                        a += this.AStarGreedy[iii].BridgesOnTable[h].BridgeThinking[0].ReturnHuristic(i, j, Order);
                                                    }
                                                    catch (Exception t)
                                                    {
                                                        //
                                                    }
                                                Order = COrder;
                                                Kind = 5;
                                                Order *= -1;
                                                for (int h = 0; h < AllDraw.MinisterMidle; h++)

                                                    try
                                                    {
                                                        a += this.AStarGreedy[iii].MinisterOnTable[h].MinisterThinking[0].ReturnHuristic(i, j, Order);
                                                    }
                                                    catch (Exception t)
                                                    {
                                                        //
                                                    }
                                                Order = COrder;
                                                Kind = 6;
                                                Order *= -1;
                                                for (int h = 0; h < AllDraw.KingMidle; h++)

                                                    try
                                                    {
                                                        a += this.AStarGreedy[iii].KingOnTable[h].KingThinking[0].ReturnHuristic(i, j, Order);
                                                    }
                                                    catch (Exception t)
                                                    {
                                                        //
                                                    }
                                            }
                                            else
                                            {
                                                if (Order == -1)
                                                {
                                                    Order = COrder;
                                                    Kind = -1;
                                                    Order *= -1;
                                                    for (int h = AllDraw.SodierMidle; h < AllDraw.SodierHigh; h++)

                                                        try
                                                        {
                                                            a += this.AStarGreedy[iii].SolderesOnTable[h].SoldierThinking[0].ReturnHuristic(i, j, Order);
                                                        }
                                                        catch (Exception t)
                                                        {
                                                            //
                                                        }
                                                    Order = COrder;
                                                    Kind = -2;
                                                    Order *= -1;
                                                    for (int h = AllDraw.ElefantMidle; h < AllDraw.ElefantHigh; h++)

                                                        try
                                                        {
                                                            a += this.AStarGreedy[iii].ElephantOnTable[h].ElefantThinking[0].ReturnHuristic(i, j, Order);
                                                        }
                                                        catch (Exception t)
                                                        {
                                                            //
                                                        }
                                                    Order = COrder;

                                                    Kind = -3;
                                                    Order *= -1;
                                                    for (int h = AllDraw.HourseMidle; h < AllDraw.HourseHight; h++)

                                                        try
                                                        {
                                                            a += this.AStarGreedy[iii].HoursesOnTable[h].HourseThinking[0].ReturnHuristic(i, j, Order);
                                                        }
                                                        catch (Exception t)
                                                        {
                                                            //
                                                        }
                                                    Order = COrder;
                                                    Kind = -4;
                                                    Order *= -1;
                                                    for (int h = AllDraw.BridgeMidle; h < AllDraw.BridgeHigh; h++)

                                                        try
                                                        {
                                                            a += this.AStarGreedy[iii].BridgesOnTable[h].BridgeThinking[0].ReturnHuristic(i, j, Order);
                                                        }
                                                        catch (Exception t)
                                                        {
                                                            //
                                                        }
                                                    Order = COrder;
                                                    Kind = -5;
                                                    Order *= -1;
                                                    for (int h = AllDraw.MinisterMidle; h < AllDraw.MinisterHigh; h++)

                                                        try
                                                        {
                                                            a += this.AStarGreedy[iii].MinisterOnTable[h].MinisterThinking[0].ReturnHuristic(i, j, Order);
                                                        }
                                                        catch (Exception t)
                                                        {
                                                            //
                                                        }
                                                    Order = COrder;
                                                    Kind = -6;
                                                    Order *= -1;
                                                    for (int h = AllDraw.KingMidle; h < AllDraw.KingHigh; h++)

                                                        try
                                                        {
                                                            a += this.AStarGreedy[iii].KingOnTable[h].KingThinking[0].ReturnHuristic(i, j, Order);
                                                        }
                                                        catch (Exception t)
                                                        {
                                                            //
                                                        }
                                                    Order = COrder;
                                                }

                                            }
                                        }
                                        catch (Exception t)
                                        {
                                            //
                                        }
                                    }
                                }
                            }
                            else
                                if (System.Math.Abs(Kind) == 5)
                                {

                                    for (int i = 0; i < HuristicListMinister.Count; i++)
                                    {

                                        for (int iii = 0; iii < this.AStarGreedy.Count; iii++)
                                        {
                                            a += HuristicListMinister[i][0] +
                                                HuristicListMinister[i][1] +
                                                HuristicListMinister[i][2] +
                                                HuristicListMinister[i][3];
                                            try
                                            {
                                                if (Order == 1)
                                                {
                                                    Kind = 1;
                                                    Order *= -1;
                                                    for (int h = 0; h < AllDraw.SodierMidle; h++)

                                                        try
                                                        {
                                                            a += this.AStarGreedy[iii].SolderesOnTable[h].SoldierThinking[0].ReturnHuristic(i, j, Order);
                                                        }
                                                        catch (Exception t)
                                                        {
                                                            //
                                                        }
                                                    Order = COrder;
                                                    Kind = 2;
                                                    Order *= -1;
                                                    for (int h = 0; h < AllDraw.ElefantMidle; h++)

                                                        try
                                                        {
                                                            a += this.AStarGreedy[iii].ElephantOnTable[h].ElefantThinking[0].ReturnHuristic(i, j, Order);
                                                        }
                                                        catch (Exception t)
                                                        {
                                                            //
                                                        }
                                                    Order = COrder;
                                                    Kind = 3;
                                                    Order *= -1;
                                                    for (int h = 0; h < AllDraw.HourseMidle; h++)

                                                        try
                                                        {
                                                            a += this.AStarGreedy[iii].HoursesOnTable[h].HourseThinking[0].ReturnHuristic(i, j, Order);
                                                        }
                                                        catch (Exception t)
                                                        {
                                                            //
                                                        }
                                                    Order = COrder;
                                                    Kind = 4;
                                                    Order *= -1;
                                                    for (int h = 0; h < AllDraw.BridgeMidle; h++)

                                                        try
                                                        {
                                                            a += this.AStarGreedy[iii].BridgesOnTable[h].BridgeThinking[0].ReturnHuristic(i, j, Order);
                                                        }
                                                        catch (Exception t)
                                                        {
                                                            //
                                                        }
                                                    Order = COrder;
                                                    Kind = 5;
                                                    Order *= -1;
                                                    for (int h = 0; h < AllDraw.MinisterMidle; h++)

                                                        try
                                                        {
                                                            a += this.AStarGreedy[iii].MinisterOnTable[h].MinisterThinking[0].ReturnHuristic(i, j, Order);
                                                        }
                                                        catch (Exception t)
                                                        {
                                                            //
                                                        }
                                                    Order = COrder;
                                                    Kind = 6;
                                                    Order *= -1;
                                                    for (int h = 0; h < AllDraw.KingMidle; h++)

                                                        try
                                                        {
                                                            a += this.AStarGreedy[iii].KingOnTable[h].KingThinking[0].ReturnHuristic(i, j, Order);
                                                        }
                                                        catch (Exception t)
                                                        {
                                                            //
                                                        }
                                                }
                                                else
                                                {
                                                    if (Order == -1)
                                                    {
                                                        Order = COrder;
                                                        Kind = -1;
                                                        Order *= -1;
                                                        for (int h = AllDraw.SodierMidle; h < AllDraw.SodierHigh; h++)

                                                            try
                                                            {
                                                                a += this.AStarGreedy[iii].SolderesOnTable[h].SoldierThinking[0].ReturnHuristic(i, j, Order);
                                                            }
                                                            catch (Exception t)
                                                            {
                                                                //
                                                            }
                                                        Order = COrder;
                                                        Kind = -2;
                                                        Order *= -1;
                                                        for (int h = AllDraw.ElefantMidle; h < AllDraw.ElefantHigh; h++)

                                                            try
                                                            {
                                                                a += this.AStarGreedy[iii].ElephantOnTable[h].ElefantThinking[0].ReturnHuristic(i, j, Order);
                                                            }
                                                            catch (Exception t)
                                                            {
                                                                //
                                                            }
                                                        Order = COrder;

                                                        Kind = -3;
                                                        Order *= -1;
                                                        for (int h = AllDraw.HourseMidle; h < AllDraw.HourseHight; h++)

                                                            try
                                                            {
                                                                a += this.AStarGreedy[iii].HoursesOnTable[h].HourseThinking[0].ReturnHuristic(i, j, Order);
                                                            }
                                                            catch (Exception t)
                                                            {
                                                                //
                                                            }
                                                        Order = COrder;
                                                        Kind = -4;
                                                        Order *= -1;
                                                        for (int h = AllDraw.BridgeMidle; h < AllDraw.BridgeHigh; h++)

                                                            try
                                                            {
                                                                a += this.AStarGreedy[iii].BridgesOnTable[h].BridgeThinking[0].ReturnHuristic(i, j, Order);
                                                            }
                                                            catch (Exception t)
                                                            {
                                                                //
                                                            }
                                                        Order = COrder;
                                                        Kind = -5;
                                                        Order *= -1;
                                                        for (int h = AllDraw.MinisterMidle; h < AllDraw.MinisterHigh; h++)

                                                            try
                                                            {
                                                                a += this.AStarGreedy[iii].MinisterOnTable[h].MinisterThinking[0].ReturnHuristic(i, j, Order);
                                                            }
                                                            catch (Exception t)
                                                            {
                                                                //
                                                            }
                                                        Order = COrder;
                                                        Kind = -6;
                                                        Order *= -1;
                                                        for (int h = AllDraw.KingMidle; h < AllDraw.KingHigh; h++)

                                                            try
                                                            {
                                                                a += this.AStarGreedy[iii].KingOnTable[h].KingThinking[0].ReturnHuristic(i, j, Order);
                                                            }
                                                            catch (Exception t)
                                                            {
                                                                //
                                                            }
                                                        Order = COrder;
                                                    }

                                                }
                                            }
                                            catch (Exception t)
                                            {
                                                //
                                            }
                                        }
                                    }
                                }
                                else
                                    if (System.Math.Abs(Kind) == 6)
                                    {

                                        for (int i = 0; i < HuristicListKing.Count; i++)
                                        {

                                            for (int iii = 0; iii < this.AStarGreedy.Count; iii++)
                                            {
                                                a += HuristicListKing[i][0] +
                                                    HuristicListKing[i][1] +
                                                    HuristicListKing[i][2] +
                                                    HuristicListKing[i][3];
                                                try
                                                {
                                                    if (Order == 1)
                                                    {
                                                        Kind = 1;
                                                        Order *= -1;
                                                        for (int h = 0; h < AllDraw.SodierMidle; h++)

                                                            try
                                                            {
                                                                a += this.AStarGreedy[iii].SolderesOnTable[h].SoldierThinking[0].ReturnHuristic(i, j, Order);
                                                            }
                                                            catch (Exception t)
                                                            {
                                                                //
                                                            }
                                                        Order = COrder;
                                                        Kind = 2;
                                                        Order *= -1;
                                                        for (int h = 0; h < AllDraw.ElefantMidle; h++)

                                                            try
                                                            {
                                                                a += this.AStarGreedy[iii].ElephantOnTable[h].ElefantThinking[0].ReturnHuristic(i, j, Order);
                                                            }
                                                            catch (Exception t)
                                                            {
                                                                //
                                                            }
                                                        Order = COrder;
                                                        Kind = 3;
                                                        Order *= -1;
                                                        for (int h = 0; h < AllDraw.HourseMidle; h++)

                                                            try
                                                            {
                                                                a += this.AStarGreedy[iii].HoursesOnTable[h].HourseThinking[0].ReturnHuristic(i, j, Order);
                                                            }
                                                            catch (Exception t)
                                                            {
                                                                //
                                                            }
                                                        Order = COrder;
                                                        Kind = 4;
                                                        Order *= -1;
                                                        for (int h = 0; h < AllDraw.BridgeMidle; h++)

                                                            try
                                                            {
                                                                a += this.AStarGreedy[iii].BridgesOnTable[h].BridgeThinking[0].ReturnHuristic(i, j, Order);
                                                            }
                                                            catch (Exception t)
                                                            {
                                                                //
                                                            }
                                                        Order = COrder;
                                                        Kind = 5;
                                                        Order *= -1;
                                                        for (int h = 0; h < AllDraw.MinisterMidle; h++)

                                                            try
                                                            {
                                                                a += this.AStarGreedy[iii].MinisterOnTable[h].MinisterThinking[0].ReturnHuristic(i, j, Order);
                                                            }
                                                            catch (Exception t)
                                                            {
                                                                //
                                                            }
                                                        Order = COrder;
                                                        Kind = 6;
                                                        Order *= -1;
                                                        for (int h = 0; h < AllDraw.KingMidle; h++)

                                                            try
                                                            {
                                                                a += this.AStarGreedy[iii].KingOnTable[h].KingThinking[0].ReturnHuristic(i, j, Order);
                                                            }
                                                            catch (Exception t)
                                                            {
                                                                //
                                                            }
                                                    }
                                                    else
                                                    {
                                                        if (Order == -1)
                                                        {
                                                            Order = COrder;
                                                            Kind = -1;
                                                            Order *= -1;
                                                            for (int h = AllDraw.SodierMidle; h < AllDraw.SodierHigh; h++)

                                                                try
                                                                {
                                                                    a += this.AStarGreedy[iii].SolderesOnTable[h].SoldierThinking[0].ReturnHuristic(i, j, Order);
                                                                }
                                                                catch (Exception t)
                                                                {
                                                                    //
                                                                }
                                                            Order = COrder;
                                                            Kind = -2;
                                                            Order *= -1;
                                                            for (int h = AllDraw.ElefantMidle; h < AllDraw.ElefantHigh; h++)

                                                                try
                                                                {
                                                                    a += this.AStarGreedy[iii].ElephantOnTable[h].ElefantThinking[0].ReturnHuristic(i, j, Order);
                                                                }
                                                                catch (Exception t)
                                                                {
                                                                    //
                                                                }
                                                            Order = COrder;

                                                            Kind = -3;
                                                            Order *= -1;
                                                            for (int h = AllDraw.HourseMidle; h < AllDraw.HourseHight; h++)

                                                                try
                                                                {
                                                                    a += this.AStarGreedy[iii].HoursesOnTable[h].HourseThinking[0].ReturnHuristic(i, j, Order);
                                                                }
                                                                catch (Exception t)
                                                                {
                                                                    //
                                                                }
                                                            Order = COrder;
                                                            Kind = -4;
                                                            Order *= -1;
                                                            for (int h = AllDraw.BridgeMidle; h < AllDraw.BridgeHigh; h++)

                                                                try
                                                                {
                                                                    a += this.AStarGreedy[iii].BridgesOnTable[h].BridgeThinking[0].ReturnHuristic(i, j, Order);
                                                                }
                                                                catch (Exception t)
                                                                {
                                                                    //
                                                                }
                                                            Order = COrder;
                                                            Kind = -5;
                                                            Order *= -1;
                                                            for (int h = AllDraw.MinisterMidle; h < AllDraw.MinisterHigh; h++)

                                                                try
                                                                {
                                                                    a += this.AStarGreedy[iii].MinisterOnTable[h].MinisterThinking[0].ReturnHuristic(i, j, Order);
                                                                }
                                                                catch (Exception t)
                                                                {
                                                                    //
                                                                }
                                                            Order = COrder;
                                                            Kind = -6;
                                                            Order *= -1;
                                                            for (int h = AllDraw.KingMidle; h < AllDraw.KingHigh; h++)

                                                                try
                                                                {
                                                                    a += this.AStarGreedy[iii].KingOnTable[h].KingThinking[0].ReturnHuristic(i, j, Order);
                                                                }
                                                                catch (Exception t)
                                                                {
                                                                    //
                                                                }
                                                            Order = COrder;
                                                        }

                                                    }
                                                }
                                                catch (Exception t)
                                                {
                                                    //
                                                }
                                            }
                                        }
                                    }
            }
            else
            {

                if (System.Math.Abs(Kind) == 1)
                {
                    a += HuristicListSolder[j][0] +
                        HuristicListSolder[j][1] +
                        HuristicListSolder[j][2] +
                        HuristicListSolder[j][3];
                }
                else
                    if (System.Math.Abs(Kind) == 2)
                    {
                        a += HuristicListElefant[j][0] +
                            HuristicListElefant[j][1] +
                            HuristicListElefant[j][2] +
                            HuristicListElefant[j][3];
                    }
                    else
                        if (System.Math.Abs(Kind) == 3)
                        {
                            a += HuristicListHourse[j][0] +
                                HuristicListHourse[j][1] +
                                HuristicListHourse[j][2] +
                                HuristicListHourse[j][3];
                        }
                        else
                            if (System.Math.Abs(Kind) == 4)
                            {
                                a += HuristicListBridge[j][0] +
                                    HuristicListBridge[j][1] +
                                    HuristicListBridge[j][2] +
                                    HuristicListBridge[j][3];
                            }
                            else
                                if (System.Math.Abs(Kind) == 5)
                                {
                                    a += HuristicListMinister[j][0] +
                                        HuristicListMinister[j][1] +
                                        HuristicListMinister[j][2] +
                                        HuristicListMinister[j][3];
                                }
                                else
                                    if (System.Math.Abs(Kind) == 6)
                                    {
                                        a += HuristicListKing[j][0] +
                                            HuristicListKing[j][1] +
                                            HuristicListKing[j][2] +
                                            HuristicListKing[j][3];
                                    }
            }
            Kind = Ki;
            return a;
        }
        //Scope of Every Objects Movments.QC-OK
        bool Scop(int i, int j, int ii, int jj, int Kind)
        {
            bool Validity = false;
            if (Kind == 1)//Sodier
            {
                if (System.Math.Abs(i - ii) <= 2 && System.Math.Abs(j - jj) <= 2)
                    Validity = true;
            }
            else
                if (Kind == 2)//Elephant
                {
                    if (System.Math.Abs(i - ii) == System.Math.Abs(j - jj))

                        Validity = true;
                }
                else
                    if (Kind == 3)
                    {
                        if (System.Math.Abs(i - ii) <= 2 && System.Math.Abs(j - jj) <= 2)
                            Validity = true;
                    }
                    else
                        if (Kind == 4)
                        {
                            if ((i == ii && j != jj) || (i != ii && j == jj))
                                Validity = true;
                        }
                        else
                            if (Kind == 5)
                            {
                                if (((i == ii && j != jj) || (i != ii && j == jj)) || System.Math.Abs(i - ii) == System.Math.Abs(j - jj))
                                    Validity = true;
                            }
                            else
                                if (Kind == 6)
                                {
                                    if (System.Math.Abs(i - ii) <= 1 && System.Math.Abs(j - jj) <= 1)
                                        Validity = true;
                                }
            return Validity;
        }
        //when current movments is suitable for movments return true.

        //Determine when current movment is suitable and is not dangrous return false.QC-OK
        bool IsAllTraversalHomeIsDangerous(int[,] Table, int ii, int jj,
            int iii, int jjj,
            //int iiiO, int jjjO,
            int Order, Color a)
        {
            //setting false.
            bool IsDangreous = false;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            int COr = Order;

            //Clone a Table.
            int[,] Tab = new int[8, 8];
            for (int ik = 0; ik < 8; ik++)
                for (int jk = 0; jk < 8; jk++)
                    Tab[ik, jk] = Table[ik, jk];

            //ChessRules.CurrentOrder *= -1;
            //Order *= -1;
            if (Order == 1)
                a = Color.Gray;
            else
                a = Color.Brown;

            //For Self Objects.
            int iiii = ii, jjjj = jj;
            ChessRules A = new ChessRules(Tab[iiii, jjjj], Tab, Order, iiii, jjjj);            
            if (A.ObjectDangourKingMove(Order, Tab, false))
            {
                if (Order == 1 && A.CheckGrayObjectDangour)
                {
                    IsDangreous = true;
                    return true;
                }
                if (Order == -1 && A.CheckBrownObjectDangour)
                {
                    IsDangreous = true;
                    return true;
                }
            }
            //for (int iiii = 0; iiii < 8; iiii++)
            {
                //  for (int jjjj = 0; jjjj < 8; jjjj++)
                {
                    //    if (Order == 1 && Tab[iiii, jjjj] <= 0)
                    //     continue;
                    //if (Order == -1 && Tab[iiii, jjjj] >= 0)
                    // continue;
                    //For Enemy Order Objects.
                    for (int iiiii = 0; iiiii < 8; iiiii++)
                    {
                        for (int jjjjj = 0; jjjjj < 8; jjjjj++)
                        {
                            if (Order == 1 && Tab[iiiii, jjjjj] > 0)
                                continue;
                            if (Order == -1 && Tab[iiiii, jjjjj] < 0)
                                continue;


                            if (Order * -1 == 1)
                                a = Color.Gray;
                            else
                                a = Color.Brown;
                            //When Enemy Attacks Current Order.
                            if (Attack(Tab, iiiii, jjjjj, iiii, jjjj, a, Order * -1))
                            {
                                //bool Sup = false;
                                if (GetObjectValue(Tab[iiii, jjjj]) <= GetObjectValue(Tab[iiiii, jjjjj]))
                                {
                                    IsDangreous = false;
                                }
                                else
                                {
                                    IsDangreous = true;
                                    return true;
                                }
                            }
                            else
                            {
                                IsDangreous = false;
                                
                                //For Enemy Order.
                                /*for (int h = 0; h < 8; h++)
                                {
                                    for (int g = 0; g < 8; g++)
                                    {
                                        if (Order == 1 && Tab[h, g] >= 0)
                                            continue;
                                        if (Order == -1 && Tab[h, g] <= 0)
                                            continue;
                                        //For Current Order and Empty.
                                        for (int m = 0; m < 8; m++)
                                        {
                                            for (int n = 0; n < 8; n++)
                                            {
                                                if (Order == 1 && Tab[m, n] < 0)
                                                    continue;
                                                if (Order == -1 && Tab[m, n] > 0)
                                                    continue;

                                                for (int ik = 0; ik < 8; ik++)
                                                    for (int jk = 0; jk < 8; jk++)
                                                        Tab[ik, jk] = Table[ik, jk];
                                                if (Order * -1 == 1)
                                                    a = Color.Gray;
                                                else
                                                    a = Color.Brown;
                                                if ((new ChessRules(Tab[h, g], Tab, Order * -1, h, g)).Rules(h, g, m, n, a, Tab[h, g]))
                                                {
                                                    if (m == iiii && n == jjjj)
                                                    {
                                                        IsDangreous = true;
                                                        return true;
                                                    }
                                                    Tab[m, n] = Tab[h, g];
                                                    Tab[h, g] = 0;
                                                    if (Order * -1 == 1)
                                                        a = Color.Gray;
                                                    else
                                                        a = Color.Brown;
                                                    if (Attack(Tab, m, n, iiii, jjjj, a, Order * -1))
                                                    {
                                                        //if (GetObjectValue(Tab[m, n]) <= GetObjectValue(Tab[iiiii, jjjjj]))
                                                       // {
                                                            IsDangreous = true;
                                                            return true;
                                                        //}
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }*/
                            }
                        }
                        
                    }
                }
            }

            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            return IsDangreous;
        }
        ///Kernel of Thinking
        public void Thinking()
        {
            bool PenRegStrore = UsePenaltyRegardMechnisam;
            if (Order != FormRefrigtz.OrderPlate)
                UsePenaltyRegardMechnisam = false;

            //Thread.Sleep(500);
            BeginThread++;
            if (CheckMateOcuured //|| FoundFirstMating
                )
            {
                ThinkingFinished = true;
                EndThread++;
                UsePenaltyRegardMechnisam = PenRegStrore;
                return;
            }
            //if (!FormRefrigtz.ArrangmentsChanged)
            //   Application.Exit();
            //if (AllDraw.FoundATable)
            //  return;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            //Initiate Locallly Global Variables. 
            TableListSolder.Clear();
            TableListElefant.Clear();
            TableListHourse.Clear();
            TableListBridge.Clear();
            TableListMinister.Clear();
            TableListKing.Clear();
            HuristicListBridge.Clear();
            HuristicListElefant.Clear();
            HuristicListHourse.Clear();
            HuristicListKing.Clear();
            HuristicListMinister.Clear();
            HuristicListSolder.Clear();
            RowColumnSoldier.Clear();
            RowColumnElefant.Clear();
            RowColumnHourse.Clear();
            RowColumnBridge.Clear();
            RowColumnMinister.Clear();
            RowColumnKing.Clear();
            HitNumberSoldier.Clear();
            HitNumberElefant.Clear();
            HitNumberHourse.Clear();
            HitNumberBridge.Clear();
            HitNumberMinister.Clear();
            HitNumberKing.Clear();
            PenaltyRegardListSolder.Clear();
            PenaltyRegardListMinister.Clear();
            PenaltyRegardListKing.Clear();
            PenaltyRegardListHourse.Clear();
            PenaltyRegardListElefant.Clear();
            PenaltyRegardListBridge.Clear();
            IndexSoldier = 0;
            IndexElefant = 0;
            IndexHourse = 0;
            IndexBridge = 0;
            IndexMinister = 0;
            IndexKing = 0;
            {
                ///For Stored Location of Objects.
                int ii = Row;
                int jj = Column;
                //for (int ii = 0; ii < 8; ii++)
                {
                    //for (int jj = 0; jj < 8; jj++)
                    {
                        ///For Every Tables Home.
                        for (int i = 0; i < 8; i++)
                        {
                            for (int j = 0; j < 8; j++)
                            {
                                if (CheckMateOcuured
                                    //      || FoundFirstMating
                                    )
                                {
                                    ThinkingFinished = true;
                                    EndThread++;
                                    UsePenaltyRegardMechnisam = PenRegStrore;
                                    return;
                                }
                                //if (AllDraw.FoundATable)
                                //    return;
                                IgnoreObjectDangour = -1;

                                //bool IgnoreAchmatPenalty = false;
                                CurrentRow = i;
                                CurrentColumn = j;
                                //bool DontClearPenalty = false;
                                SelfSupported = false;
                                InAttackedNotSelfSupported = false;
                                SelfCheckMateAction = false;
                                AchamazCurrent = false;
                                ///Current is Ignored for Increased of Performance.
                                if (ii == i && jj == j)
                                    continue;
                                HuristicValue = new double();
                                HuristicValueMovement = new double();
                                HuristicValueSelfSupported = new double();
                                HuristicValueObjectDangourCheckMate = new double();

                                /*if (IgnoreSelfObjects)
                                {
                                    if (Kind > 0 && Table[i, j] > 0)
                                        continue;
                                    if (Kind < 0 && Table[i, j] < 0)
                                        continue;
                                }
                                 */
                                ///Initiate a Local Variables.
                                int[,] TableS = new int[8, 8];
                                ///"Inizialization of This New Class (Current is Dynamic class Object) is MalFunction (Constant Variable Count).
                                QuantumAtamata Current = new QuantumAtamata(3, 3, 3);
                                ///Most Dot Net FrameWork Hot Path
                                ///Create A Clone of Current Table Constant in ThinkingChess Object Tasble.
                                for (int iii = 0; iii < 8; iii++)
                                    for (int jjj = 0; jjj < 8; jjj++)
                                    {
                                        TableS[iii, jjj] = TableConst[iii, jjj];
                                    }
                                ///Deterimine Current Table Order and Color.
                                if (TableS[ii, jj] > 0 && CurrentArray < ThingsNumber / 2 && Order == 1)
                                    color = Color.Gray;
                                else
                                    if (TableS[ii, jj] < 0 && CurrentArray >= ThingsNumber / 2 && Order == -1)
                                        color = Color.Brown;
                                    else
                                    {
                                        if (!ThinkingBegin)
                                        {
                                            ThinkingFinished = true;
                                            EndThread++;
                                            UsePenaltyRegardMechnisam = PenRegStrore;
                                            //ThinkingRun = false;
                                            return;
                                        }
                                    }
                                //if (!ExistTableInList(CurrentArray, AllDraw.TNN, 0))
                                //  AllDraw.TNN.Add(CurrentArray);
                                ///Ignore of Additinal Non Profit Objects and Empty Home. 
                                //if (Order == 1 && TableS[i, j] > 0)
                                //    continue;
                                //if (Order == -1 && TableS[i, j] < 0)
                                //    continue;
                                //  if (Order == 1 && TableS[ii, jj] < 0)
                                //    continue;
                                //if (Order == -1 && TableS[ii, jj] > 0)
                                //  continue;
                                ///Deterimine for Bridge King Wrongly Desision.
                                bool Bridge = false;
                                ChessRules.ExistInDestinationEnemy = false;
                                bool DoEnemySelf = true;
                                ChessRules AAA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                if (AAA.CheckMate(TableS, Order))
                                {

                                    if (AAA.CheckMateGray || AAA.CheckMateBrown)
                                    {
                                        ThinkingFinished = true;
                                        CheckMateOcuured = true;
                                        EndThread++;
                                        UsePenaltyRegardMechnisam = PenRegStrore;
                                        return;
                                    }
                                }
                                if (Order == 1 && AAA.CheckGray)
                                {
                                    IgnoreObjectDangour = 0;
                                   /* if (FormRefrigtz.ProfesionalWithComputer)
                                    {
                                        ThinkingFinished = true;
                                        ChessRules.BridgeActGray = true;
                                        EndThread++;
                                        return;
                                    }
                                    */ 
                                    IsCheck = true;
                                    DoEnemySelf = false;
                                }
                                if (Order == -1 && AAA.CheckBrown)
                                {
                                    IgnoreObjectDangour = 0;
                                    /*if (FormRefrigtz.ProfesionalWithComputer)
                                    {
                                        ThinkingFinished = true;
                                        ChessRules.BridgeActBrown = true;
                                        EndThread++;
                                        return;
                                    }
                                     */ 
                                    IsCheck = true;
                                    DoEnemySelf = false;
                                }
                                //When Root is CheckMate Benefit of Current Order No Consideration.
                                int CDumnmy = ChessRules.CurrentOrder;
                                bool EnemyCheckMateAction = false;
                                Order = DummyOrder;
                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                ///Calculate Bridges of Gray King.
                                if ((new ChessRules(7, TableS, Order, ii, jj)).Rules(ii, jj, i, j, color, 7) && (ChessRules.BridgeKingAllowedGray))
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //When is Bridges Gray King.

                                    {
                                        //Predict Huristic Caluculatio Before Movments.
                                        ThinkingRun = true;
                                        //int EnemyVarAttacker1 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                        //int AttacakerVar1 = AttackerCount(TableS, Order, color, ii, jj);
                                        //int SupporterVar1 = SupporterCount(TableS, Order, color, ii, jj);
                                        HuristicAttack(TableS, Order, color);
                                        HuristicMovment(TableS, color);
                                        HuristicSelfSupported(TableS, Order, color);
                                        HuristicCheckAndCheckMate(TableS, color);
                                        //HuristicObjectDangour(TableS, Order, color);
                                        HuristicHitting(TableS, ii, jj, Order, color, false);
                                        HuristicReducsedAttack(TableS, Order, color);
                                        HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, ii, jj);
                                        bool IsSuitbale = new bool();
                                        bool IsGardNotMovable = new bool();
                                        bool IsNextMovemntIsCheckOrCheckMateForCurrent = new bool();
                                        bool IsDangerous = new bool();
                                        //int EnemyVarAttacker2 = new int();
                                        //int AttacakerVar2 = new int();
                                        //int SupporterVar2 = new int();
                                        bool CanHittingAnUnSupportedEnemy = new bool();
                                        bool InDangrousUnSupported = new bool();
                                        //bool NumbersOf = new bool();
                                        //bool NumbersOfDangourous = new bool();
                                      /*  if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count)
                                        {

                                            //IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                            //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                            //IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                            //IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                        }
                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count)
                                        {
                                            //Mechanisam of Regrad.

                                            IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                            //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                            IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, ii, jj);
                                            IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                            InAttackedEnemyNotSupporetd(TableS, Order, color, ii, jj, i, j);
                                            InAttackedُSelfNotSupporetd(TableS, Order, color, ii, jj);
                                            IsDangerous = IsAllTraversalHomeIsDangerous(TableS, ii, jj, i, j, Order, color);
                                            //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                            //AttacakerVar2 = AttackerCount(TableS, Order, color, ii, jj);
                                            //SupporterVar2 = SupporterCount(TableS, Order, color, ii, jj);

                                            CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                            InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                            //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                            //NumbersOfDangourous = NumbersOf;

                                        }      //Consideration of Prevention from going Check State by self order.

                                        ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                        if (!UsePenaltyRegardMechnisam)
                                            if (AA.Check(TableS, Order))
                                            {
                                                if (Order == 1 && AA.CheckGray)
                                                    continue;
                                                else
                                                    if (Order == -1 && AA.CheckBrown)
                                                        continue;
                                            }
                                        if (IgnoreObjectDangour == 0)
                                            IgnoreObjectDangour = 1;

                                        ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                        if (Current.IsPenaltyAction() != 0 && UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count)
                                        {

                                            PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                            ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                            if (A.Check(TableS, Order))
                                            {
                                                if (Order == 1 && (A.CheckGray))
                                                    Current.LearningAlgorithmPenalty();
                                                else
                                                    if (Order == -1 && (A.CheckBrown))
                                                        Current.LearningAlgorithmPenalty();

                                                PenaltyRegardListKing.Add(Current);
                                            }
                                            else
                                            {
                                                if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                {
                                                    Current.LearningAlgorithmPenalty();
                                                    PenaltyRegardListKing.Add(Current);
                                                }
                                                else
                                                    PenaltyRegardListKing.Add(Current);
                                            }
                                        }
                                        else
                                            PenaltyRegardListKing.Add(Current);
                                        if (AA.CheckMate(TableS, Order))
                                        {

                                            if (Order == 1 && AA.CheckMateBrown)
                                            {
                                                DoEnemySelf = false;
                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                            }
                                            if (Order == -1 && AA.CheckMateGray)
                                            {
                                                DoEnemySelf = false;
                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                            }
                                            if (Order == 1 && AA.CheckMateGray)
                                            {
                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                            }
                                            if (Order == -1 && AA.CheckMateBrown)
                                            {
                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                            }
                                        }
                                        if (AA.ObjectDangourKingMove(Order, TableS, false))
                                        {

                                            if (Order == 1 && AA.CheckGrayObjectDangour)
                                            {
                                                DoEnemySelf = false;
                                                FoundFirstMating = true;
                                                AchamazCurrent = true;
                                            }
                                            if (Order == -1 && AA.CheckBrownObjectDangour)
                                            {
                                                DoEnemySelf = false;
                                                FoundFirstMating = true;
                                                AchamazCurrent = true;
                                            }
                                        }
                                        //Calculate Movment Huristic After Movments.
                                        //if (PredictHuristic)
                                        {
                                            HuristicAttack(TableS, Order, color);
                                            HuristicMovment(TableS, color);
                                            HuristicSelfSupported(TableS, Order, color);
                                            HuristicCheckAndCheckMate(TableS, color);
                                            //HuristicObjectDangour(TableS, Order, color);
                                            HuristicHitting(TableS, i, j, Order, color, false);
                                            HuristicReducsedAttack(TableS, Order, color);
                                            HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, i, j);
                                        }

                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count //+ 1)
                                        {

                                            //For Not Suppored In Attacked.
                                            if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                            {
                                                //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                {
                                                    if (Current.IsPenaltyAction() != 0)
                                                    {
                                                        //DontClearPenalty = true;
                                                        PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                        Current.LearningAlgorithmPenalty();
                                                        PenaltyRegardListKing.Add(Current);
                                                    }
                                                }
                                            }
                                            //For Ocuuring in Enemy CheckMate.
                                            if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                            {
                                                if (Current.IsPenaltyAction() != 0)
                                                {
                                                    PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                    Current.LearningAlgorithmRegard();
                                                    PenaltyRegardListKing.Add(Current);
                                                    //IgnoreAchmatPenalty = true;
                                                }
                                            }
                                            //For Preventing of Self CheckMate.
                                            if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                            {
                                                if (Current.IsPenaltyAction() != 0)
                                                {
                                                    //DontClearPenalty = true;
                                                    PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                    Current.LearningAlgorithmPenalty();
                                                    PenaltyRegardListKing.Add(Current);
                                                }
                                            }
                                            //For Ocuuring Enemy Garding Objects.
                                            if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                            {
                                                //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                {
                                                    if (Current.IsPenaltyAction() != 0)
                                                    {

                                                        PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                        Current.LearningAlgorithmRegard();
                                                        PenaltyRegardListKing.Add(Current);
                                                        //IgnoreAchmatPenalty = true;
                                                    }
                                                }
                                            }

                                            if (AchamazCurrent && IgnoreObjectDangour == 1)
                                            {
                                                PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                Current.LearningAlgorithmPenalty();
                                                PenaltyRegardListKing.Add(Current);
                                            }
                                            bool IgnoreRemove = false;
                                            if (AA.CheckGray && Order == 1)
                                                IgnoreRemove = true;
                                            else
                                                if (AA.CheckBrown && Order == -1)
                                                    IgnoreRemove = true;
                                            if (Current.IsPenaltyAction() == 0)if(RemovePenalty(TableS, Order, i, j))
                                            {
                                                Current = new QuantumAtamata(3, 3, 3);
                                                PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                PenaltyRegardListKing.Add(Current);
                                            }

                                        }
                                       */ 
                                        //Act Movments.
                                        if (i < ii)
                                        {
                                            TableS[ii - 1, j] = 4;
                                            TableS[ii - 2, j] = 6;
                                            TableS[ii, jj] = 0;
                                            TableS[0, jj] = 0;

                                        }

                                        else
                                        {
                                            TableS[ii + 1, j] = 4;
                                            TableS[ii + 2, j] = 6;
                                            TableS[ii, jj] = 0;
                                            TableS[7, jj] = 0;

                                        }
                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count //+ 1)
                                            )
                                        {
                                            //Mechanisam of Regrad.

                                            IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, i, j);
                                            //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                            IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                            IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, i, j);
                                            InAttackedEnemyNotSupporetd(TableS, Order, color, i, j, ii, jj);
                                            InAttackedُSelfNotSupporetd(TableS, Order, color, i, j);
                                            IsDangerous = IsAllTraversalHomeIsDangerous(TableS, i, j, ii, jj, Order, color);
                                            //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, i, j);
                                            //AttacakerVar2 = AttackerCount(TableS, Order, color, i, j);
                                            //SupporterVar2 = SupporterCount(TableS, Order, color, i, j);

                                            CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                            InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                            
                                            
                                            //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                            //mbersOfDangourous = NumbersOf;

                                        }
                                        //Consideration of Prevention from going Check State by self order.

                                        ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                        if (!UsePenaltyRegardMechnisam)
                                            if (AA.Check(TableS, Order))
                                            {
                                                if (Order == 1 && AA.CheckGray)
                                                    continue;
                                                else
                                                    if (Order == -1 && AA.CheckBrown)
                                                        continue;
                                            }
                                        if (IgnoreObjectDangour == 0)
                                            IgnoreObjectDangour = 1;

                                        ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                        if (Current.IsPenaltyAction() != 0 && UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count //+ 1)
                                            )
                                        {
                                            //PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                            ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                            if (A.Check(TableS, Order))
                                            {
                                                if (Order == 1 && (A.CheckGray))
                                                    Current.LearningAlgorithmPenalty();
                                                else
                                                    if (Order == -1 && (A.CheckBrown))
                                                        Current.LearningAlgorithmPenalty();

                                                PenaltyRegardListKing.Add(Current);
                                            }
                                            else
                                            {
                                                if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                {
                                                    Current.LearningAlgorithmPenalty();
                                                    PenaltyRegardListKing.Add(Current);
                                                }
                                                else
                                                    PenaltyRegardListKing.Add(Current);
                                            }
                                        }
                                        if (AA.CheckMate(TableS, Order))
                                        {

                                            if (Order == 1 && AA.CheckMateBrown)
                                            {
                                                DoEnemySelf = false;
                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                            }
                                            if (Order == -1 && AA.CheckMateGray)
                                            {
                                                DoEnemySelf = false;
                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                            }
                                            if (Order == 1 && AA.CheckMateGray)
                                            {
                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                            }
                                            if (Order == -1 && AA.CheckMateBrown)
                                            {
                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                            }
                                        }
                                        if (AA.ObjectDangourKingMove(Order, TableS, false))
                                        {

                                            if (Order == 1 && AA.CheckGrayObjectDangour)
                                            {
                                                DoEnemySelf = false;
                                                FoundFirstMating = true;
                                                AchamazCurrent = true;
                                            }
                                            if (Order == -1 && AA.CheckBrownObjectDangour)
                                            {
                                                DoEnemySelf = false;
                                                FoundFirstMating = true;
                                                AchamazCurrent = true;
                                            }
                                        }
                                        //Store Movments Items.
                                        int[] AS = new int[2];
                                        AS[0] = i;
                                        AS[1] = j;
                                        RowColumnKing.Add(AS);
                                        RowColumn[Index, 0] = i;
                                        RowColumn[Index, 1] = j;

                                        Index++;
                                        TableListKing.Add(CloneATable(TableS));
                                        IndexKing++;
                                        //Row = i;
                                        //Column = j;
                                        SelfSupported = false;
                                        InAttackedNotSelfSupported = false;
                                        //Calculate Movment Huristic After Movments.
                                        //if (PredictHuristic)
                                        {
                                            HuristicAttack(TableS, Order, color);
                                            HuristicMovment(TableS, color);
                                            HuristicSelfSupported(TableS, Order, color);
                                            HuristicCheckAndCheckMate(TableS, color);
                                            //HuristicObjectDangour(TableS, Order, color);
                                            HuristicHitting(TableS, i, j, Order, color, false);
                                            HuristicReducsedAttack(TableS, Order, color);
                                            HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, i, j);
                                        }

                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count)
                                        {

                                            //For Not Suppored In Attacked.
                                            if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                            {
                                                //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                {
                                                    if (Current.IsPenaltyAction() != 0)
                                                    {
                                                        //DontClearPenalty = true;
                                                        PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                        Current.LearningAlgorithmPenalty();
                                                        PenaltyRegardListKing.Add(Current);
                                                    }
                                                }
                                            }
                                            //For Ocuuring in Enemy CheckMate.
                                            if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                            {
                                                if (Current.IsPenaltyAction() != 0)
                                                {
                                                    PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                    Current.LearningAlgorithmRegard();
                                                    PenaltyRegardListKing.Add(Current);
                                                    //IgnoreAchmatPenalty = true;
                                                }
                                            }
                                            //For Preventing of Self CheckMate.
                                            if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                            {
                                                if (Current.IsPenaltyAction() != 0)
                                                {
                                                    //DontClearPenalty = true;
                                                    PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                    Current.LearningAlgorithmPenalty();
                                                    PenaltyRegardListKing.Add(Current);
                                                }
                                            }
                                            //For Ocuuring Enemy Garding Objects.
                                            if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                            {
                                                //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                {
                                                    if (Current.IsPenaltyAction() != 0)
                                                    {

                                                        PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                        Current.LearningAlgorithmRegard();
                                                        PenaltyRegardListKing.Add(Current);
                                                        //IgnoreAchmatPenalty = true;
                                                    }
                                                }
                                            }

                                            if (AchamazCurrent && IgnoreObjectDangour == 1)
                                            {
                                                PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                Current.LearningAlgorithmPenalty();
                                                PenaltyRegardListKing.Add(Current);
                                            }
                                            bool IgnoreRemove = false;
                                            if (AA.CheckGray && Order == 1)
                                                IgnoreRemove = true;
                                            else
                                                if (AA.CheckBrown && Order == -1)
                                                    IgnoreRemove = true;

                                            if (Current.IsPenaltyAction() == 0) if (RemovePenalty(TableS, Order, i, j))
                                                {
                                                    Current = new QuantumAtamata(3, 3, 3);
                                                    PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                    PenaltyRegardListKing.Add(Current);
                                                }

                                        }
                                        else
                                            PenaltyRegardListKing.Add(Current);//Calculate Huristic Sumaton and Stor Specificcaly.
                                        double[] Hu = new double[4];

                                        Hu[0] = HuristicValue;
                                        Hu[1] = HuristicValueMovement;
                                        Hu[2] = HuristicValueSelfSupported;
                                        Hu[3] = HuristicValueObjectDangourCheckMate;
                                        HuristicListKing.Add(Hu);
                                        //ChessRules.BridgeActGray = true;                                        
                                        Bridge = true;
                                    }
                                    /*if (FormRefrigtz.ProfesionalWithComputer)
                                    {
                                        if (Order == 1)
                                            ChessRules.CurrentOrder = -1;
                                        else
                                            ChessRules.CurrentOrder = 1;

                                        this.AStarGreedy.Clear();
                                        //this.AStarGreedy[0].TableList.Clear();
                                        this.AStarGreedy.Add(new AllDraw(ref THIS));
                                        this.AStarGreedy[0].TableList.Add(CloneATable(TableS)); ;
                                        this.AStarGreedy[0].SetRowColumn(0);
                                        if (Order == 1)
                                            this.AStarGreedy[0].Initiate(i, j, color, TableS, -1, false, ref THIS.TimerText, ref THIS.BrownTimer);
                                        else
                                            this.AStarGreedy[0].Initiate(i, j, color, TableS, 1, false, ref THIS.TimerText, ref THIS.GrayTimer);
                                    }
                                     */ 
                                }
                                else
                                    ///Calculate of Bridges of Brown.
                                    if ((new ChessRules(-7, TableS, Order, ii, jj)).Rules(ii, jj, i, j, color, -7) && (ChessRules.BridgeKingAllowedBrown))
                                    {
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //When is Brown Bridges King.

                                        {
                                            //Calcuilate Huristic Before Movment.
                                            //int EnemyVarAttacker1 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                            //int AttacakerVar1 = AttackerCount(TableS, Order, color, ii, jj);
                                            //int SupporterVar1 = SupporterCount(TableS, Order, color, ii, jj);
                                            ThinkingRun = true;
                                            HuristicAttack(TableS, Order, color);
                                            HuristicMovment(TableS, color);
                                            HuristicSelfSupported(TableS, Order, color);
                                            HuristicCheckAndCheckMate(TableS, color);
                                            //HuristicObjectDangour(TableS, Order, color);
                                            HuristicHitting(TableS, ii, jj, Order, color, false);
                                            HuristicReducsedAttack(TableS, Order, color);
                                            HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, ii, jj);
                                            bool IsSuitbale = new bool();
                                            bool IsGardNotMovable = new bool();
                                            bool IsNextMovemntIsCheckOrCheckMateForCurrent = new bool();
                                            bool IsDangerous = new bool();
                                            //int EnemyVarAttacker2 = new int();
                                            //int AttacakerVar2 = new int();
                                            //int SupporterVar2 = new int();
                                            bool CanHittingAnUnSupportedEnemy = new bool();
                                            bool InDangrousUnSupported = new bool();
                                            //bool NumbersOf = new bool();
                                            //bool NumbersOfDangourous = new bool();
                                         /*   if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count)
                                            {

                                                //IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                                //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                //IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                //IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                            }
                                            if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count)
                                            {
                                                //Mechanisam of Regrad.

                                                IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                                //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, ii, jj);
                                                IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                                InAttackedEnemyNotSupporetd(TableS, Order, color, ii, jj, i, j);
                                                InAttackedُSelfNotSupporetd(TableS, Order, color, ii, jj);
                                                IsDangerous = IsAllTraversalHomeIsDangerous(TableS, ii, jj, i, j, Order, color);
                                                //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                                //AttacakerVar2 = AttackerCount(TableS, Order, color, ii, jj);
                                                //SupporterVar2 = SupporterCount(TableS, Order, color, ii, jj);

                                                CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                                InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                                //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                                //NumbersOfDangourous = NumbersOf;

                                            }
                                            ChessRules AA = new ChessRules(TableS[i, j], TableS, Order, Row, Column);

                                            ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                            if (Current.IsPenaltyAction() != 0 && UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count)
                                            {
                                                ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                if (A.Check(TableS, Order))
                                                {
                                                    if (Order == 1 && (A.CheckGray))
                                                        Current.LearningAlgorithmPenalty();
                                                    else
                                                        if (Order == -1 && (A.CheckBrown))
                                                            Current.LearningAlgorithmPenalty();
                                                    PenaltyRegardListKing.Add(Current);
                                                }
                                                else
                                                {
                                                    if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                    {
                                                        Current.LearningAlgorithmPenalty();
                                                        PenaltyRegardListKing.Add(Current);
                                                    }
                                                    else
                                                        PenaltyRegardListKing.Add(Current);
                                                }
                                            }
                                            else
                                                PenaltyRegardListKing.Add(Current);
                                            if (AA.CheckMate(TableS, Order))
                                            {

                                                if (Order == 1 && AA.CheckMateBrown)
                                                {
                                                    DoEnemySelf = false;
                                                    FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                }
                                                if (Order == -1 && AA.CheckMateGray)
                                                {
                                                    DoEnemySelf = false;
                                                    FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                }
                                                if (Order == 1 && AA.CheckMateGray)
                                                {
                                                    FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                }
                                                if (Order == -1 && AA.CheckMateBrown)
                                                {
                                                    FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                }
                                            }
                                            if (AA.ObjectDangourKingMove(Order, TableS, false))
                                            {

                                                if (Order == 1 && AA.CheckGrayObjectDangour)
                                                {
                                                    DoEnemySelf = false;
                                                    FoundFirstMating = true;
                                                    AchamazCurrent = true;
                                                }
                                                if (Order == -1 && AA.CheckBrownObjectDangour)
                                                {
                                                    DoEnemySelf = false;
                                                    FoundFirstMating = true;
                                                    AchamazCurrent = true;
                                                }
                                            }

                                            ///Row = i;
                                            //Column = j;
                                            SelfSupported = false;
                                            InAttackedNotSelfSupported = false;
                                            if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count //+ 1)
                                            {
                                                //Calculatre Huristic After Movments.
                                                //if (PredictHuristic)
                                                //For Ocuuring in Enemy CheckMate.
                                                if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                                {
                                                    if (Current.IsPenaltyAction() != 0)
                                                    {
                                                        PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                        Current.LearningAlgorithmRegard();
                                                        PenaltyRegardListKing.Add(Current);
                                                        //IgnoreAchmatPenalty = true;
                                                    }
                                                }
                                                //For Preventing of Self CheckMate.
                                                if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                                {
                                                    if (Current.IsPenaltyAction() != 0)
                                                    {
                                                        //DontClearPenalty = true;
                                                        PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                        Current.LearningAlgorithmPenalty();
                                                        PenaltyRegardListKing.Add(Current);
                                                    }
                                                }
                                                if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count)
                                                {
                                                    //For Not Suppored In Attacked.
                                                    if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                                    {
                                                        //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                        {
                                                            if (Current.IsPenaltyAction() != 0)
                                                            {
                                                                //DontClearPenalty = true;
                                                                PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListKing.Add(Current);
                                                            }
                                                        }
                                                    }
                                                }
                                                //For Ocuuring Enemy  Garding Objects.
                                                if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                                {
                                                    //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                    {
                                                        if (Current.IsPenaltyAction() != 0)
                                                        {
                                                            PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                            Current.LearningAlgorithmRegard();
                                                            PenaltyRegardListKing.Add(Current);
                                                            //IgnoreAchmatPenalty = true;
                                                        }
                                                    }
                                                }
                                                if (AchamazCurrent && IgnoreObjectDangour == 1)
                                                {
                                                    PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                    Current.LearningAlgorithmPenalty();
                                                    PenaltyRegardListKing.Add(Current);
                                                }
                                                bool IgnoreRemove = false;
                                                if (AA.CheckGray && Order == 1)
                                                    IgnoreRemove = true;
                                                else
                                                    if (AA.CheckBrown && Order == -1)
                                                        IgnoreRemove = true;

                                                if (Current.IsPenaltyAction() == 0)if(RemovePenalty(TableS, Order, i, j))
                                                {
                                                    Current = new QuantumAtamata(3, 3, 3);
                                                    PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                    PenaltyRegardListKing.Add(Current);
                                                }

                                            }
                                          */ 

                                            //Act Movment.
                                            if (i < ii)
                                            {
                                                TableS[ii - 1, j] = -4;
                                                TableS[ii - 2, j] = -6;
                                                TableS[ii, jj] = 0;
                                                TableS[0, jj] = 0;

                                            }

                                            else
                                            {
                                                TableS[ii + 1, j] = -4;
                                                TableS[ii + 2, j] = -6;
                                                TableS[ii, jj] = 0;
                                                TableS[7, jj] = 0;

                                            }
                                            if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count //+ 1)
                                                )
                                            {
                                                //Mechanisam of Regrad.      
                                                IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, i, j);
                                                //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, i, j);

                                                InAttackedEnemyNotSupporetd(TableS, Order, color, i, j, ii, jj);
                                                InAttackedُSelfNotSupporetd(TableS, Order, color, i, j);
                                                IsDangerous = IsAllTraversalHomeIsDangerous(TableS, i, j, ii, jj, Order, color);
                                                //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, i, j);
                                                //AttacakerVar2 = AttackerCount(TableS, Order, color, i, j);
                                                //SupporterVar2 = SupporterCount(TableS, Order, color, i, j);
                                                CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                                InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                                //NumbersOf = (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) && (!(EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0)) || (!(AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0)) && (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0); //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                                //NumbersOfDangourous = NumbersOf;
                                            }//Consideration of Prevention from going Check State by self order.
                                            ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                            if (!UsePenaltyRegardMechnisam)
                                                if (AA.Check(TableS, Order))
                                                {
                                                    if (Order == 1 && AA.CheckGray)
                                                        continue;
                                                    else
                                                        if (Order == -1 && AA.CheckBrown)
                                                            continue;

                                                }
                                            if (IgnoreObjectDangour == 0)
                                                IgnoreObjectDangour = 1;

                                            ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                            if (Current.IsPenaltyAction() != 0 && UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count //+ 1)
                                                )
                                            {
                                                //PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                if (A.Check(TableS, Order))
                                                {
                                                    if (Order == 1 && (A.CheckGray))
                                                        Current.LearningAlgorithmPenalty();
                                                    else
                                                        if (Order == -1 && (A.CheckBrown))
                                                            Current.LearningAlgorithmPenalty();
                                                    PenaltyRegardListKing.Add(Current);
                                                }
                                                else
                                                {
                                                    if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                    {
                                                        Current.LearningAlgorithmPenalty();
                                                        PenaltyRegardListKing.Add(Current);
                                                    }
                                                    else
                                                        PenaltyRegardListKing.Add(Current);
                                                }
                                            }
                                            if (AA.CheckMate(TableS, Order))
                                            {

                                                if (Order == 1 && AA.CheckMateBrown)
                                                {
                                                    DoEnemySelf = false;
                                                    FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                }
                                                if (Order == -1 && AA.CheckMateGray)
                                                {
                                                    DoEnemySelf = false;
                                                    FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                }
                                                if (Order == 1 && AA.CheckMateGray)
                                                {
                                                    FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                }
                                                if (Order == -1 && AA.CheckMateBrown)
                                                {
                                                    FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                }
                                            }
                                            if (AA.ObjectDangourKingMove(Order, TableS, false))
                                            {

                                                if (Order == 1 && AA.CheckGrayObjectDangour)
                                                {
                                                    DoEnemySelf = false;
                                                    FoundFirstMating = true;
                                                    AchamazCurrent = true;
                                                }
                                                if (Order == -1 && AA.CheckBrownObjectDangour)
                                                {
                                                    DoEnemySelf = false;
                                                    FoundFirstMating = true;
                                                    AchamazCurrent = true;
                                                }
                                            }

                                            //Store Movments Items. 
                                            int[] AS = new int[2];
                                            AS[0] = i;
                                            AS[1] = j;
                                            RowColumnKing.Add(AS);
                                            RowColumn[Index, 0] = i;
                                            RowColumn[Index, 1] = j;
                                            Index++;
                                            TableListKing.Add(CloneATable(TableS)); ;
                                            IndexKing++;
                                            ///Row = i;
                                            //Column = j;
                                            SelfSupported = false;
                                            InAttackedNotSelfSupported = false;
                                            if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count)
                                            {
                                                //Calculatre Huristic After Movments.
                                                //if (PredictHuristic)
                                                {
                                                    HuristicAttack(TableS, Order, color);
                                                    HuristicMovment(TableS, color);
                                                    HuristicSelfSupported(TableS, Order, color);
                                                    HuristicCheckAndCheckMate(TableS, color);
                                                    //HuristicObjectDangour(TableS, Order, color);
                                                    HuristicHitting(TableS, i, j, Order, color, false);
                                                    HuristicReducsedAttack(TableS, Order, color);
                                                    HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, i, j);
                                                }

                                                //For Ocuuring in Enemy CheckMate.
                                                if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                                {
                                                    if (Current.IsPenaltyAction() != 0)
                                                    {
                                                        PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                        Current.LearningAlgorithmRegard();
                                                        PenaltyRegardListKing.Add(Current);
                                                        //IgnoreAchmatPenalty = true;
                                                    }
                                                }
                                                //For Preventing of Self CheckMate.
                                                if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                                {
                                                    if (Current.IsPenaltyAction() != 0)
                                                    {
                                                        //DontClearPenalty = true;
                                                        PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                        Current.LearningAlgorithmPenalty();
                                                        PenaltyRegardListKing.Add(Current);
                                                    }
                                                }
                                                if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count)
                                                {
                                                    //For Not Suppored In Attacked.
                                                    if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                                    {
                                                        //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                        {
                                                            if (Current.IsPenaltyAction() != 0)
                                                            {
                                                                //DontClearPenalty = true;
                                                                PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListKing.Add(Current);
                                                            }
                                                        }
                                                    }
                                                }
                                                //For Ocuuring Enemy  Garding Objects.
                                                if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                                {
                                                    //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                    {
                                                        if (Current.IsPenaltyAction() != 0)
                                                        {
                                                            PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                            Current.LearningAlgorithmRegard();
                                                            PenaltyRegardListKing.Add(Current);
                                                            //IgnoreAchmatPenalty = true;
                                                        }
                                                    }
                                                }
                                                if (AchamazCurrent && IgnoreObjectDangour == 1)
                                                {
                                                    PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                    Current.LearningAlgorithmPenalty();
                                                    PenaltyRegardListKing.Add(Current);
                                                }
                                                bool IgnoreRemove = false;
                                                if (AA.CheckGray && Order == 1)
                                                    IgnoreRemove = true;
                                                else
                                                    if (AA.CheckBrown && Order == -1)
                                                        IgnoreRemove = true;

                                                if (Current.IsPenaltyAction() == 0)if(RemovePenalty(TableS, Order, i, j))
                                                {
                                                    Current = new QuantumAtamata(3, 3, 3);
                                                    PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                    PenaltyRegardListKing.Add(Current);
                                                }

                                            }else
                                                PenaltyRegardListKing.Add(Current);
                                            //Calculate Huristic Sumation and Store in Specific List.
                                            double[] Hu = new double[4];
                                            Hu[0] = HuristicValue;
                                            Hu[1] = HuristicValueMovement;
                                            Hu[2] = HuristicValueSelfSupported;
                                            Hu[3] = HuristicValueObjectDangourCheckMate;
                                            HuristicListKing.Add(Hu);
                                            //ChessRules.BridgeActBrown = true;
                                            Bridge = true;
                                            /*if (FormRefrigtz.ProfesionalWithComputer)
                                            {
                                                if (Order == 1)
                                                    ChessRules.CurrentOrder = -1;
                                                else
                                                    ChessRules.CurrentOrder = 1;

                                                this.AStarGreedy.Clear();
                                                //this.AStarGreedy[0].TableList.Clear();
                                                this.AStarGreedy.Add(new AllDraw(ref THIS));
                                                this.AStarGreedy[0].TableList.Add(CloneATable(TableS)); ;
                                                this.AStarGreedy[0].SetRowColumn(0);
                                                if (Order == 1)
                                                    this.AStarGreedy[0].Initiate(i, j, color, TableS, -1, false, ref THIS.TimerText, ref THIS.BrownTimer);
                                                else
                                                    this.AStarGreedy[0].Initiate(i, j, color, TableS, 1, false, ref THIS.TimerText, ref THIS.GrayTimer);
                                            }
                                             */ 
                                        }

                                    }
                                    else   ///For Soldier Thinking
                                        if (Scop(ii, jj, i, j, 1) && System.Math.Abs(TableS[ii, jj]) == 1 && System.Math.Abs(Kind) == 1)
                                        {
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            ///When There is Movments.
                                            if ((new ChessRules(TableS[ii, jj], TableS, Order, ii, jj)).Rules(ii, jj, i, j, color, TableS[ii, jj]))
                                            {
                                                //int EnemyVarAttacker1 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                                //int AttacakerVar1 = AttackerCount(TableS, Order, color, ii, jj);
                                                //int SupporterVar1 = SupporterCount(TableS, Order, color, ii, jj);
                                                //SodierValue = 1 * (VeryFye(TableS, Order, color) + 1);
                                                ///Calculate Hit Occured and Value of Object.
                                                bool Hit = false;
                                                int HitNumber = TableS[i, j];
                                                if (System.Math.Abs(TableS[i, j]) > 0)
                                                    Hit = true;
                                                ///Add Table to List of Private.
                                                HitNumberSoldier.Add(TableS[i, j]);
                                                ThinkingRun = true;
                                                ///Predict Huristic.
                                                HuristicAttack(TableS, Order, color);
                                                HuristicMovment(TableS, color);
                                                HuristicSelfSupported(TableS, Order, color);
                                                HuristicCheckAndCheckMate(TableS, color);
                                                //HuristicObjectDangour(TableS, Order, color);
                                                HuristicHitting(TableS, ii, jj, Order, color, Hit);
                                                HuristicReducsedAttack(TableS, Order, color);
                                                HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, ii, jj);
                                                bool IsSuitbale = new bool();
                                                bool IsGardNotMovable = new bool();
                                                bool IsNextMovemntIsCheckOrCheckMateForCurrent = new bool();
                                                bool IsDangerous = new bool();
                                                //int EnemyVarAttacker2 = new int();
                                                //int AttacakerVar2 = new int();
                                                //int SupporterVar2 = new int();
                                                bool CanHittingAnUnSupportedEnemy = new bool();
                                                bool InDangrousUnSupported = new bool();
                                                //bool NumbersOf = new bool();
                                                //bool NumbersOfDangourous = new bool();
                                               /* if (UsePenaltyRegardMechnisam && PenaltyRegardListSolder.Count == TableListSolder.Count)
                                                {

                                                    //IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                                    //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                    //IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                    //IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                                }
                                                if (UsePenaltyRegardMechnisam && PenaltyRegardListSolder.Count == TableListSolder.Count)
                                                {
                                                    //Mechanisam of Regrad.  
                                                    IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, i, j);
                                                    //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                    IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                    IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, i, j);

                                                    InAttackedEnemyNotSupporetd(TableS, Order, color, i, j, ii, jj);
                                                    InAttackedُSelfNotSupporetd(TableS, Order, color, i, j);
                                                    IsDangerous = IsAllTraversalHomeIsDangerous(TableS, i, j, ii, jj, Order, color);
                                                    //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, i, j);
                                                    //AttacakerVar2 = AttackerCount(TableS, Order, color, i, j);
                                                    //SupporterVar2 = SupporterCount(TableS, Order, color, i, j);
                                                    CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                                    InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                                    //NumbersOf = (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) && (!(EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0)) || (!(AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0)) && (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0); //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                                    //NumbersOfDangourous = NumbersOf;
                                                }
                                                //SodierValue = 1 * (VeryFye(TableS, Order, color) + 1);
                                                //Consideration of Prevention from going Check State by self order.
                                                ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                if (!UsePenaltyRegardMechnisam)
                                                    if (AA.Check(TableS, Order))
                                                    {
                                                        if (Order == 1 && AA.CheckGray)
                                                            continue;
                                                        else
                                                            if (Order == -1 && AA.CheckBrown)
                                                                continue;
                                                    }

                                                if (IgnoreObjectDangour == 0)
                                                    IgnoreObjectDangour = 1;

                                                if (AA.CheckMate(TableS, Order))
                                                {

                                                    if (Order == 1 && AA.CheckMateBrown)
                                                    {
                                                        DoEnemySelf = false;
                                                        FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                    }
                                                    if (Order == -1 && AA.CheckMateGray)
                                                    {
                                                        DoEnemySelf = false;
                                                        FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                    }
                                                    if (Order == 1 && AA.CheckMateGray)
                                                    {
                                                        FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                    }
                                                    if (Order == -1 && AA.CheckMateBrown)
                                                    {
                                                        FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                    }
                                                }
                                                if (AA.ObjectDangourKingMove(Order, TableS, false))
                                                {

                                                    if (Order == 1 && AA.CheckGrayObjectDangour)
                                                    {
                                                        DoEnemySelf = false;
                                                        FoundFirstMating = true;
                                                        AchamazCurrent = true;
                                                    }
                                                    if (Order == -1 && AA.CheckBrownObjectDangour)
                                                    {
                                                        DoEnemySelf = false;
                                                        FoundFirstMating = true;
                                                        AchamazCurrent = true;
                                                    }

                                                }
                                                ///Consideration of Itterative Movments to ignore.
                                                if (ThinkingChess.ExistTableInList(TableS, TableListSolder, 0))
                                                {
                                                    ///Set Predict Huristic and Movments Backward.
                                                    TableS[ii, jj] = TableS[i, j];
                                                    TableS[i, j] = 0;
                                                    HuristicValue = 0;
                                                    HuristicValueMovement = 0;
                                                    HuristicValueSelfSupported = 0;
                                                    HuristicValueObjectDangourCheckMate = 0;
                                                    HuristicReducsedAttack(TableS, Order, color);

                                                    continue;
                                                }
                                                ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                                if (UsePenaltyRegardMechnisam && PenaltyRegardListSolder.Count == TableListSolder.Count)
                                                {
                                                    ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                    if (A.Check(TableS, Order))
                                                    {
                                                        if (Order == 1 && (A.CheckGray))
                                                            Current.LearningAlgorithmPenalty();
                                                        else
                                                            if (Order == -1 && (A.CheckBrown))
                                                                Current.LearningAlgorithmPenalty();
                                                        PenaltyRegardListSolder.Add(Current);
                                                    }
                                                    else
                                                    {
                                                        if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                        {
                                                            Current.LearningAlgorithmPenalty();
                                                            PenaltyRegardListSolder.Add(Current);
                                                        }
                                                        else
                                                            PenaltyRegardListSolder.Add(Current);
                                                    }

                                                }
                                                else
                                                    PenaltyRegardListSolder.Add(Current);
                                                ///Store of Indexes Changes and Table in specific List.
                                                //Row = i;
                                                //Column = j;
                                                SelfSupported = false;
                                                InAttackedNotSelfSupported = false;
                                                ///Wehn Predict of Operation Do operate a Predict of this movments.
                                                //if (PredictHuristic)

                                                if (UsePenaltyRegardMechnisam && PenaltyRegardListSolder.Count == TableListSolder.Count //+ 1)
                                                {
                                                    //For Not Suppored In Attacked.
                                                    if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                                    {
                                                        //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                        {
                                                            if (Current.IsPenaltyAction() != 0)
                                                            {
                                                                //DontClearPenalty = true;
                                                                PenaltyRegardListSolder.RemoveAt(PenaltyRegardListSolder.Count - 1);
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListSolder.Add(Current);
                                                            }
                                                        }
                                                    }
                                                    //For Preventing of Self CheckMate.
                                                    if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                                    {
                                                        if (Current.IsPenaltyAction() != 0)
                                                        {
                                                            //DontClearPenalty = true;
                                                            PenaltyRegardListSolder.RemoveAt(PenaltyRegardListSolder.Count - 1);
                                                            Current.LearningAlgorithmPenalty();
                                                            PenaltyRegardListSolder.Add(Current);
                                                        }
                                                    }
                                                    //For Ocuuring in Enemy CheckMate.
                                                    if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                                    {
                                                        if (Current.IsPenaltyAction() != 0)
                                                        {
                                                            PenaltyRegardListSolder.RemoveAt(PenaltyRegardListSolder.Count - 1);
                                                            Current.LearningAlgorithmRegard();
                                                            PenaltyRegardListSolder.Add(Current);
                                                            //IgnoreAchmatPenalty = true;
                                                        }
                                                    }
                                                    //For Ocuuring Enemy Garding Objects.
                                                    if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                                    {
                                                        //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                        {
                                                            if (Current.IsPenaltyAction() != 0)
                                                            {
                                                                PenaltyRegardListSolder.RemoveAt(PenaltyRegardListSolder.Count - 1);
                                                                Current.LearningAlgorithmRegard();
                                                                PenaltyRegardListSolder.Add(Current);
                                                                //IgnoreAchmatPenalty = true;
                                                            }
                                                        }
                                                    }
                                                    if (AchamazCurrent && IgnoreObjectDangour == 1)
                                                    {
                                                        PenaltyRegardListSolder.RemoveAt(PenaltyRegardListSolder.Count - 1);
                                                        Current.LearningAlgorithmPenalty();
                                                        PenaltyRegardListSolder.Add(Current);
                                                    }
                                                    bool IgnoreRemove = false;
                                                    if (AA.CheckGray && Order == 1)
                                                        IgnoreRemove = true;
                                                    else
                                                        if (AA.CheckBrown && Order == -1)
                                                            IgnoreRemove = true;

                                                    if (Current.IsPenaltyAction() == 0)if(RemovePenalty(TableS, Order, i, j))
                                                    {
                                                        Current = new QuantumAtamata(3, 3, 3);
                                                        PenaltyRegardListSolder.RemoveAt(PenaltyRegardListSolder.Count - 1);
                                                        PenaltyRegardListSolder.Add(Current);
                                                    }

                                                }
                                                */ 

                                                ///Action of Movements.
                                                TableS[i, j] = TableS[ii, jj];
                                                TableS[ii, jj] = 0;
                                                if (UsePenaltyRegardMechnisam && PenaltyRegardListSolder.Count == TableListSolder.Count //+ 1)
                                                    )
                                                {
                                                    //Mechanisam of Regrad.  
                                                    IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, i, j);
                                                    //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                    IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                    IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, i, j);

                                                    InAttackedEnemyNotSupporetd(TableS, Order, color, i, j, ii, jj);
                                                    InAttackedُSelfNotSupporetd(TableS, Order, color, i, j);
                                                    IsDangerous = IsAllTraversalHomeIsDangerous(TableS, i, j, ii, jj, Order, color);
                                                    //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, i, j);
                                                    //AttacakerVar2 = AttackerCount(TableS, Order, color, i, j);
                                                    //SupporterVar2 = SupporterCount(TableS, Order, color, i, j);
                                                    CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                                    InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                                    //NumbersOf = (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) && (!(EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0)) || (!(AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0)) && (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0); //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                                    //NumbersOfDangourous = NumbersOf;
                                                }
                                                //SodierValue = 1 * (VeryFye(TableS, Order, color) + 1);
                                                //Consideration of Prevention from going Check State by self order.
                                                ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                if (!UsePenaltyRegardMechnisam)
                                                    if (AA.Check(TableS, Order))
                                                    {
                                                        if (Order == 1 && AA.CheckGray)
                                                            continue;
                                                        else
                                                            if (Order == -1 && AA.CheckBrown)
                                                                continue;
                                                    }

                                                if (IgnoreObjectDangour == 0)
                                                    IgnoreObjectDangour = 1;

                                                if (AA.CheckMate(TableS, Order))
                                                {

                                                    if (Order == 1 && AA.CheckMateBrown)
                                                    {
                                                        DoEnemySelf = false;
                                                        FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                    }
                                                    if (Order == -1 && AA.CheckMateGray)
                                                    {
                                                        DoEnemySelf = false;
                                                        FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                    }
                                                    if (Order == 1 && AA.CheckMateGray)
                                                    {
                                                        FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                    }
                                                    if (Order == -1 && AA.CheckMateBrown)
                                                    {
                                                        FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                    }
                                                }
                                                if (AA.ObjectDangourKingMove(Order, TableS, false))
                                                {

                                                    if (Order == 1 && AA.CheckGrayObjectDangour)
                                                    {
                                                        DoEnemySelf = false;
                                                        FoundFirstMating = true;
                                                        AchamazCurrent = true;
                                                    }
                                                    if (Order == -1 && AA.CheckBrownObjectDangour)
                                                    {
                                                        DoEnemySelf = false;
                                                        FoundFirstMating = true;
                                                        AchamazCurrent = true;
                                                    }

                                                }
                                                ///Consideration of Itterative Movments to ignore.
                                                if (ThinkingChess.ExistTableInList(TableS, TableListSolder, 0))
                                                {
                                                    ///Set Predict Huristic and Movments Backward.
                                                    TableS[ii, jj] = TableS[i, j];
                                                    TableS[i, j] = 0;
                                                    HuristicValue = 0;
                                                    HuristicValueMovement = 0;
                                                    HuristicValueSelfSupported = 0;
                                                    HuristicValueObjectDangourCheckMate = 0;
                                                    HuristicReducsedAttack(TableS, Order, color);

                                                    continue;
                                                }
                                                ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                                if (Current.IsPenaltyAction() != 0 && UsePenaltyRegardMechnisam && PenaltyRegardListSolder.Count == TableListSolder.Count //+ 1)
                                                    )
                                                {
                                                    //PenaltyRegardListSolder.RemoveAt(PenaltyRegardListSolder.Count - 1);
                                                    ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                    if (A.Check(TableS, Order))
                                                    {
                                                        if (Order == 1 && (A.CheckGray))
                                                            Current.LearningAlgorithmPenalty();
                                                        else
                                                            if (Order == -1 && (A.CheckBrown))
                                                                Current.LearningAlgorithmPenalty();
                                                        PenaltyRegardListSolder.Add(Current);
                                                    }
                                                    else
                                                    {
                                                        if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                        {
                                                            Current.LearningAlgorithmPenalty();
                                                            PenaltyRegardListSolder.Add(Current);
                                                        }
                                                        else
                                                            PenaltyRegardListSolder.Add(Current);
                                                    }

                                                }
                                                ///Store of Indexes Changes and Table in specific List.
                                                int[] AS = new int[2];
                                                AS[0] = i;
                                                AS[1] = j;
                                                RowColumnSoldier.Add(AS);
                                                RowColumn[Index, 0] = i;
                                                RowColumn[Index, 1] = j;
                                                Index++;
                                                TableListSolder.Add(CloneATable(TableS)); ;
                                                IndexSoldier++;
                                                //Row = i;
                                                //Column = j;
                                                SelfSupported = false;
                                                InAttackedNotSelfSupported = false;
                                                ///Wehn Predict of Operation Do operate a Predict of this movments.
                                                //if (PredictHuristic)
                                                {
                                                    HuristicAttack(TableS, Order, color);
                                                    HuristicMovment(TableS, color);
                                                    HuristicSelfSupported(TableS, Order, color);
                                                    HuristicCheckAndCheckMate(TableS, color);
                                                    //HuristicObjectDangour(TableS, Order, color);
                                                    HuristicHitting(TableS, i, j, Order, color, Hit);
                                                    HuristicReducsedAttack(TableS, Order, color);
                                                    HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, i, j);
                                                }

                                                if (UsePenaltyRegardMechnisam && PenaltyRegardListSolder.Count == TableListSolder.Count)
                                                {
                                                    //For Not Suppored In Attacked.
                                                    if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                                    {
                                                        //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                        {
                                                            if (Current.IsPenaltyAction() != 0)
                                                            {
                                                                //DontClearPenalty = true;
                                                                PenaltyRegardListSolder.RemoveAt(PenaltyRegardListSolder.Count - 1);
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListSolder.Add(Current);
                                                            }
                                                        }
                                                    }
                                                    //For Preventing of Self CheckMate.
                                                    if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                                    {
                                                        if (Current.IsPenaltyAction() != 0)
                                                        {
                                                            //DontClearPenalty = true;
                                                            PenaltyRegardListSolder.RemoveAt(PenaltyRegardListSolder.Count - 1);
                                                            Current.LearningAlgorithmPenalty();
                                                            PenaltyRegardListSolder.Add(Current);
                                                        }
                                                    }
                                                    //For Ocuuring in Enemy CheckMate.
                                                    if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                                    {
                                                        if (Current.IsPenaltyAction() != 0)
                                                        {
                                                            PenaltyRegardListSolder.RemoveAt(PenaltyRegardListSolder.Count - 1);
                                                            Current.LearningAlgorithmRegard();
                                                            PenaltyRegardListSolder.Add(Current);
                                                            //IgnoreAchmatPenalty = true;
                                                        }
                                                    }
                                                    //For Ocuuring Enemy Garding Objects.
                                                    if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                                    {
                                                        //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                        {
                                                            if (Current.IsPenaltyAction() != 0)
                                                            {
                                                                PenaltyRegardListSolder.RemoveAt(PenaltyRegardListSolder.Count - 1);
                                                                Current.LearningAlgorithmRegard();
                                                                PenaltyRegardListSolder.Add(Current);
                                                                //IgnoreAchmatPenalty = true;
                                                            }
                                                        }
                                                    }
                                                    if (AchamazCurrent && IgnoreObjectDangour == 1)
                                                    {
                                                        PenaltyRegardListSolder.RemoveAt(PenaltyRegardListSolder.Count - 1);
                                                        Current.LearningAlgorithmPenalty();
                                                        PenaltyRegardListSolder.Add(Current);
                                                    }
                                                    bool IgnoreRemove = false;
                                                    if (AA.CheckGray && Order == 1)
                                                        IgnoreRemove = true;
                                                    else
                                                        if (AA.CheckBrown && Order == -1)
                                                            IgnoreRemove = true;

                                                    if (Current.IsPenaltyAction() == 0) if (RemovePenalty(TableS, Order, i, j))
                                                        {
                                                            Current = new QuantumAtamata(3, 3, 3);
                                                            PenaltyRegardListSolder.RemoveAt(PenaltyRegardListSolder.Count - 1);
                                                            PenaltyRegardListSolder.Add(Current);
                                                        }

                                                }
                                                else
                                                    PenaltyRegardListSolder.Add(Current);
                                                ///Calculate Huristic and Add to List Speciifically and Cal Syntax.
                                                double[] Hu = new double[4];
                                                Hu[0] = HuristicValue;
                                                Hu[1] = HuristicValueMovement;
                                                Hu[2] = HuristicValueSelfSupported;
                                                Hu[3] = HuristicValueObjectDangourCheckMate;
                                                HuristicListSolder.Add(Hu);
                                                /* if (Order == 1)
                                                     AllDraw.SyntaxToWrite = (new ChessRules()).CreateStatistic(TableS, FormRefrigtz.MovmentsNumber, 1, j, i, Hit, HitNumber, ChessRules.BridgeActBrown, false);
                                                 else
                                                     AllDraw.SyntaxToWrite = (new ChessRules()).CreateStatistic(TableS, FormRefrigtz.MovmentsNumber, -1, j, i, Hit, HitNumber, ChessRules.BridgeActBrown, false);
                                                 AllDraw.SyntaxToWrite += "Huristic :" + (Hu[0] + Hu[1] + Hu[2] + Hu[3]).ToString();
                                                 */
                                                /*if (FormRefrigtz.ProfesionalWithComputer)
                                                {
                                                    if (Order == 1)
                                                        ChessRules.CurrentOrder = -1;
                                                    else
                                                        ChessRules.CurrentOrder = 1;

                                                    this.AStarGreedy.Clear();
                                                    //this.AStarGreedy[0].TableList.Clear();
                                                    this.AStarGreedy.Add(new AllDraw(ref THIS));
                                                    this.AStarGreedy[0].TableList.Add(CloneATable(TableS)); ;
                                                    this.AStarGreedy[0].SetRowColumn(0);
                                                    if (Order == 1)
                                                        this.AStarGreedy[0].Initiate(i, j, color, TableS, -1, false, ref THIS.TimerText, ref THIS.BrownTimer);
                                                    else
                                                        this.AStarGreedy[0].Initiate(i, j, color, TableS, 1, false, ref THIS.TimerText, ref THIS.GrayTimer);
                                                }
                                                 */ 
                                            }
                                        }
                                        else
                                            ///Else for Elephant Thinking.
                                            if (Scop(ii, jj, i, j, 2) && System.Math.Abs(TableS[ii, jj]) == 2 && System.Math.Abs(Kind) == 2)
                                            {

                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                ///When There is Movments.
                                                if ((new ChessRules(TableS[ii, jj], TableS, Order, ii, jj)).Rules(ii, jj, i, j, color, TableS[ii, jj]))
                                                {
                                                    //int EnemyVarAttacker1 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                                    //int AttacakerVar1 = AttackerCount(TableS, Order, color, ii, jj);
                                                    //int SupporterVar1 = SupporterCount(TableS, Order, color, ii, jj);
                                                    //ElefantValue = 3 * (VeryFye(TableS, Order, color) + 1);
                                                    ///Calculate Hit Occured and Value of Object.
                                                    bool Hit = false;
                                                    int HitNumber = TableS[i, j];
                                                    if (System.Math.Abs(TableS[i, j]) > 0)
                                                        Hit = true;
                                                    ///Add Table to List of Private.
                                                    HitNumberElefant.Add(TableS[i, j]);
                                                    ThinkingRun = true;
                                                    ///Predict Huristic.
                                                    HuristicAttack(TableS, Order, color);
                                                    HuristicMovment(TableS, color);
                                                    HuristicSelfSupported(TableS, Order, color);
                                                    HuristicCheckAndCheckMate(TableS, color);
                                                    //HuristicObjectDangour(TableS, Order, color);
                                                    HuristicHitting(TableS, ii, jj, Order, color, Hit);
                                                    HuristicReducsedAttack(TableS, Order, color);
                                                    HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, ii, jj);
                                                    bool IsSuitbale = new bool();
                                                    bool IsGardNotMovable = new bool();
                                                    bool IsNextMovemntIsCheckOrCheckMateForCurrent = new bool();
                                                    bool IsDangerous = new bool();
                                                    //int EnemyVarAttacker2 = new int();
                                                    //int AttacakerVar2 = new int();
                                                    //int SupporterVar2 = new int();
                                                    bool CanHittingAnUnSupportedEnemy = new bool();
                                                    bool InDangrousUnSupported = new bool();
                                                    //bool NumbersOf = new bool();
                                                    //bool NumbersOfDangourous = new bool();
                                                    ///Action of Movements.
                                                    /*if (UsePenaltyRegardMechnisam && PenaltyRegardListElefant.Count == TableListElefant.Count)
                                                    {

                                                        //IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                                        //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                        //IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                        //IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                                    }
                                                    if (UsePenaltyRegardMechnisam && PenaltyRegardListElefant.Count == TableListElefant.Count)
                                                    {
                                                        //Mechanisam of Regrad.

                                                        IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                                        //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                        IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, ii, jj);
                                                        IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                                        InAttackedEnemyNotSupporetd(TableS, Order, color, ii, jj, i, j);
                                                        InAttackedُSelfNotSupporetd(TableS, Order, color, ii, jj);
                                                        IsDangerous = IsAllTraversalHomeIsDangerous(TableS, ii, jj, i, j, Order, color);
                                                        //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                                        //AttacakerVar2 = AttackerCount(TableS, Order, color, ii, jj);
                                                        //SupporterVar2 = SupporterCount(TableS, Order, color, ii, jj);

                                                        CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                                        InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                                        //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                                        //NumbersOfDangourous = NumbersOf;

                                                    }
                                                    //ElefantValue = 3 * (VeryFye(TableS, Order, color) + 1);
                                                    //Consideration of Prevention from going Check State by self order.
                                                    ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                    if (!UsePenaltyRegardMechnisam)
                                                        if (AA.Check(TableS, Order))
                                                        {
                                                            if (Order == 1 && AA.CheckGray)
                                                                continue;
                                                            else
                                                                if (Order == -1 && AA.CheckBrown)
                                                                    continue;
                                                        }
                                                    if (IgnoreObjectDangour == 0)
                                                        IgnoreObjectDangour = 1;

                                                    if (AA.CheckMate(TableS, Order))
                                                    {

                                                        if (Order == 1 && AA.CheckMateBrown)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                        }
                                                        if (Order == -1 && AA.CheckMateGray)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                        }
                                                        if (Order == 1 && AA.CheckMateGray)
                                                        {
                                                            FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                        }
                                                        if (Order == -1 && AA.CheckMateBrown)
                                                        {
                                                            FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                        }
                                                    }
                                                    if (AA.ObjectDangourKingMove(Order, TableS, false))
                                                    {

                                                        if (Order == 1 && AA.CheckGrayObjectDangour)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true;
                                                            AchamazCurrent = true;
                                                        }
                                                        if (Order == -1 && AA.CheckBrownObjectDangour)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true;
                                                            AchamazCurrent = true;
                                                        }
                                                    }
                                                    ///Consideration of Itterative Movments to ignore.
                                                    if (ThinkingChess.ExistTableInList(TableS, TableListElefant, 0))
                                                    {
                                                        ///Set Predict Huris0tic and Movments Backward.0
                                                        TableS[ii, jj] = TableS[i, j];
                                                        TableS[i, j] = 0;
                                                        HuristicValue = 0;
                                                        HuristicValueMovement = 0;
                                                        HuristicValueSelfSupported = 0;
                                                        HuristicValueObjectDangourCheckMate = 0;

                                                        continue;
                                                    }
                                                    ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                                    if (UsePenaltyRegardMechnisam && PenaltyRegardListElefant.Count == TableListElefant.Count)
                                                    {

                                                        ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                        if (A.Check(TableS, Order))
                                                        {
                                                            if (Order == 1 && (A.CheckGray))
                                                                Current.LearningAlgorithmPenalty();
                                                            else
                                                                if (Order == -1 && (A.CheckBrown))
                                                                    Current.LearningAlgorithmPenalty();
                                                            PenaltyRegardListElefant.Add(Current);
                                                        }
                                                        else
                                                        {
                                                            if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                            {
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListElefant.Add(Current);
                                                            }
                                                            else
                                                                PenaltyRegardListElefant.Add(Current);
                                                        }
                                                    }
                                                    else
                                                        PenaltyRegardListElefant.Add(Current);
                                                    ///Store of Indexes Changes and Table in specific List.
                                                    //Row = i;
                                                    //Column = j;
                                                    SelfSupported = false;
                                                    InAttackedNotSelfSupported = false;
                                                    ///Wehn Predict of Operation Do operate a Predict of this movments.
                                                    //if (PredictHuristic)

                                                    if (UsePenaltyRegardMechnisam && PenaltyRegardListElefant.Count == TableListElefant.Count //+ 1)
                                                    {
                                                        //For Not Suppored In Attacked.
                                                        if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                                        {
                                                            //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    //DontClearPenalty = true;
                                                                    PenaltyRegardListElefant.RemoveAt(PenaltyRegardListElefant.Count - 1);
                                                                    Current.LearningAlgorithmPenalty();
                                                                    PenaltyRegardListElefant.Add(Current);
                                                                }
                                                            }
                                                        }
                                                        //For Ocuuring Enemy Garding Objects.
                                                        if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                                        {
                                                            //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {

                                                                    PenaltyRegardListElefant.RemoveAt(PenaltyRegardListElefant.Count - 1);
                                                                    Current.LearningAlgorithmRegard();
                                                                    PenaltyRegardListElefant.Add(Current);
                                                                    //IgnoreAchmatPenalty = true;
                                                                }
                                                            }
                                                        }
                                                        //For Preventing of Self CheckMate.
                                                        if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                                        {
                                                            if (Current.IsPenaltyAction() != 0)
                                                            {
                                                                ///DontClearPenalty = true;
                                                                PenaltyRegardListElefant.RemoveAt(PenaltyRegardListElefant.Count - 1);
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListElefant.Add(Current);
                                                            }
                                                        }
                                                        //For Ocuuring in Enemy CheckMate.
                                                        if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                                        {
                                                            if (Current.IsPenaltyAction() != 0)
                                                            {
                                                                PenaltyRegardListElefant.RemoveAt(PenaltyRegardListElefant.Count - 1);
                                                                Current.LearningAlgorithmRegard();
                                                                PenaltyRegardListElefant.Add(Current);
                                                                //IgnoreAchmatPenalty = true;
                                                            }
                                                        }
                                                        if (AchamazCurrent && IgnoreObjectDangour == 1)
                                                        {
                                                            PenaltyRegardListElefant.RemoveAt(PenaltyRegardListElefant.Count - 1);
                                                            Current.LearningAlgorithmPenalty();
                                                            PenaltyRegardListElefant.Add(Current);
                                                        }
                                                        bool IgnoreRemove = false;
                                                        if (AA.CheckGray && Order == 1)
                                                            IgnoreRemove = true;
                                                        else
                                                            if (AA.CheckBrown && Order == -1)
                                                                IgnoreRemove = true;

                                                        if (Current.IsPenaltyAction() == 0)if(RemovePenalty(TableS, Order, i, j))
                                                        {
                                                            Current = new QuantumAtamata(3, 3, 3);
                                                            PenaltyRegardListElefant.RemoveAt(PenaltyRegardListElefant.Count - 1);
                                                            PenaltyRegardListElefant.Add(Current);
                                                        }

                                                        ///Calculate Huristic and Add to List Speciifically and Cal Syntax.
                                                    }
                                                     */ 
                                                    TableS[i, j] = TableS[ii, jj];
                                                    TableS[ii, jj] = 0;
                                                    if (UsePenaltyRegardMechnisam && PenaltyRegardListElefant.Count == TableListElefant.Count //+ 1)
                                                        )
                                                    {
                                                        //Mechanisam of Regrad. 
                                                        IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, i, j);
                                                        //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                        IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                        IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, i, j);

                                                        InAttackedEnemyNotSupporetd(TableS, Order, color, i, j, ii, jj);
                                                        InAttackedُSelfNotSupporetd(TableS, Order, color, i, j);
                                                        IsDangerous = IsAllTraversalHomeIsDangerous(TableS, i, j, ii, jj, Order, color);
                                                        //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, i, j);
                                                        //AttacakerVar2 = AttackerCount(TableS, Order, color, i, j);
                                                        //SupporterVar2 = SupporterCount(TableS, Order, color, i, j);
                                                        CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                                        InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                                        //NumbersOf = (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) && (!(EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0)) || (!(AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0)) && (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0); //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                                        //NumbersOfDangourous = NumbersOf;
                                                    }
                                                    //ElefantValue = 3 * (VeryFye(TableS, Order, color) + 1);
                                                    //Consideration of Prevention from going Check State by self order.
                                                   ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                    if (!UsePenaltyRegardMechnisam)
                                                        if (AA.Check(TableS, Order))
                                                        {
                                                            if (Order == 1 && AA.CheckGray)
                                                                continue;
                                                            else
                                                                if (Order == -1 && AA.CheckBrown)
                                                                    continue;
                                                        }
                                                    if (IgnoreObjectDangour == 0)
                                                        IgnoreObjectDangour = 1;

                                                    if (AA.CheckMate(TableS, Order))
                                                    {

                                                        if (Order == 1 && AA.CheckMateBrown)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                        }
                                                        if (Order == -1 && AA.CheckMateGray)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                        }
                                                        if (Order == 1 && AA.CheckMateGray)
                                                        {
                                                            FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                        }
                                                        if (Order == -1 && AA.CheckMateBrown)
                                                        {
                                                            FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                        }
                                                    }
                                                    if (AA.ObjectDangourKingMove(Order, TableS, false))
                                                    {

                                                        if (Order == 1 && AA.CheckGrayObjectDangour)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true;
                                                            AchamazCurrent = true;
                                                        }
                                                        if (Order == -1 && AA.CheckBrownObjectDangour)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true;
                                                            AchamazCurrent = true;
                                                        }
                                                    }
                                                    ///Consideration of Itterative Movments to ignore.
                                                    if (ThinkingChess.ExistTableInList(TableS, TableListElefant, 0))
                                                    {
                                                        ///Set Predict Huris0tic and Movments Backward.0
                                                        TableS[ii, jj] = TableS[i, j];
                                                        TableS[i, j] = 0;
                                                        HuristicValue = 0;
                                                        HuristicValueMovement = 0;
                                                        HuristicValueSelfSupported = 0;
                                                        HuristicValueObjectDangourCheckMate = 0;

                                                        continue;
                                                    }
                                                    ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                                    if (Current.IsPenaltyAction() != 0 && UsePenaltyRegardMechnisam && PenaltyRegardListElefant.Count == TableListElefant.Count //+ 1)
                                                        )
                                                    {
                                                       // PenaltyRegardListElefant.RemoveAt(PenaltyRegardListElefant.Count - 1);
                                                        ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                        if (A.Check(TableS, Order))
                                                        {
                                                            if (Order == 1 && (A.CheckGray))
                                                                Current.LearningAlgorithmPenalty();
                                                            else
                                                                if (Order == -1 && (A.CheckBrown))
                                                                    Current.LearningAlgorithmPenalty();
                                                            PenaltyRegardListElefant.Add(Current);
                                                        }
                                                        else
                                                        {
                                                            if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                            {
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListElefant.Add(Current);
                                                            }
                                                            else
                                                                PenaltyRegardListElefant.Add(Current);
                                                        }
                                                    }
                                                    ///Store of Indexes Changes and Table in specific List.
                                                    int[] AS = new int[2];
                                                    AS[0] = i;
                                                    AS[1] = j;
                                                    RowColumnElefant.Add(AS);

                                                    RowColumn[Index, 0] = i;
                                                    RowColumn[Index, 1] = j;
                                                    Index++;
                                                    TableListElefant.Add(CloneATable(TableS)); ;
                                                    IndexElefant++;
                                                    //Row = i;
                                                    //Column = j;
                                                    SelfSupported = false;
                                                    InAttackedNotSelfSupported = false;
                                                    ///Wehn Predict of Operation Do operate a Predict of this movments.
                                                    //if (PredictHuristic)
                                                    {
                                                        HuristicAttack(TableS, Order, color);
                                                        HuristicMovment(TableS, color);
                                                        HuristicSelfSupported(TableS, Order, color);
                                                        HuristicCheckAndCheckMate(TableS, color);
                                                        //HuristicObjectDangour(TableS, Order, color);
                                                        HuristicHitting(TableS, i, j, Order, color, Hit);
                                                        HuristicReducsedAttack(TableS, Order, color);
                                                        HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, i, j);
                                                    }

                                                    if (UsePenaltyRegardMechnisam && PenaltyRegardListElefant.Count == TableListElefant.Count)
                                                    {
                                                        //For Not Suppored In Attacked.
                                                        if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                                        {
                                                            //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    //DontClearPenalty = true;
                                                                    PenaltyRegardListElefant.RemoveAt(PenaltyRegardListElefant.Count - 1);
                                                                    Current.LearningAlgorithmPenalty();
                                                                    PenaltyRegardListElefant.Add(Current);
                                                                }
                                                            }
                                                        }
                                                        //For Ocuuring Enemy Garding Objects.
                                                        if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                                        {
                                                            //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {

                                                                    PenaltyRegardListElefant.RemoveAt(PenaltyRegardListElefant.Count - 1);
                                                                    Current.LearningAlgorithmRegard();
                                                                    PenaltyRegardListElefant.Add(Current);
                                                                    //IgnoreAchmatPenalty = true;
                                                                }
                                                            }
                                                        }
                                                        //For Preventing of Self CheckMate.
                                                        if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                                        {
                                                            if (Current.IsPenaltyAction() != 0)
                                                            {
                                                                ///DontClearPenalty = true;
                                                                PenaltyRegardListElefant.RemoveAt(PenaltyRegardListElefant.Count - 1);
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListElefant.Add(Current);
                                                            }
                                                        }
                                                        //For Ocuuring in Enemy CheckMate.
                                                        if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                                        {
                                                            if (Current.IsPenaltyAction() != 0)
                                                            {
                                                                PenaltyRegardListElefant.RemoveAt(PenaltyRegardListElefant.Count - 1);
                                                                Current.LearningAlgorithmRegard();
                                                                PenaltyRegardListElefant.Add(Current);
                                                                //IgnoreAchmatPenalty = true;
                                                            }
                                                        }
                                                        if (AchamazCurrent && IgnoreObjectDangour == 1)
                                                        {
                                                            PenaltyRegardListElefant.RemoveAt(PenaltyRegardListElefant.Count - 1);
                                                            Current.LearningAlgorithmPenalty();
                                                            PenaltyRegardListElefant.Add(Current);
                                                        }
                                                        bool IgnoreRemove = false;
                                                        if (AA.CheckGray && Order == 1)
                                                            IgnoreRemove = true;
                                                        else
                                                            if (AA.CheckBrown && Order == -1)
                                                                IgnoreRemove = true;

                                                        if (Current.IsPenaltyAction() == 0) if (RemovePenalty(TableS, Order, i, j))
                                                            {
                                                                Current = new QuantumAtamata(3, 3, 3);
                                                                PenaltyRegardListElefant.RemoveAt(PenaltyRegardListElefant.Count - 1);
                                                                PenaltyRegardListElefant.Add(Current);
                                                            }

                                                        ///Calculate Huristic and Add to List Speciifically and Cal Syntax.
                                                    }
                                                    else
                                                        PenaltyRegardListElefant.Add(Current);
                                                    double[] Hu = new double[4];
                                                    Hu[0] = HuristicValue;
                                                    Hu[1] = HuristicValueMovement;
                                                    Hu[2] = HuristicValueSelfSupported;
                                                    Hu[3] = HuristicValueObjectDangourCheckMate;
                                                    HuristicListElefant.Add(Hu);
                                                    /*if (Order == 1)
                                                        AllDraw.SyntaxToWrite = (new ChessRules()).CreateStatistic(TableS, FormRefrigtz.MovmentsNumber, 2, j, i, Hit, HitNumber, ChessRules.BridgeActBrown, false);
                                                    else
                                                        AllDraw.SyntaxToWrite = (new ChessRules()).CreateStatistic(TableS, FormRefrigtz.MovmentsNumber, -2, j, i, Hit, HitNumber, ChessRules.BridgeActBrown, false);
                                                    AllDraw.SyntaxToWrite += "Huristic :" + (Hu[0] + Hu[1] + Hu[2] + Hu[3]).ToString();
                                                     */
                                                    /*if (FormRefrigtz.ProfesionalWithComputer)
                                                    {
                                                        if (Order == 1)
                                                            ChessRules.CurrentOrder = -1;
                                                        else
                                                            ChessRules.CurrentOrder = 1;
                                                        this.AStarGreedy.Clear();
                                                        //this.AStarGreedy[0].TableList.Clear();
                                                        this.AStarGreedy.Add(new AllDraw(ref THIS));
                                                        this.AStarGreedy[0].TableList.Add(CloneATable(TableS)); ;
                                                        this.AStarGreedy[0].SetRowColumn(0);
                                                        if (Order == 1)
                                                            this.AStarGreedy[0].Initiate(i, j, color, TableS, -1, false, ref THIS.TimerText, ref THIS.BrownTimer);
                                                        else
                                                            this.AStarGreedy[0].Initiate(i, j, color, TableS, 1, false, ref THIS.TimerText, ref THIS.GrayTimer);
                                                    }
                                                     */ 
                                                }
                                            }
                                            ///Else for Hourse Thinking.
                                            else if (Scop(ii, jj, i, j, 3) && System.Math.Abs(TableS[ii, jj]) == 3 && System.Math.Abs(Kind) == 3)
                                            {
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                ///When There is Movments.
                                                if ((new ChessRules(TableS[ii, jj], TableS, Order, ii, jj)).Rules(ii, jj, i, j, color, TableS[ii, jj]))
                                                {
                                                    //int EnemyVarAttacker1 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                                    //int AttacakerVar1 = AttackerCount(TableS, Order, color, ii, jj);
                                                    //int SupporterVar1 = SupporterCount(TableS, Order, color, ii, jj);
                                                    //HourseValue = 3 * (VeryFye(TableS, Order, color) + 1);
                                                    ///Calculate Hit Occured and Value of Object.
                                                    bool Hit = false;
                                                    int HitNumber = TableS[i, j];
                                                    if (System.Math.Abs(TableS[i, j]) > 0)
                                                        Hit = true;
                                                    ///Add Table to List of Private.
                                                    HitNumberHourse.Add(TableS[i, j]);
                                                    ThinkingRun = true;
                                                    ///Predict Huristic.
                                                    HuristicAttack(TableS, Order, color);
                                                    HuristicMovment(TableS, color);
                                                    HuristicSelfSupported(TableS, Order, color);
                                                    HuristicCheckAndCheckMate(TableS, color);
                                                    //HuristicObjectDangour(TableS, Order, color);
                                                    HuristicHitting(TableS, ii, jj, Order, color, Hit);
                                                    HuristicReducsedAttack(TableS, Order, color);
                                                    HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, ii, jj);
                                                    bool IsSuitbale = new bool();
                                                    bool IsGardNotMovable = new bool();
                                                    bool IsNextMovemntIsCheckOrCheckMateForCurrent = new bool();
                                                    bool IsDangerous = new bool();
                                                    //int EnemyVarAttacker2 = new int();
                                                    //int AttacakerVar2 = new int();
                                                    //int SupporterVar2 = new int();
                                                    bool CanHittingAnUnSupportedEnemy = new bool();
                                                    bool InDangrousUnSupported = new bool();
                                                    //bool NumbersOf = new bool();
                                                    //bool NumbersOfDangourous = new bool();
                                                    ///Action of Movements.
                                                    /*if (UsePenaltyRegardMechnisam && PenaltyRegardListHourse.Count == TableListHourse.Count)
                                                    {

                                                        //IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                                        //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                        //IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                        //IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                                    }
                                                    if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count)
                                                    {
                                                        //Mechanisam of Regrad.

                                                        IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                                        //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                        IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, ii, jj);
                                                        IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                                        InAttackedEnemyNotSupporetd(TableS, Order, color, ii, jj, i, j);
                                                        InAttackedُSelfNotSupporetd(TableS, Order, color, ii, jj);
                                                        IsDangerous = IsAllTraversalHomeIsDangerous(TableS, ii, jj, i, j, Order, color);
                                                        //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                                        //AttacakerVar2 = AttackerCount(TableS, Order, color, ii, jj);
                                                        //SupporterVar2 = SupporterCount(TableS, Order, color, ii, jj);

                                                        CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                                        InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                                        //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                                        //NumbersOfDangourous = NumbersOf;

                                                    }    //HourseValue = 3 * (VeryFye(TableS, Order, color) + 1);
                                                    //Consideration of Prevention from going Check State by self order.
                                                    ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                    if (!UsePenaltyRegardMechnisam)
                                                        if (AA.Check(TableS, Order))
                                                        {
                                                            if (Order == 1 && AA.CheckGray)
                                                                continue;
                                                            else if (Order == -1 && AA.CheckBrown)
                                                                continue;

                                                        }
                                                    if (IgnoreObjectDangour == 0)
                                                        IgnoreObjectDangour = 1;

                                                    if (AA.CheckMate(TableS, Order))
                                                    {

                                                        if (Order == 1 && AA.CheckMateBrown)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                        }
                                                        if (Order == -1 && AA.CheckMateGray)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                        }
                                                        if (Order == 1 && AA.CheckMateGray)
                                                        {
                                                            FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                        }
                                                        if (Order == -1 && AA.CheckMateBrown)
                                                        {
                                                            FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                        }
                                                    }
                                                    if (AA.ObjectDangourKingMove(Order, TableS, false))
                                                    {

                                                        if (Order == 1 && AA.CheckGrayObjectDangour)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true;
                                                            AchamazCurrent = true;
                                                        }
                                                        if (Order == -1 && AA.CheckBrownObjectDangour)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true;
                                                            AchamazCurrent = true;
                                                        }
                                                    }
                                                    ///Consideration of Itterative Movments to ignore.
                                                    if (ThinkingChess.ExistTableInList(TableS, TableListHourse, 0))
                                                    {
                                                        ///Set Predict Huristic and Movments Backward.
                                                        TableS[ii, jj] = TableS[i, j];
                                                        TableS[i, j] = 0;
                                                        HuristicValue = 0;
                                                        HuristicValueMovement = 0;
                                                        HuristicValueSelfSupported = 0;
                                                        HuristicValueObjectDangourCheckMate = 0;

                                                        continue;
                                                    }
                                                    ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                                    if (Current.IsPenaltyAction() != 0 && UsePenaltyRegardMechnisam && PenaltyRegardListHourse.Count == TableListHourse.Count)
                                                    {
                                                        ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                        if (A.Check(TableS, Order))
                                                        {
                                                            if (Order == 1 && (A.CheckGray))
                                                                Current.LearningAlgorithmPenalty();
                                                            else
                                                                if (Order == -1 && (A.CheckBrown))
                                                                    Current.LearningAlgorithmPenalty();
                                                            PenaltyRegardListHourse.Add(Current);
                                                        }
                                                        else
                                                        {
                                                            if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                            {
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListHourse.Add(Current);
                                                            }
                                                            else
                                                                PenaltyRegardListHourse.Add(Current);
                                                        }
                                                    }
                                                    else
                                                        PenaltyRegardListHourse.Add(Current);
                                                    ///Store of Indexes Changes and Table in specific List.
                                                    SelfSupported = false;
                                                    InAttackedNotSelfSupported = false;
                                                    ///Wehn Predict of Operation Do operate a Predict of this movments.
                                                    //if (PredictHuristic)

                                                    if (UsePenaltyRegardMechnisam && PenaltyRegardListHourse.Count == TableListHourse.Count //+ 1)
                                                    {
                                                        //For Not Suppored In Attacked.
                                                        if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                                        {
                                                            //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    //DontClearPenalty = true;
                                                                    PenaltyRegardListHourse.RemoveAt(PenaltyRegardListHourse.Count - 1);
                                                                    Current.LearningAlgorithmPenalty();
                                                                    PenaltyRegardListHourse.Add(Current);
                                                                }
                                                            }
                                                        }
                                                        //For Ocuuring Enemy Garding Objects.
                                                        if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                                        {
                                                            //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    PenaltyRegardListHourse.RemoveAt(PenaltyRegardListHourse.Count - 1);
                                                                    Current.LearningAlgorithmRegard();
                                                                    PenaltyRegardListHourse.Add(Current);
                                                                    //IgnoreAchmatPenalty = true;
                                                                }
                                                            }
                                                        }
                                                        //For Preventing of Self CheckMate.
                                                        if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                                        {
                                                            if (Current.IsPenaltyAction() != 0)
                                                            {
                                                                //DontClearPenalty = true;
                                                                PenaltyRegardListHourse.RemoveAt(PenaltyRegardListHourse.Count - 1);
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListHourse.Add(Current);
                                                            }
                                                        }
                                                        //For Ocuuring in Enemy CheckMate.
                                                        if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                                        {
                                                            if (Current.IsPenaltyAction() != 0)
                                                            {
                                                                PenaltyRegardListHourse.RemoveAt(PenaltyRegardListHourse.Count - 1);
                                                                Current.LearningAlgorithmRegard();
                                                                PenaltyRegardListHourse.Add(Current);
                                                                //IgnoreAchmatPenalty = true;
                                                            }
                                                        }
                                                        if (AchamazCurrent && IgnoreObjectDangour == 1)
                                                        {
                                                            PenaltyRegardListHourse.RemoveAt(PenaltyRegardListHourse.Count - 1);
                                                            Current.LearningAlgorithmPenalty();
                                                            PenaltyRegardListHourse.Add(Current);
                                                        }
                                                        bool IgnoreRemove = false;
                                                        if (AA.CheckGray && Order == 1)
                                                            IgnoreRemove = true;
                                                        else
                                                            if (AA.CheckBrown && Order == -1)
                                                                IgnoreRemove = true;

                                                        if (Current.IsPenaltyAction() == 0)if(RemovePenalty(TableS, Order, i, j))
                                                        {
                                                            Current = new QuantumAtamata(3, 3, 3);
                                                            PenaltyRegardListHourse.RemoveAt(PenaltyRegardListHourse.Count - 1);
                                                            PenaltyRegardListHourse.Add(Current);
                                                        }

                                                    }

                                                     */ 
                                                    TableS[i, j] = TableS[ii, jj];
                                                    TableS[ii, jj] = 0;
                                                    if (UsePenaltyRegardMechnisam && PenaltyRegardListHourse.Count == TableListHourse.Count //+ 1)
                                                        )
                                                    {
                                                        //Mechanisam of Regrad. 
                                                        IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, i, j);
                                                        //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                        IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                        IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, i, j);

                                                        InAttackedEnemyNotSupporetd(TableS, Order, color, i, j, ii, jj);
                                                        InAttackedُSelfNotSupporetd(TableS, Order, color, i, j);
                                                        IsDangerous = IsAllTraversalHomeIsDangerous(TableS, i, j, ii, jj, Order, color);
                                                        //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, i, j);
                                                        //AttacakerVar2 = AttackerCount(TableS, Order, color, i, j);
                                                        //SupporterVar2 = SupporterCount(TableS, Order, color, i, j);
                                                        CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                                        InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                                        //NumbersOf = (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) && (!(EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0)) || (!(AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0)) && (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0); //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                                        //NumbersOfDangourous = NumbersOf;
                                                    }
                                                    //HourseValue = 3 * (VeryFye(TableS, Order, color) + 1);
                                                    //Consideration of Prevention from going Check State by self order.
                                                   ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                    if (!UsePenaltyRegardMechnisam)
                                                        if (AA.Check(TableS, Order))
                                                        {
                                                            if (Order == 1 && AA.CheckGray)
                                                                continue;
                                                            else if (Order == -1 && AA.CheckBrown)
                                                                continue;

                                                        }
                                                    if (IgnoreObjectDangour == 0)
                                                        IgnoreObjectDangour = 1;

                                                    if (AA.CheckMate(TableS, Order))
                                                    {

                                                        if (Order == 1 && AA.CheckMateBrown)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                        }
                                                        if (Order == -1 && AA.CheckMateGray)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                        }
                                                        if (Order == 1 && AA.CheckMateGray)
                                                        {
                                                            FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                        }
                                                        if (Order == -1 && AA.CheckMateBrown)
                                                        {
                                                            FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                        }
                                                    }
                                                    if (AA.ObjectDangourKingMove(Order, TableS, false))
                                                    {

                                                        if (Order == 1 && AA.CheckGrayObjectDangour)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true;
                                                            AchamazCurrent = true;
                                                        }
                                                        if (Order == -1 && AA.CheckBrownObjectDangour)
                                                        {
                                                            DoEnemySelf = false;
                                                            FoundFirstMating = true;
                                                            AchamazCurrent = true;
                                                        }
                                                    }
                                                    ///Consideration of Itterative Movments to ignore.
                                                    if (ThinkingChess.ExistTableInList(TableS, TableListHourse, 0))
                                                    {
                                                        ///Set Predict Huristic and Movments Backward.
                                                        TableS[ii, jj] = TableS[i, j];
                                                        TableS[i, j] = 0;
                                                        HuristicValue = 0;
                                                        HuristicValueMovement = 0;
                                                        HuristicValueSelfSupported = 0;
                                                        HuristicValueObjectDangourCheckMate = 0;

                                                        continue;
                                                    }
                                                    ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                                    if (Current.IsPenaltyAction() != 0 && UsePenaltyRegardMechnisam && PenaltyRegardListHourse.Count == TableListHourse.Count //+ 1)
                                                        )
                                                    {
                                                        //PenaltyRegardListHourse.RemoveAt(PenaltyRegardListHourse.Count - 1);
                                                        ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                        if (A.Check(TableS, Order))
                                                        {
                                                            if (Order == 1 && (A.CheckGray))
                                                                Current.LearningAlgorithmPenalty();
                                                            else
                                                                if (Order == -1 && (A.CheckBrown))
                                                                    Current.LearningAlgorithmPenalty();
                                                            PenaltyRegardListHourse.Add(Current);
                                                        }
                                                        else
                                                        {
                                                            if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                            {
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListHourse.Add(Current);
                                                            }
                                                            else
                                                                PenaltyRegardListHourse.Add(Current);
                                                        }
                                                    }
                                                    ///Store of Indexes Changes and Table in specific List.
                                                    int[] AS = new int[2];
                                                    AS[0] = i;
                                                    AS[1] = j;
                                                    RowColumnHourse.Add(AS);

                                                    ThinkingChess.RowColumn[Index, 0] = i;
                                                    ThinkingChess.RowColumn[Index, 1] = j;
                                                    Index++;
                                                    TableListHourse.Add(CloneATable(TableS)); ;
                                                    IndexHourse++;
                                                    //Row = i;
                                                    //Column = j;
                                                    SelfSupported = false;
                                                    InAttackedNotSelfSupported = false;
                                                    ///Wehn Predict of Operation Do operate a Predict of this movments.
                                                    //if (PredictHuristic)
                                                    {
                                                        HuristicAttack(TableS, Order, color);
                                                        HuristicMovment(TableS, color);
                                                        HuristicSelfSupported(TableS, Order, color);
                                                        HuristicCheckAndCheckMate(TableS, color);
                                                        //HuristicObjectDangour(TableS, Order, color);
                                                        HuristicHitting(TableS, i, j, Order, color, Hit);
                                                        HuristicReducsedAttack(TableS, Order, color);
                                                        HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, i, j);
                                                    }

                                                    if (UsePenaltyRegardMechnisam && PenaltyRegardListHourse.Count == TableListHourse.Count)
                                                    {
                                                        //For Not Suppored In Attacked.
                                                        if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                                        {
                                                            //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    //DontClearPenalty = true;
                                                                    PenaltyRegardListHourse.RemoveAt(PenaltyRegardListHourse.Count - 1);
                                                                    Current.LearningAlgorithmPenalty();
                                                                    PenaltyRegardListHourse.Add(Current);
                                                                }
                                                            }
                                                        }
                                                        //For Ocuuring Enemy Garding Objects.
                                                        if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                                        {
                                                            //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    PenaltyRegardListHourse.RemoveAt(PenaltyRegardListHourse.Count - 1);
                                                                    Current.LearningAlgorithmRegard();
                                                                    PenaltyRegardListHourse.Add(Current);
                                                                    //IgnoreAchmatPenalty = true;
                                                                }
                                                            }
                                                        }
                                                        //For Preventing of Self CheckMate.
                                                        if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                                        {
                                                            if (Current.IsPenaltyAction() != 0)
                                                            {
                                                                //DontClearPenalty = true;
                                                                PenaltyRegardListHourse.RemoveAt(PenaltyRegardListHourse.Count - 1);
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListHourse.Add(Current);
                                                            }
                                                        }
                                                        //For Ocuuring in Enemy CheckMate.
                                                        if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                                        {
                                                            if (Current.IsPenaltyAction() != 0)
                                                            {
                                                                PenaltyRegardListHourse.RemoveAt(PenaltyRegardListHourse.Count - 1);
                                                                Current.LearningAlgorithmRegard();
                                                                PenaltyRegardListHourse.Add(Current);
                                                                //IgnoreAchmatPenalty = true;
                                                            }
                                                        }
                                                        if (AchamazCurrent && IgnoreObjectDangour == 1)
                                                        {
                                                            PenaltyRegardListHourse.RemoveAt(PenaltyRegardListHourse.Count - 1);
                                                            Current.LearningAlgorithmPenalty();
                                                            PenaltyRegardListHourse.Add(Current);
                                                        }
                                                        bool IgnoreRemove = false;
                                                        if (AA.CheckGray && Order == 1)
                                                            IgnoreRemove = true;
                                                        else
                                                            if (AA.CheckBrown && Order == -1)
                                                                IgnoreRemove = true;

                                                        if (Current.IsPenaltyAction() == 0) if (RemovePenalty(TableS, Order, i, j))
                                                            {
                                                                Current = new QuantumAtamata(3, 3, 3);
                                                                PenaltyRegardListHourse.RemoveAt(PenaltyRegardListHourse.Count - 1);
                                                                PenaltyRegardListHourse.Add(Current);
                                                            }

                                                    }
                                                    else
                                                        PenaltyRegardListHourse.Add(Current);
                                                    //Calculate Huristic and Add to List and Cal Syntax.
                                                    double[] Hu = new double[4];
                                                    Hu[0] = HuristicValue;
                                                    Hu[1] = HuristicValueMovement;
                                                    Hu[2] = HuristicValueSelfSupported;
                                                    Hu[3] = HuristicValueObjectDangourCheckMate;
                                                    HuristicListHourse.Add(Hu);
                                                    /* if (Order == 1)
                                                         AllDraw.SyntaxToWrite = (new ChessRules()).CreateStatistic(TableS, FormRefrigtz.MovmentsNumber, 3, j, i, Hit, HitNumber, ChessRules.BridgeActBrown, false);
                                                     else
                                                         AllDraw.SyntaxToWrite = (new ChessRules()).CreateStatistic(TableS, FormRefrigtz.MovmentsNumber, -3, j, i, Hit, HitNumber, ChessRules.BridgeActBrown, false);
                                                     AllDraw.SyntaxToWrite += "Huristic :" + (Hu[0] + Hu[1] + Hu[2] + Hu[3]).ToString();
                                                     */
                                                    /*if (FormRefrigtz.ProfesionalWithComputer)
                                                    {
                                                        if (Order == 1)
                                                            ChessRules.CurrentOrder = -1;
                                                        else
                                                            ChessRules.CurrentOrder = 1;
                                                        this.AStarGreedy.Clear();
                                                        //this.AStarGreedy[0].TableList.Clear();
                                                        this.AStarGreedy.Add(new AllDraw(ref THIS));
                                                        this.AStarGreedy[0].TableList.Add(CloneATable(TableS)); ;
                                                        this.AStarGreedy[0].SetRowColumn(0);
                                                        if (Order == 1)
                                                            this.AStarGreedy[0].Initiate(i, j, color, TableS, -1, false, ref THIS.TimerText, ref THIS.BrownTimer);
                                                        else
                                                            this.AStarGreedy[0].Initiate(i, j, color, TableS, 1, false, ref THIS.TimerText, ref THIS.GrayTimer);
                                                    }
                                                     */ 
                                                }
                                            }
                                            ///Else For Bridges Thinking.
                                            else
                                                if (Scop(ii, jj, i, j, 4) && System.Math.Abs(TableS[ii, jj]) == 4 && System.Math.Abs(Kind) == 4)
                                                {
                                                    Order = DummyOrder;
                                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                                    ///When There is Movments.
                                                    if ((new ChessRules(TableS[ii, jj], TableS, Order, ii, jj)).Rules(ii, jj, i, j, color, TableS[ii, jj]))
                                                    {
                                                        //int EnemyVarAttacker1 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                                        //int AttacakerVar1 = AttackerCount(TableS, Order, color, ii, jj);
                                                        //int SupporterVar1 = SupporterCount(TableS, Order, color, ii, jj);
                                                        //BridgeValue = 5 * (VeryFye(TableS, Order, color) + 1);
                                                        ///Calculate Hit Occured and Value of Object.
                                                        bool Hit = false;
                                                        int HitNumber = TableS[i, j];
                                                        if (System.Math.Abs(TableS[i, j]) > 0)
                                                            Hit = true;
                                                        ///Add Table to List of Private.
                                                        HitNumberBridge.Add(TableS[i, j]);
                                                        ThinkingRun = true;
                                                        ///Predict Huristic.
                                                        HuristicAttack(TableS, Order, color);
                                                        HuristicMovment(TableS, color);
                                                        HuristicSelfSupported(TableS, Order, color);
                                                        HuristicCheckAndCheckMate(TableS, color);
                                                        //HuristicObjectDangour(TableS, Order, color);
                                                        HuristicHitting(TableS, ii, jj, Order, color, Hit);
                                                        HuristicReducsedAttack(TableS, Order, color);
                                                        HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, ii, jj);
                                                        bool IsSuitbale = new bool();
                                                        bool IsGardNotMovable = new bool();
                                                        bool IsNextMovemntIsCheckOrCheckMateForCurrent = new bool();
                                                        bool IsDangerous = new bool();
                                                        //int EnemyVarAttacker2 = new int();
                                                        //int AttacakerVar2 = new int();
                                                        //int SupporterVar2 = new int();
                                                        bool CanHittingAnUnSupportedEnemy = new bool();
                                                        bool InDangrousUnSupported = new bool();
                                                        //bool NumbersOf = new bool();
                                                        //bool NumbersOfDangourous = new bool();
                                                        ///Action of Movements.
                                                        /*if (UsePenaltyRegardMechnisam && PenaltyRegardListBridge.Count == TableListBridge.Count)
                                                        {

                                                            //IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                                            //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                            //IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                            //IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                                        }
                                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListBridge.Count == TableListBridge.Count)
                                                        {
                                                            //Mechanisam of Regrad.

                                                            IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                                            //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                            IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, ii, jj);
                                                            IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                                            InAttackedEnemyNotSupporetd(TableS, Order, color, ii, jj, i, j);
                                                            InAttackedُSelfNotSupporetd(TableS, Order, color, ii, jj);
                                                            IsDangerous = IsAllTraversalHomeIsDangerous(TableS, ii, jj, i, j, Order, color);
                                                            //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                                            //AttacakerVar2 = AttackerCount(TableS, Order, color, ii, jj);
                                                            //SupporterVar2 = SupporterCount(TableS, Order, color, ii, jj);

                                                            CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                                            InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                                            //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                                            //NumbersOfDangourous = NumbersOf;

                                                        }    //BridgeValue = 5 * (VeryFye(TableS, Order, color) + 1);
                                                        //Consideration of Prevention from going Check State by self order.
                                                        ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                        if (!UsePenaltyRegardMechnisam)
                                                            if (AA.Check(TableS, Order))
                                                            {
                                                                if (Order == 1 && AA.CheckGray)
                                                                    continue;
                                                                else
                                                                    if (Order == -1 && AA.CheckBrown)
                                                                        continue;
                                                            }
                                                        if (IgnoreObjectDangour == 0)
                                                            IgnoreObjectDangour = 1;

                                                        if (AA.CheckMate(TableS, Order))
                                                        {

                                                            if (Order == 1 && AA.CheckMateBrown)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                            }
                                                            if (Order == -1 && AA.CheckMateGray)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                            }
                                                            if (Order == 1 && AA.CheckMateGray)
                                                            {
                                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                            }
                                                            if (Order == -1 && AA.CheckMateBrown)
                                                            {
                                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                            }
                                                        }
                                                        if (AA.ObjectDangourKingMove(Order, TableS, false))
                                                        {

                                                            if (Order == 1 && AA.CheckGrayObjectDangour)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true;
                                                                AchamazCurrent = true;
                                                            }
                                                            if (Order == -1 && AA.CheckBrownObjectDangour)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true;
                                                                AchamazCurrent = true;
                                                            }
                                                        }
                                                        ///Consideration of Itterative Movments to ignore.
                                                        if (ExistTableInList(TableS, TableListBridge, 0))
                                                        {
                                                            ///Set Predict Huristic and Movments Backward.
                                                            TableS[ii, jj] = TableS[i, j];
                                                            TableS[i, j] = 0;
                                                            HuristicValue = 0;
                                                            HuristicValueMovement = 0;
                                                            HuristicValueSelfSupported = 0;
                                                            HuristicValueObjectDangourCheckMate = 0;
                                                            HuristicReducsedAttack(TableS, Order, color);

                                                            continue;
                                                        }
                                                        ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                                        if (Current.IsPenaltyAction() != 0 && UsePenaltyRegardMechnisam && PenaltyRegardListBridge.Count == TableListBridge.Count)
                                                        {
                                                            ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                            if (A.Check(TableS, Order))
                                                            {
                                                                if (Order == 1 && (A.CheckGray))
                                                                    Current.LearningAlgorithmPenalty();
                                                                else
                                                                    if (Order == -1 && (A.CheckBrown))
                                                                        Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListBridge.Add(Current);
                                                            }
                                                            else
                                                            {
                                                                if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                                {
                                                                    Current.LearningAlgorithmPenalty();
                                                                    PenaltyRegardListBridge.Add(Current);
                                                                }
                                                                else
                                                                    PenaltyRegardListBridge.Add(Current);
                                                            }

                                                        }
                                                        else
                                                            PenaltyRegardListBridge.Add(Current);
                                                        ///Store of Indexes Changes and Table in specific List.
                                                        //Row = i;
                                                        //Column = j;
                                                        SelfSupported = false;
                                                        InAttackedNotSelfSupported = false;
                                                        ///Wehn Predict of Operation Do operate a Predict of this movments.
                                                        //if (PredictHuristic)

                                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListBridge.Count == TableListBridge.Count //+ 1)
                                                        {
                                                            //For Not Suppored In Attacked.
                                                            if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                                            {
                                                                //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                                {
                                                                    if (Current.IsPenaltyAction() != 0)
                                                                    {
                                                                        //DontClearPenalty = true;
                                                                        PenaltyRegardListBridge.RemoveAt(PenaltyRegardListBridge.Count - 1);
                                                                        Current.LearningAlgorithmPenalty();
                                                                        PenaltyRegardListBridge.Add(Current);
                                                                    }
                                                                }
                                                            }
                                                            //For Ocuuring Enemy Garding Objects.
                                                            if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                                            {
                                                                //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                                {
                                                                    if (Current.IsPenaltyAction() != 0)
                                                                    {
                                                                        PenaltyRegardListBridge.RemoveAt(PenaltyRegardListBridge.Count - 1);
                                                                        Current.LearningAlgorithmRegard();
                                                                        PenaltyRegardListBridge.Add(Current);
                                                                        //IgnoreAchmatPenalty = true;
                                                                    }
                                                                }
                                                            }
                                                            //For Preventing of Self CheckMate.
                                                            if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    //DontClearPenalty = true;
                                                                    PenaltyRegardListBridge.RemoveAt(PenaltyRegardListBridge.Count - 1);
                                                                    Current.LearningAlgorithmPenalty();
                                                                    PenaltyRegardListBridge.Add(Current);
                                                                }
                                                            }
                                                            //For Ocuuring in Enemy CheckMate.
                                                            if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    PenaltyRegardListBridge.RemoveAt(PenaltyRegardListBridge.Count - 1);
                                                                    Current.LearningAlgorithmRegard();
                                                                    PenaltyRegardListBridge.Add(Current);
                                                                    //IgnoreAchmatPenalty = true;
                                                                }
                                                            }
                                                            if (AchamazCurrent && IgnoreObjectDangour == 1)
                                                            {
                                                                PenaltyRegardListBridge.RemoveAt(PenaltyRegardListBridge.Count - 1);
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListBridge.Add(Current);
                                                            }
                                                            bool IgnoreRemove = false;
                                                            if (AA.CheckGray && Order == 1)
                                                                IgnoreRemove = true;
                                                            else
                                                                if (AA.CheckBrown && Order == -1)
                                                                    IgnoreRemove = true;

                                                            if (Current.IsPenaltyAction() == 0)if(RemovePenalty(TableS, Order, i, j))
                                                            {
                                                                Current = new QuantumAtamata(3, 3, 3);
                                                                PenaltyRegardListBridge.RemoveAt(PenaltyRegardListBridge.Count - 1);
                                                                PenaltyRegardListBridge.Add(Current);
                                                            }

                                                        }

                                                         */ 
                                                        TableS[i, j] = TableS[ii, jj];
                                                        TableS[ii, jj] = 0;
                                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListBridge.Count == TableListBridge.Count //+ 1)
                                                            )
                                                        {
                                                            //Mechanisam of Regrad.   
                                                            IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, i, j);
                                                            //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                            IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                            IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, i, j);

                                                            InAttackedEnemyNotSupporetd(TableS, Order, color, i, j, ii, jj);
                                                            InAttackedُSelfNotSupporetd(TableS, Order, color, i, j);
                                                            IsDangerous = IsAllTraversalHomeIsDangerous(TableS, i, j, ii, jj, Order, color);
                                                            //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, i, j);
                                                            //AttacakerVar2 = AttackerCount(TableS, Order, color, i, j);
                                                            //SupporterVar2 = SupporterCount(TableS, Order, color, i, j);
                                                            CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                                            InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                                            //NumbersOf = (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) && (!(EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0)) || (!(AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0)) && (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0); //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                                            //NumbersOfDangourous = NumbersOf;
                                                        }
                                                        //BridgeValue = 5 * (VeryFye(TableS, Order, color) + 1);
                                                        //Consideration of Prevention from going Check State by self order.
                                                       ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                        if (!UsePenaltyRegardMechnisam)
                                                            if (AA.Check(TableS, Order))
                                                            {
                                                                if (Order == 1 && AA.CheckGray)
                                                                    continue;
                                                                else
                                                                    if (Order == -1 && AA.CheckBrown)
                                                                        continue;
                                                            }
                                                        if (IgnoreObjectDangour == 0)
                                                            IgnoreObjectDangour = 1;

                                                        if (AA.CheckMate(TableS, Order))
                                                        {

                                                            if (Order == 1 && AA.CheckMateBrown)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                            }
                                                            if (Order == -1 && AA.CheckMateGray)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                            }
                                                            if (Order == 1 && AA.CheckMateGray)
                                                            {
                                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                            }
                                                            if (Order == -1 && AA.CheckMateBrown)
                                                            {
                                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                            }
                                                        }
                                                        if (AA.ObjectDangourKingMove(Order, TableS, false))
                                                        {

                                                            if (Order == 1 && AA.CheckGrayObjectDangour)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true;
                                                                AchamazCurrent = true;
                                                            }
                                                            if (Order == -1 && AA.CheckBrownObjectDangour)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true;
                                                                AchamazCurrent = true;
                                                            }
                                                        }
                                                        ///Consideration of Itterative Movments to ignore.
                                                        if (ExistTableInList(TableS, TableListBridge, 0))
                                                        {
                                                            ///Set Predict Huristic and Movments Backward.
                                                            TableS[ii, jj] = TableS[i, j];
                                                            TableS[i, j] = 0;
                                                            HuristicValue = 0;
                                                            HuristicValueMovement = 0;
                                                            HuristicValueSelfSupported = 0;
                                                            HuristicValueObjectDangourCheckMate = 0;
                                                            HuristicReducsedAttack(TableS, Order, color);

                                                            continue;
                                                        }
                                                        ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                                        if (Current.IsPenaltyAction() != 0 && UsePenaltyRegardMechnisam && PenaltyRegardListBridge.Count == TableListBridge.Count //+ 1)
                                                            )
                                                        {
                                                            //PenaltyRegardListBridge.RemoveAt(PenaltyRegardListBridge.Count - 1);
                                                            ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                            if (A.Check(TableS, Order))
                                                            {
                                                                if (Order == 1 && (A.CheckGray))
                                                                    Current.LearningAlgorithmPenalty();
                                                                else
                                                                    if (Order == -1 && (A.CheckBrown))
                                                                        Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListBridge.Add(Current);
                                                            }
                                                            else
                                                            {
                                                                if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                                {
                                                                    Current.LearningAlgorithmPenalty();
                                                                    PenaltyRegardListBridge.Add(Current);
                                                                }
                                                                else
                                                                    PenaltyRegardListBridge.Add(Current);
                                                            }

                                                        }
                                                        ///Store of Indexes Changes and Table in specific List.
                                                        int[] AS = new int[2];
                                                        AS[0] = i;
                                                        AS[1] = j;
                                                        RowColumnBridge.Add(AS);
                                                        ThinkingChess.RowColumn[Index, 0] = i;
                                                        ThinkingChess.RowColumn[Index, 1] = j;
                                                        Index++;
                                                        TableListBridge.Add(CloneATable(TableS)); ;
                                                        IndexBridge++;
                                                        //Row = i;
                                                        //Column = j;
                                                        SelfSupported = false;
                                                        InAttackedNotSelfSupported = false;
                                                        ///Wehn Predict of Operation Do operate a Predict of this movments.
                                                        //if (PredictHuristic)
                                                        {
                                                            HuristicAttack(TableS, Order, color);
                                                            HuristicMovment(TableS, color);
                                                            HuristicSelfSupported(TableS, Order, color);
                                                            HuristicCheckAndCheckMate(TableS, color);
                                                            //HuristicObjectDangour(TableS, Order, color);
                                                            HuristicHitting(TableS, i, j, Order, color, Hit);
                                                            HuristicReducsedAttack(TableS, Order, color);
                                                            HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, i, j);

                                                        }

                                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListBridge.Count == TableListBridge.Count)
                                                        {
                                                            //For Not Suppored In Attacked.
                                                            if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                                            {
                                                                //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                                {
                                                                    if (Current.IsPenaltyAction() != 0)
                                                                    {
                                                                        //DontClearPenalty = true;
                                                                        PenaltyRegardListBridge.RemoveAt(PenaltyRegardListBridge.Count - 1);
                                                                        Current.LearningAlgorithmPenalty();
                                                                        PenaltyRegardListBridge.Add(Current);
                                                                    }
                                                                }
                                                            }
                                                            //For Ocuuring Enemy Garding Objects.
                                                            if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                                            {
                                                                //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                                {
                                                                    if (Current.IsPenaltyAction() != 0)
                                                                    {
                                                                        PenaltyRegardListBridge.RemoveAt(PenaltyRegardListBridge.Count - 1);
                                                                        Current.LearningAlgorithmRegard();
                                                                        PenaltyRegardListBridge.Add(Current);
                                                                        //IgnoreAchmatPenalty = true;
                                                                    }
                                                                }
                                                            }
                                                            //For Preventing of Self CheckMate.
                                                            if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    //DontClearPenalty = true;
                                                                    PenaltyRegardListBridge.RemoveAt(PenaltyRegardListBridge.Count - 1);
                                                                    Current.LearningAlgorithmPenalty();
                                                                    PenaltyRegardListBridge.Add(Current);
                                                                }
                                                            }
                                                            //For Ocuuring in Enemy CheckMate.
                                                            if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    PenaltyRegardListBridge.RemoveAt(PenaltyRegardListBridge.Count - 1);
                                                                    Current.LearningAlgorithmRegard();
                                                                    PenaltyRegardListBridge.Add(Current);
                                                                    //IgnoreAchmatPenalty = true;
                                                                }
                                                            }
                                                            if (AchamazCurrent && IgnoreObjectDangour == 1)
                                                            {
                                                                PenaltyRegardListBridge.RemoveAt(PenaltyRegardListBridge.Count - 1);
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListBridge.Add(Current);
                                                            }
                                                            bool IgnoreRemove = false;
                                                            if (AA.CheckGray && Order == 1)
                                                                IgnoreRemove = true;
                                                            else
                                                                if (AA.CheckBrown && Order == -1)
                                                                    IgnoreRemove = true;

                                                            if (Current.IsPenaltyAction() == 0)if(RemovePenalty(TableS, Order, i, j))
                                                            {
                                                                Current = new QuantumAtamata(3, 3, 3);
                                                                PenaltyRegardListBridge.RemoveAt(PenaltyRegardListBridge.Count - 1);
                                                                PenaltyRegardListBridge.Add(Current);
                                                            }

                                                        }
                                                        else
                                                            PenaltyRegardListBridge.Add(Current);
                                                        ///Calculate Huristic and Add to List Speciifically and Cal Syntax.
                                                        double[] Hu = new double[4];
                                                        Hu[0] = HuristicValue;
                                                        Hu[1] = HuristicValueMovement;
                                                        Hu[2] = HuristicValueSelfSupported;
                                                        Hu[3] = HuristicValueObjectDangourCheckMate;
                                                        HuristicListBridge.Add(Hu);
                                                        /*  if (Order == 1)
                                                              AllDraw.SyntaxToWrite = (new ChessRules()).CreateStatistic(TableS, FormRefrigtz.MovmentsNumber, 4, j, i, Hit, HitNumber, ChessRules.BridgeActBrown, false);
                                                          else
                                                              AllDraw.SyntaxToWrite = (new ChessRules()).CreateStatistic(TableS, FormRefrigtz.MovmentsNumber, -4, j, i, Hit, HitNumber, ChessRules.BridgeActBrown, false);
                                                          AllDraw.SyntaxToWrite += "Huristic :" + (Hu[0] + Hu[1] + Hu[2] + Hu[3]).ToString();
                                                         */
                                                        /*if (FormRefrigtz.ProfesionalWithComputer)
                                                        {
                                                            if (Order == 1)
                                                                ChessRules.CurrentOrder = -1;
                                                            else
                                                                ChessRules.CurrentOrder = 1;
                                                            this.AStarGreedy.Clear();
                                                            //this.AStarGreedy[0].TableList.Clear();
                                                            this.AStarGreedy.Add(new AllDraw(ref THIS));
                                                            this.AStarGreedy[0].TableList.Add(CloneATable(TableS)); ;
                                                            this.AStarGreedy[0].SetRowColumn(0);
                                                            if (Order == 1)
                                                                this.AStarGreedy[0].Initiate(i, j, color, TableS, -1, false, ref THIS.TimerText, ref THIS.BrownTimer);
                                                            else
                                                                this.AStarGreedy[0].Initiate(i, j, color, TableS, 1, false, ref THIS.TimerText, ref THIS.GrayTimer);
                                                        }
                                                         */ 
                                                    }
                                                }
                                                ///Else for Minister Thinkings.
                                                else if (Scop(ii, jj, i, j, 5) && System.Math.Abs(TableS[ii, jj]) == 5 && System.Math.Abs(Kind) == 5)
                                                {
                                                    Order = DummyOrder;
                                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                                    ///When There is Movments.
                                                    if ((new ChessRules(TableS[ii, jj], TableS, Order, ii, jj)).Rules(ii, jj, i, j, color, TableS[ii, jj]))
                                                    {
                                                        //int EnemyVarAttacker1 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                                        //int AttacakerVar1 = AttackerCount(TableS, Order, color, ii, jj);
                                                        //int SupporterVar1 = SupporterCount(TableS, Order, color, ii, jj);
                                                        //MinisterValue = 9 * (VeryFye(TableS, Order, color) + 1);
                                                        ///Calculate Hit Occured and Value of Object.
                                                        bool Hit = false;
                                                        int HitNumber = TableS[i, j];
                                                        if (System.Math.Abs(TableS[i, j]) > 0)
                                                            Hit = true;
                                                        ///Add Table to List of Private.
                                                        HitNumberMinister.Add(TableS[i, j]);
                                                        ThinkingRun = true;
                                                        ///Predict Huristic.
                                                        HuristicAttack(TableS, Order, color);
                                                        HuristicMovment(TableS, color);
                                                        HuristicSelfSupported(TableS, Order, color);
                                                        HuristicCheckAndCheckMate(TableS, color);
                                                        //HuristicObjectDangour(TableS, Order, color);
                                                        HuristicHitting(TableS, ii, jj, Order, color, Hit);
                                                        HuristicReducsedAttack(TableS, Order, color);
                                                        HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, ii, jj);
                                                        bool IsSuitbale = new bool();
                                                        bool IsGardNotMovable = new bool();
                                                        bool IsNextMovemntIsCheckOrCheckMateForCurrent = new bool();
                                                        bool IsDangerous = new bool();
                                                        //int EnemyVarAttacker2 = new int();
                                                        //int AttacakerVar2 = new int();
                                                        //int SupporterVar2 = new int();
                                                        bool CanHittingAnUnSupportedEnemy = new bool();
                                                        bool InDangrousUnSupported = new bool();
                                                        //bool NumbersOf = new bool();
                                                        //bool NumbersOfDangourous = new bool();
                                                        ///Action of Movements.
                                                        /*if (UsePenaltyRegardMechnisam && PenaltyRegardListMinister.Count == TableListMinister.Count)
                                                        {
                                                            //IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                                            //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                            //IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                            //IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                                        }
                                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListMinister.Count == TableListMinister.Count)
                                                        {
                                                            //Mechanisam of Regrad.

                                                            IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                                            //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                            IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, ii, jj);
                                                            IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                                            InAttackedEnemyNotSupporetd(TableS, Order, color, ii, jj, i, j);
                                                            InAttackedُSelfNotSupporetd(TableS, Order, color, ii, jj);
                                                            IsDangerous = IsAllTraversalHomeIsDangerous(TableS, ii, jj, i, j, Order, color);
                                                            //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                                            //AttacakerVar2 = AttackerCount(TableS, Order, color, ii, jj);
                                                            //SupporterVar2 = SupporterCount(TableS, Order, color, ii, jj);

                                                            CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                                            InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                                            //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                                            //NumbersOfDangourous = NumbersOf;

                                                        } //MinisterValue = 9 * (VeryFye(TableS, Order, color) + 1);
                                                        //Consideration of Prevention from going Check State by self order.
                                                        ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                        if (!UsePenaltyRegardMechnisam)
                                                            if (AA.Check(TableS, Order))
                                                            {
                                                                if (Order == 1 && AA.CheckGray)
                                                                    continue;

                                                                else if (Order == -1 && AA.CheckBrown)
                                                                    continue;
                                                            }
                                                        if (IgnoreObjectDangour == 0)
                                                            IgnoreObjectDangour = 1;
                                                        ///Consideration of Itterative Movments to ignore.
                                                        if (ExistTableInList(TableS, TableListMinister, 0))
                                                        {
                                                            ///Set Predict Huristic and Movments Backward.
                                                            TableS[ii, jj] = TableS[i, j];
                                                            TableS[i, j] = 0;
                                                            HuristicValue = 0;
                                                            HuristicValueMovement = 0;
                                                            HuristicValueSelfSupported = 0;
                                                            HuristicValueObjectDangourCheckMate = 0;

                                                            continue;
                                                        }
                                                        ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                                        if (Current.IsPenaltyAction() != 0 && UsePenaltyRegardMechnisam && PenaltyRegardListMinister.Count == TableListMinister.Count)
                                                        {
                                                            ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                            if (A.Check(TableS, Order))
                                                            {
                                                                if (Order == 1 && (A.CheckGray))
                                                                    Current.LearningAlgorithmPenalty();
                                                                else
                                                                    if (Order == -1 && (A.CheckBrown))
                                                                        Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListMinister.Add(Current);
                                                            }
                                                            else
                                                            {
                                                                if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                                {
                                                                    Current.LearningAlgorithmPenalty();
                                                                    PenaltyRegardListMinister.Add(Current);
                                                                }
                                                                else
                                                                    PenaltyRegardListMinister.Add(Current);
                                                            }

                                                        }
                                                        else
                                                            PenaltyRegardListMinister.Add(Current);
                                                        if (AA.CheckMate(TableS, Order))
                                                        {

                                                            if (Order == 1 && AA.CheckMateBrown)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                            }
                                                            if (Order == -1 && AA.CheckMateGray)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                            }
                                                            if (Order == 1 && AA.CheckMateGray)
                                                            {
                                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                            }
                                                            if (Order == -1 && AA.CheckMateBrown)
                                                            {
                                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                            }
                                                        }
                                                        if (AA.ObjectDangourKingMove(Order, TableS, false))
                                                        {

                                                            if (Order == 1 && AA.CheckGrayObjectDangour)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true;
                                                                AchamazCurrent = true;
                                                            }
                                                            if (Order == -1 && AA.CheckBrownObjectDangour)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true;
                                                                AchamazCurrent = true;
                                                            }
                                                        }
                                                        ///Store of Indexes Changes and Table in specific List.
                                                        //Row = i;
                                                        // Column = j;
                                                        SelfSupported = false;
                                                        InAttackedNotSelfSupported = false;
                                                        ///Wehn Predict of Operation Do operate a Predict of this movments.
                                                        //if (PredictHuristic)

                                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListMinister.Count == TableListMinister.Count //+ 1)
                                                        {
                                                            //For Not Suppored In Attacked.
                                                            if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                                            {
                                                                //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                                {
                                                                    if (Current.IsPenaltyAction() != 0)
                                                                    {
                                                                        //DontClearPenalty = true;
                                                                        PenaltyRegardListMinister.RemoveAt(PenaltyRegardListMinister.Count - 1);
                                                                        Current.LearningAlgorithmPenalty();
                                                                        PenaltyRegardListMinister.Add(Current);
                                                                    }
                                                                }
                                                            }
                                                            //For Ocuuring Enemy Garding Objects.
                                                            if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                                            {
                                                                //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                                {
                                                                    if (Current.IsPenaltyAction() != 0)
                                                                    {
                                                                        PenaltyRegardListMinister.RemoveAt(PenaltyRegardListMinister.Count - 1);
                                                                        Current.LearningAlgorithmRegard();
                                                                        PenaltyRegardListMinister.Add(Current);
                                                                        //IgnoreAchmatPenalty = true;
                                                                    }
                                                                }
                                                            }
                                                            //For Preventing of Self CheckMate.
                                                            if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    //DontClearPenalty = true;
                                                                    PenaltyRegardListMinister.RemoveAt(PenaltyRegardListMinister.Count - 1);
                                                                    Current.LearningAlgorithmPenalty();
                                                                    PenaltyRegardListMinister.Add(Current);
                                                                }
                                                            }
                                                            //For Ocuuring in Enemy CheckMate.7
                                                            if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    PenaltyRegardListMinister.RemoveAt(PenaltyRegardListMinister.Count - 1);
                                                                    Current.LearningAlgorithmRegard();
                                                                    PenaltyRegardListMinister.Add(Current);
                                                                    //ignoreAchmatPenalty = true;
                                                                }
                                                            }
                                                            if (AchamazCurrent && IgnoreObjectDangour == 1)
                                                            {
                                                                PenaltyRegardListMinister.RemoveAt(PenaltyRegardListMinister.Count - 1);
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListMinister.Add(Current);
                                                            }
                                                            bool IgnoreRemove = false;
                                                            if (AA.CheckGray && Order == 1)
                                                                IgnoreRemove = true;
                                                            else
                                                                if (AA.CheckBrown && Order == -1)
                                                                    IgnoreRemove = true;

                                                            if (Current.IsPenaltyAction() == 0)if(RemovePenalty(TableS, Order, i, j))
                                                            {
                                                                Current = new QuantumAtamata(3, 3, 3);
                                                                PenaltyRegardListMinister.RemoveAt(PenaltyRegardListMinister.Count - 1);
                                                                PenaltyRegardListMinister.Add(Current);
                                                            }
                                                        }

                                                         */ 
                                                        TableS[i, j] = TableS[ii, jj];
                                                        TableS[ii, jj] = 0;
                                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListMinister.Count == TableListMinister.Count //+ 1)
                                                            )
                                                        {
                                                            //Mechanisam of Regrad.     
                                                            IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, i, j);
                                                            //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                            IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                            IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, i, j);

                                                            InAttackedEnemyNotSupporetd(TableS, Order, color, i, j, ii, jj);
                                                            InAttackedُSelfNotSupporetd(TableS, Order, color, i, j);
                                                            IsDangerous = IsAllTraversalHomeIsDangerous(TableS, i, j, ii, jj, Order, color);
                                                            //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, i, j);
                                                            //AttacakerVar2 = AttackerCount(TableS, Order, color, i, j);
                                                            //SupporterVar2 = SupporterCount(TableS, Order, color, i, j);
                                                            CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                                            InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                                            //NumbersOf = (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) && (!(EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0)) || (!(AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0)) && (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0); //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                                            //NumbersOfDangourous = NumbersOf;
                                                        }
                                                        //MinisterValue = 9 * (VeryFye(TableS, Order, color) + 1);
                                                        //Consideration of Prevention from going Check State by self order.
                                                       ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                        if (!UsePenaltyRegardMechnisam)
                                                            if (AA.Check(TableS, Order))
                                                            {
                                                                if (Order == 1 && AA.CheckGray)
                                                                    continue;

                                                                else if (Order == -1 && AA.CheckBrown)
                                                                    continue;
                                                            }
                                                        if (IgnoreObjectDangour == 0)
                                                            IgnoreObjectDangour = 1;
                                                        ///Consideration of Itterative Movments to ignore.
                                                        if (ExistTableInList(TableS, TableListMinister, 0))
                                                        {
                                                            ///Set Predict Huristic and Movments Backward.
                                                            TableS[ii, jj] = TableS[i, j];
                                                            TableS[i, j] = 0;
                                                            HuristicValue = 0;
                                                            HuristicValueMovement = 0;
                                                            HuristicValueSelfSupported = 0;
                                                            HuristicValueObjectDangourCheckMate = 0;

                                                            continue;
                                                        }
                                                        ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                                        if (Current.IsPenaltyAction() != 0 && UsePenaltyRegardMechnisam && PenaltyRegardListMinister.Count == TableListMinister.Count //+ 1)
                                                            )
                                                        {
                                                           // PenaltyRegardListMinister.RemoveAt(PenaltyRegardListMinister.Count - 1);
                                                            ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                            if (A.Check(TableS, Order))
                                                            {
                                                                if (Order == 1 && (A.CheckGray))
                                                                    Current.LearningAlgorithmPenalty();
                                                                else
                                                                    if (Order == -1 && (A.CheckBrown))
                                                                        Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListMinister.Add(Current);
                                                            }
                                                            else
                                                            {
                                                                if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                                {
                                                                    Current.LearningAlgorithmPenalty();
                                                                    PenaltyRegardListMinister.Add(Current);
                                                                }
                                                                else
                                                                    PenaltyRegardListMinister.Add(Current);
                                                            }

                                                        }
                                                        if (AA.CheckMate(TableS, Order))
                                                        {

                                                            if (Order == 1 && AA.CheckMateBrown)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                            }
                                                            if (Order == -1 && AA.CheckMateGray)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                            }
                                                            if (Order == 1 && AA.CheckMateGray)
                                                            {
                                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                            }
                                                            if (Order == -1 && AA.CheckMateBrown)
                                                            {
                                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                            }
                                                        }
                                                        if (AA.ObjectDangourKingMove(Order, TableS, false))
                                                        {

                                                            if (Order == 1 && AA.CheckGrayObjectDangour)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true;
                                                                AchamazCurrent = true;
                                                            }
                                                            if (Order == -1 && AA.CheckBrownObjectDangour)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true;
                                                                AchamazCurrent = true;
                                                            }
                                                        }
                                                        ///Store of Indexes Changes and Table in specific List.
                                                        int[] AS = new int[2];
                                                        AS[0] = i;
                                                        AS[1] = j;
                                                        RowColumnMinister.Add(AS);
                                                        RowColumn[Index, 0] = i;
                                                        RowColumn[Index, 1] = j;
                                                        Index++;
                                                        TableListMinister.Add(CloneATable(TableS)); ;
                                                        IndexMinister++;
                                                        //Row = i;
                                                        // Column = j;
                                                        SelfSupported = false;
                                                        InAttackedNotSelfSupported = false;
                                                        ///Wehn Predict of Operation Do operate a Predict of this movments.
                                                        //if (PredictHuristic)
                                                        {
                                                            HuristicAttack(TableS, Order, color);
                                                            HuristicMovment(TableS, color);
                                                            HuristicSelfSupported(TableS, Order, color);
                                                            HuristicCheckAndCheckMate(TableS, color);
                                                            //HuristicObjectDangour(TableS, Order, color);
                                                            HuristicHitting(TableS, i, j, Order, color, Hit);
                                                            HuristicReducsedAttack(TableS, Order, color);
                                                            HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, i, j);
                                                        }

                                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListMinister.Count == TableListMinister.Count)
                                                        {
                                                            //For Not Suppored In Attacked.
                                                            if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                                            {
                                                                //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                                {
                                                                    if (Current.IsPenaltyAction() != 0)
                                                                    {
                                                                        //DontClearPenalty = true;
                                                                        PenaltyRegardListMinister.RemoveAt(PenaltyRegardListMinister.Count - 1);
                                                                        Current.LearningAlgorithmPenalty();
                                                                        PenaltyRegardListMinister.Add(Current);
                                                                    }
                                                                }
                                                            }
                                                            //For Ocuuring Enemy Garding Objects.
                                                            if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                                            {
                                                                //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                                {
                                                                    if (Current.IsPenaltyAction() != 0)
                                                                    {
                                                                        PenaltyRegardListMinister.RemoveAt(PenaltyRegardListMinister.Count - 1);
                                                                        Current.LearningAlgorithmRegard();
                                                                        PenaltyRegardListMinister.Add(Current);
                                                                        //IgnoreAchmatPenalty = true;
                                                                    }
                                                                }
                                                            }
                                                            //For Preventing of Self CheckMate.
                                                            if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    //DontClearPenalty = true;
                                                                    PenaltyRegardListMinister.RemoveAt(PenaltyRegardListMinister.Count - 1);
                                                                    Current.LearningAlgorithmPenalty();
                                                                    PenaltyRegardListMinister.Add(Current);
                                                                }
                                                            }
                                                            //For Ocuuring in Enemy CheckMate.7
                                                            if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    PenaltyRegardListMinister.RemoveAt(PenaltyRegardListMinister.Count - 1);
                                                                    Current.LearningAlgorithmRegard();
                                                                    PenaltyRegardListMinister.Add(Current);
                                                                    //ignoreAchmatPenalty = true;
                                                                }
                                                            }
                                                            if (AchamazCurrent && IgnoreObjectDangour == 1)
                                                            {
                                                                PenaltyRegardListMinister.RemoveAt(PenaltyRegardListMinister.Count - 1);
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListMinister.Add(Current);
                                                            }
                                                            bool IgnoreRemove = false;
                                                            if (AA.CheckGray && Order == 1)
                                                                IgnoreRemove = true;
                                                            else
                                                                if (AA.CheckBrown && Order == -1)
                                                                    IgnoreRemove = true;

                                                            if (Current.IsPenaltyAction() == 0) if (RemovePenalty(TableS, Order, i, j))
                                                                {
                                                                    Current = new QuantumAtamata(3, 3, 3);
                                                                    PenaltyRegardListMinister.RemoveAt(PenaltyRegardListMinister.Count - 1);
                                                                    PenaltyRegardListMinister.Add(Current);
                                                                }
                                                        }
                                                        else
                                                            PenaltyRegardListMinister.Add(Current);
                                                        ///Calculate Huristic and Add to List Speciifically and Cal Syntax.
                                                        double[] Hu = new double[4];
                                                        Hu[0] = HuristicValue;
                                                        Hu[1] = HuristicValueMovement;
                                                        Hu[2] = HuristicValueSelfSupported;
                                                        Hu[3] = HuristicValueObjectDangourCheckMate;
                                                        HuristicListMinister.Add(Hu);
                                                        /*if (Order == 1)
                                                            AllDraw.SyntaxToWrite = (new ChessRules()).CreateStatistic(TableS, FormRefrigtz.MovmentsNumber, 5, j, i, Hit, HitNumber, ChessRules.BridgeActBrown, false);
                                                        else
                                                            AllDraw.SyntaxToWrite = (new ChessRules()).CreateStatistic(TableS, FormRefrigtz.MovmentsNumber, -5, j, i, Hit, HitNumber, ChessRules.BridgeActBrown, false);
                                                        AllDraw.SyntaxToWrite += "Huristic :" + (Hu[0] + Hu[1] + Hu[2] + Hu[3]).ToString();
                                                         */
                                                        /*if (FormRefrigtz.ProfesionalWithComputer)
                                                        {
                                                            if (Order == 1)
                                                                ChessRules.CurrentOrder = -1;
                                                            else
                                                                ChessRules.CurrentOrder = 1;
                                                            this.AStarGreedy.Clear();
                                                            //this.AStarGreedy[0].TableList.Clear();
                                                            this.AStarGreedy.Add(new AllDraw(ref THIS));
                                                            this.AStarGreedy[0].TableList.Add(CloneATable(TableS)); ;
                                                            this.AStarGreedy[0].SetRowColumn(0);
                                                            if (Order == 1)
                                                                this.AStarGreedy[0].Initiate(i, j, color, TableS, -1, false, ref THIS.TimerText, ref THIS.BrownTimer);
                                                            else
                                                                this.AStarGreedy[0].Initiate(i, j, color, TableS, 1, false, ref THIS.TimerText, ref THIS.GrayTimer);
                                                        }
                                                         */ 
                                                    }
                                                }
                                                ///Else For Kings Thinkings.
                                                else if (Scop(ii, jj, i, j, 6) && System.Math.Abs(TableS[ii, jj]) == 6 && System.Math.Abs(Kind) == 6)
                                                {
                                                    Order = DummyOrder;
                                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                                    ///When There is Movments.
                                                    if ((new ChessRules(TableS[ii, jj], TableS, Order, ii, jj)).Rules(ii, jj, i, j, color, TableS[ii, jj]))
                                                    {
                                                        //int EnemyVarAttacker1 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                                        //int AttacakerVar1 = AttackerCount(TableS, Order, color, ii, jj);
                                                        //int SupporterVar1 = SupporterCount(TableS, Order, color, ii, jj);
                                                        //KingValue = 10 * (VeryFye(TableS, Order, color) + 1);
                                                        ///Calculate Hit Occured and Value of Object.
                                                        bool Hit = false;
                                                        int HitNumber = TableS[i, j];
                                                        if (System.Math.Abs(TableS[i, j]) > 0)
                                                            Hit = true;
                                                        ///Add Table to List of Private.
                                                        HitNumberKing.Add(TableS[i, j]);
                                                        ThinkingRun = true;
                                                        ///Predict Huristic.
                                                        HuristicAttack(TableS, Order, color);
                                                        HuristicMovment(TableS, color);
                                                        HuristicSelfSupported(TableS, Order, color);
                                                        HuristicCheckAndCheckMate(TableS, color);
                                                        //HuristicObjectDangour(TableS, Order, color);
                                                        HuristicHitting(TableS, ii, jj, Order, color, Hit);
                                                        HuristicReducsedAttack(TableS, Order, color);
                                                        HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, ii, jj);
                                                        bool IsSuitbale = new bool();
                                                        bool IsGardNotMovable = new bool();
                                                        bool IsNextMovemntIsCheckOrCheckMateForCurrent = new bool();
                                                        bool IsDangerous = new bool();
                                                        //int EnemyVarAttacker2 = new int();
                                                        //int AttacakerVar2 = new int();
                                                        //int SupporterVar2 = new int();
                                                        bool CanHittingAnUnSupportedEnemy = new bool();
                                                        bool InDangrousUnSupported = new bool();
                                                        //bool NumbersOf = new bool();
                                                        //bool NumbersOfDangourous = new bool();
                                                        /*if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count)
                                                        {

                                                            //IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                                            //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                            //IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                            //IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                                        }
                                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count)
                                                        {
                                                            //Mechanisam of Regrad.

                                                            IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, ii, jj);
                                                            //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                            IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, ii, jj);
                                                            IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, ii, jj);
                                                            InAttackedEnemyNotSupporetd(TableS, Order, color, ii, jj, i, j);
                                                            InAttackedُSelfNotSupporetd(TableS, Order, color, ii, jj);
                                                            IsDangerous = IsAllTraversalHomeIsDangerous(TableS, ii, jj, i, j, Order, color);
                                                            //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, ii, jj);
                                                            //AttacakerVar2 = AttackerCount(TableS, Order, color, ii, jj);
                                                            //SupporterVar2 = SupporterCount(TableS, Order, color, ii, jj);

                                                            CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                                            InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                                            //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                                            //NumbersOfDangourous = NumbersOf;

                                                        }    //KingValue = 10 * (VeryFye(TableS, Order, color) + 1);
                                                        int RowB = 0, ColumnB = 0;
                                                        int RowG = 0, ColumnG = 0;
                                                        AAA.FindBrownKing(TableS, ref RowB, ref ColumnB);
                                                        AAA.FindGrayKing(TableS, ref RowG, ref ColumnG);
                                                        bool ConvergenceofTowKMing = false;
                                                        //Gray Order.
                                                        //Illegal King Foundation.
                                                        if (System.Math.Abs(RowB - RowG) <= 1 && System.Math.Abs(ColumnB - ColumnG) <= 1)
                                                        {
                                                            Current.LearningAlgorithmPenalty();
                                                            PenaltyRegardListKing.Add(Current);
                                                            ConvergenceofTowKMing = true;
                                                        }

                                                        ///Consideration of Itterative Movments to ignore.
                                                        if (ExistTableInList(TableS, TableListKing, 0))
                                                        {
                                                            ///Set Predict Huristic and Movments Backward.
                                                            TableS[ii, jj] = TableS[i, j];
                                                            TableS[i, j] = 0;
                                                            HuristicValue = 0;
                                                            HuristicValueMovement = 0;
                                                            HuristicValueSelfSupported = 0;
                                                            HuristicValueObjectDangourCheckMate = 0;

                                                            continue;
                                                        }
                                                        //Consideration of Prevention from going Check State by self order.
                                                        ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                        if (!UsePenaltyRegardMechnisam)
                                                            if (AA.Check(TableS, Order))
                                                            {
                                                                if (Order == 1 && AA.CheckGray)
                                                                    continue;
                                                                else
                                                                    if (Order == -1 && AA.CheckBrown)
                                                                        continue;
                                                            }
                                                        if (IgnoreObjectDangour == 0)
                                                            IgnoreObjectDangour = 1;
                                                        if (AA.CheckMate(TableS, Order))
                                                        {

                                                            if (Order == 1 && AA.CheckMateBrown)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                            }
                                                            if (Order == -1 && AA.CheckMateGray)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                            }
                                                            if (Order == 1 && AA.CheckMateGray)
                                                            {
                                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                            }
                                                            if (Order == -1 && AA.CheckMateBrown)
                                                            {
                                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                            }
                                                        }
                                                        if (AA.ObjectDangourKingMove(Order, TableS, false))
                                                        {

                                                            if (Order == 1 && AA.CheckGrayObjectDangour)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true;
                                                                AchamazCurrent = true;
                                                            }
                                                            if (Order == -1 && AA.CheckBrownObjectDangour)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true;
                                                                AchamazCurrent = true;
                                                            }
                                                        }
                                                        ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                                        if (Current.IsPenaltyAction() != 0 && UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count && !ConvergenceofTowKMing)
                                                        {
                                                            ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                            if (A.Check(TableS, Order))
                                                            {
                                                                if (Order == 1 && (A.CheckGray))
                                                                    Current.LearningAlgorithmPenalty();
                                                                else
                                                                    if (Order == -1 && (A.CheckBrown))
                                                                        Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListKing.Add(Current);
                                                            }
                                                            else
                                                            {
                                                                if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                                {
                                                                    Current.LearningAlgorithmPenalty();
                                                                    PenaltyRegardListKing.Add(Current);
                                                                }
                                                                else
                                                                    PenaltyRegardListKing.Add(Current);
                                                            }

                                                        }
                                                        else if (!ConvergenceofTowKMing)
                                                            PenaltyRegardListKing.Add(Current);

                                                        ///Store of Indexes Changes and Table in specific List.
                                                        SelfSupported = false;
                                                        InAttackedNotSelfSupported = false;
                                                        //Calculate Movment Huristic After Movments.
                                                        //if (PredictHuristic)

                                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count //+ 1)
                                                        {
                                                            //For Not Suppored In Attacked.
                                                            if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                                            {
                                                                //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                                {
                                                                    if (Current.IsPenaltyAction() != 0)
                                                                    {
                                                                        //DontClearPenalty = true;
                                                                        PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                                        Current.LearningAlgorithmPenalty();
                                                                        PenaltyRegardListKing.Add(Current);
                                                                    }
                                                                }
                                                            }
                                                            //For Ocuuring in Enemy CheckMate.
                                                            if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                                    Current.LearningAlgorithmRegard();
                                                                    PenaltyRegardListKing.Add(Current);
                                                                    //IgnoreAchmatPenalty = true;
                                                                }
                                                            }
                                                            //For Preventing of Self CheckMate.
                                                            if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    //DontClearPenalty = true;
                                                                    PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                                    Current.LearningAlgorithmRegard();
                                                                    PenaltyRegardListKing.Add(Current);
                                                                    //IgnoreAchmatPenalty = true;
                                                                }
                                                            }
                                                            //For Ocuuring Enemy Garding Objects.
                                                            if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                                            {
                                                                //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                                {
                                                                    if (Current.IsPenaltyAction() != 0)
                                                                    {
                                                                        PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                                        Current.LearningAlgorithmRegard();
                                                                        PenaltyRegardListKing.Add(Current);
                                                                        //IgnoreAchmatPenalty = true;
                                                                    }
                                                                }
                                                            }
                                                            if (AchamazCurrent && IgnoreObjectDangour == 1)
                                                            {
                                                                PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListKing.Add(Current);
                                                            }
                                                            bool IgnoreRemove = false;
                                                            if (AA.CheckGray && Order == 1)
                                                                IgnoreRemove = true;
                                                            else
                                                                if (AA.CheckBrown && Order == -1)
                                                                    IgnoreRemove = true;

                                                            if (Current.IsPenaltyAction() == 0)if(RemovePenalty(TableS, Order, i, j))
                                                            {
                                                                Current = new QuantumAtamata(3, 3, 3);
                                                                PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                                PenaltyRegardListKing.Add(Current);
                                                            }

                                                        } 
                                                         */
                                                        ///Calculate Huristic and Add to List Speciifically and Cal Syntax.
                                                        ///Action of Movements.
                                                        TableS[i, j] = TableS[ii, jj];
                                                        TableS[ii, jj] = 0;
                                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count //+ 1)
                                                            )
                                                        {
                                                            //Mechanisam of Regrad.  
                                                            IsSuitbale = IsEnenmyInGardForCurrentMovmentsIsSuitable(TableS, Order, color, i, j);
                                                            //bool IsGard = IsGardForCurrentMovmentsRemained(TableS, Order, color, ii, jj);
                                                            IsGardNotMovable = IsGardForCurrentMovmentsAndIsNotMovable(TableS, Order, color, i, j);
                                                            IsNextMovemntIsCheckOrCheckMateForCurrent = IsNextMovmentIsCheckOrCheckMateForCurrentMovment(TableS, Order, color, i, j);

                                                            InAttackedEnemyNotSupporetd(TableS, Order, color, i, j, ii, jj);
                                                            InAttackedُSelfNotSupporetd(TableS, Order, color, i, j);
                                                            IsDangerous = IsAllTraversalHomeIsDangerous(TableS, i, j, ii, jj, Order, color);
                                                            //EnemyVarAttacker2 = EnemyAttackerCount(TableS, Order, color, i, j);
                                                            //AttacakerVar2 = AttackerCount(TableS, Order, color, i, j);
                                                            //SupporterVar2 = SupporterCount(TableS, Order, color, i, j);
                                                            CanHittingAnUnSupportedEnemy = EnemyNotSupported && InAttackedNotEnemySupported;
                                                            InDangrousUnSupported = IsDangerous || ((InAttackedNotSelfSupported && !SelfSupported)); if (CanHittingAnUnSupportedEnemy) InDangrousUnSupported = false;
                                                            //NumbersOf = (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) && (!(EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0)) || (!(AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0)) && (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0); //NumbersOf = ((SupporterVar1 > SupporterVar2 && SupporterVar1 != 0) || (AttacakerVar1 >= AttacakerVar2 && AttacakerVar1 != 0) || (EnemyVarAttacker1 <= EnemyVarAttacker2 && EnemyVarAttacker1 != 0));
                                                            //NumbersOfDangourous = NumbersOf;
                                                        }

                                                        //KingValue = 10 * (VeryFye(TableS, Order, color) + 1);
                                                        int RowB = 0, ColumnB = 0;
                                                        int RowG = 0, ColumnG = 0;
                                                        AAA.FindBrownKing(TableS, ref RowB, ref ColumnB);
                                                        AAA.FindGrayKing(TableS, ref RowG, ref ColumnG);
                                                        bool ConvergenceofTowKMing = false;
                                                        //Gray Order.
                                                        //Illegal King Foundation.
                                                        if (System.Math.Abs(RowB - RowG) <= 1 && System.Math.Abs(ColumnB - ColumnG) <= 1)
                                                        {
                                                            Current.LearningAlgorithmPenalty();
                                                            PenaltyRegardListKing.Add(Current);
                                                            ConvergenceofTowKMing = true;
                                                        }

                                                        ///Consideration of Itterative Movments to ignore.
                                                        if (ExistTableInList(TableS, TableListKing, 0))
                                                        {
                                                            ///Set Predict Huristic and Movments Backward.
                                                            TableS[ii, jj] = TableS[i, j];
                                                            TableS[i, j] = 0;
                                                            HuristicValue = 0;
                                                            HuristicValueMovement = 0;
                                                            HuristicValueSelfSupported = 0;
                                                            HuristicValueObjectDangourCheckMate = 0;

                                                            continue;
                                                        }
                                                        //Consideration of Prevention from going Check State by self order.
                                                       ChessRules AA = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                        if (!UsePenaltyRegardMechnisam)
                                                            if (AA.Check(TableS, Order))
                                                            {
                                                                if (Order == 1 && AA.CheckGray)
                                                                    continue;
                                                                else
                                                                    if (Order == -1 && AA.CheckBrown)
                                                                        continue;
                                                            }
                                                        if (IgnoreObjectDangour == 0)
                                                            IgnoreObjectDangour = 1;
                                                        if (AA.CheckMate(TableS, Order))
                                                        {

                                                            if (Order == 1 && AA.CheckMateBrown)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                            }
                                                            if (Order == -1 && AA.CheckMateGray)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true; SelfCheckMateAction = false; EnemyCheckMateAction = true;
                                                            }
                                                            if (Order == 1 && AA.CheckMateGray)
                                                            {
                                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                            }
                                                            if (Order == -1 && AA.CheckMateBrown)
                                                            {
                                                                FoundFirstMating = true; SelfCheckMateAction = true; EnemyCheckMateAction = false;
                                                            }
                                                        }
                                                        if (AA.ObjectDangourKingMove(Order, TableS, false))
                                                        {

                                                            if (Order == 1 && AA.CheckGrayObjectDangour)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true;
                                                                AchamazCurrent = true;
                                                            }
                                                            if (Order == -1 && AA.CheckBrownObjectDangour)
                                                            {
                                                                DoEnemySelf = false;
                                                                FoundFirstMating = true;
                                                                AchamazCurrent = true;
                                                            }
                                                        }
                                                        ///Operation of Penalty Regard Mechanisam on Check and mate speciffically.
                                                        if (Current.IsPenaltyAction() != 0 && UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count + 1 && !ConvergenceofTowKMing)
                                                        {

                                                            //PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                            ChessRules A = new ChessRules(TableS[ii, jj], TableS, Order, Row, Column);
                                                            if (A.Check(TableS, Order))
                                                            {
                                                                if (Order == 1 && (A.CheckGray))
                                                                    Current.LearningAlgorithmPenalty();
                                                                else
                                                                    if (Order == -1 && (A.CheckBrown))
                                                                        Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListKing.Add(Current);
                                                            }
                                                            else
                                                            {
                                                                if (IsCurrentStateIsDangreousForCurrentOrder(TableS, Order, color, i, j) && DoEnemySelf)
                                                                {
                                                                    Current.LearningAlgorithmPenalty();
                                                                    PenaltyRegardListKing.Add(Current);
                                                                }
                                                                else
                                                                    PenaltyRegardListKing.Add(Current);
                                                            }

                                                        }

                                                        ///Store of Indexes Changes and Table in specific List.
                                                        int[] AS = new int[2];
                                                        AS[0] = i;
                                                        AS[1] = j;
                                                        RowColumnKing.Add(AS);
                                                        RowColumn[Index, 0] = i;
                                                        RowColumn[Index, 1] = j;
                                                        Index++;
                                                        TableListKing.Add(CloneATable(TableS)); ;
                                                        IndexKing++;
                                                        //Row = i;
                                                        //Column = j;
                                                        SelfSupported = false;
                                                        InAttackedNotSelfSupported = false;
                                                        //Calculate Movment Huristic After Movments.
                                                        //if (PredictHuristic)
                                                        {
                                                            HuristicAttack(TableS, Order, color);
                                                            HuristicMovment(TableS, color);
                                                            HuristicSelfSupported(TableS, Order, color);
                                                            HuristicCheckAndCheckMate(TableS, color);
                                                            //HuristicObjectDangour(TableS, Order, color);
                                                            HuristicHitting(TableS, i, j, Order, color, Hit);
                                                            HuristicReducsedAttack(TableS, Order, color);
                                                            HeuristicDistabceOfCurrentMoveFromEnemyKing(TableS, Order, i, j);
                                                        }

                                                        if (UsePenaltyRegardMechnisam && PenaltyRegardListKing.Count == TableListKing.Count)
                                                        {
                                                            //For Not Suppored In Attacked.
                                                            if (InDangrousUnSupported || IsGardNotMovable || IsNextMovemntIsCheckOrCheckMateForCurrent)
                                                            {
                                                                //if (InAttackedNotSelfSupported || IsDangerous || IsGardNotMovable || !ExistingOfEnemyHiiting || IsNextMovemntIsCheckOrCheckMateForCurrent || SupporterVar1 > SupporterVar2 || AttacakerVar1 > AttacakerVar2 && EnemyVarAttacker1 < EnemyVarAttacker2)
                                                                {
                                                                    if (Current.IsPenaltyAction() != 0)
                                                                    {
                                                                        //DontClearPenalty = true;
                                                                        PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                                        Current.LearningAlgorithmPenalty();
                                                                        PenaltyRegardListKing.Add(Current);
                                                                    }
                                                                }
                                                            }
                                                            //For Ocuuring in Enemy CheckMate.
                                                            if (EnemyCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported) && Current.IsPenaltyAction() != 0)
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                                    Current.LearningAlgorithmRegard();
                                                                    PenaltyRegardListKing.Add(Current);
                                                                    //IgnoreAchmatPenalty = true;
                                                                }
                                                            }
                                                            //For Preventing of Self CheckMate.
                                                            if (SelfCheckMateAction && SelfSupported && (!InAttackedNotSelfSupported))
                                                            {
                                                                if (Current.IsPenaltyAction() != 0)
                                                                {
                                                                    //DontClearPenalty = true;
                                                                    PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                                    Current.LearningAlgorithmRegard();
                                                                    PenaltyRegardListKing.Add(Current);
                                                                    //IgnoreAchmatPenalty = true;
                                                                }
                                                            }
                                                            //For Ocuuring Enemy Garding Objects.
                                                            if (CanHittingAnUnSupportedEnemy && IsSuitbale && EnemyNotSupported && InAttackedNotEnemySupported && SelfSupported && (!InAttackedNotSelfSupported))
                                                            {
                                                                //if ((InAttackedNotEnemySupported || IsSuitbale || IsGard) && !IsDangerous)
                                                                {
                                                                    if (Current.IsPenaltyAction() != 0)
                                                                    {
                                                                        PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                                        Current.LearningAlgorithmRegard();
                                                                        PenaltyRegardListKing.Add(Current);
                                                                        //IgnoreAchmatPenalty = true;
                                                                    }
                                                                }
                                                            }
                                                            if (AchamazCurrent && IgnoreObjectDangour == 1)
                                                            {
                                                                PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                                Current.LearningAlgorithmPenalty();
                                                                PenaltyRegardListKing.Add(Current);
                                                            }
                                                            bool IgnoreRemove = false;
                                                            if (AA.CheckGray && Order == 1)
                                                                IgnoreRemove = true;
                                                            else
                                                                if (AA.CheckBrown && Order == -1)
                                                                    IgnoreRemove = true;

                                                            if (Current.IsPenaltyAction() == 0) if (RemovePenalty(TableS, Order, i, j))
                                                                {
                                                                    Current = new QuantumAtamata(3, 3, 3);
                                                                    PenaltyRegardListKing.RemoveAt(PenaltyRegardListKing.Count - 1);
                                                                    PenaltyRegardListKing.Add(Current);
                                                                }

                                                        }
                                                        else
                                                            PenaltyRegardListKing.Add(Current);///Calculate Huristic and Add to List Speciifically and Cal Syntax.
                                                        double[] Hu = new double[4];
                                                        Hu[0] = HuristicValue;
                                                        Hu[1] = HuristicValueMovement;
                                                        Hu[2] = HuristicValueSelfSupported;
                                                        Hu[3] = HuristicValueObjectDangourCheckMate;
                                                        HuristicListKing.Add(Hu);
                                                        /*if (Order == 1)
                                                            AllDraw.SyntaxToWrite = (new ChessRules()).CreateStatistic(TableS, FormRefrigtz.MovmentsNumber, 6, j, i, Hit, HitNumber, ChessRules.BridgeActBrown, false);
                                                        else
                                                            AllDraw.SyntaxToWrite = (new ChessRules()).CreateStatistic(TableS, FormRefrigtz.MovmentsNumber, -6, j, i, Hit, HitNumber, ChessRules.BridgeActBrown, false);
                                                        AllDraw.SyntaxToWrite += "Huristic :" + (Hu[0] + Hu[1] + Hu[2] + Hu[3]).ToString();
                                                         */
                                                       /* if (FormRefrigtz.ProfesionalWithComputer)
                                                        {
                                                            if (Order == 1)
                                                                ChessRules.CurrentOrder = -1;
                                                            else
                                                                ChessRules.CurrentOrder = 1;
                                                            this.AStarGreedy.Clear();
                                                            //this.AStarGreedy[0].TableList.Clear();
                                                            this.AStarGreedy.Add(new AllDraw(ref THIS));
                                                            this.AStarGreedy[0].TableList.Add(CloneATable(TableS)); ;
                                                            this.AStarGreedy[0].SetRowColumn(0);
                                                            if (Order == 1)
                                                                this.AStarGreedy[0].Initiate(i, j, color, TableS, -1, false, ref THIS.TimerText, ref THIS.BrownTimer);
                                                            else
                                                                this.AStarGreedy[0].Initiate(i, j, color, TableS, 1, false, ref THIS.TimerText, ref THIS.GrayTimer);
                                                        }
                                                        */ 
                                                    }
                                                }

                            }

                            ///Wehn Thinkings finished by Movments found breaks.
                            if (ThinkingFinished)
                                break;

                        }

                    }
                }
                ///Initiate Global Varibales at END.
                ThinkingBegin = false;
                ///This Variable Not Work! 
                ThinkingFinished = true;

            }
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            EndThread++;
            UsePenaltyRegardMechnisam = PenRegStrore;
            //Thread.Sleep(1);
            ///Return at End.
            return;
        }

    }
}


//End of Documentation.